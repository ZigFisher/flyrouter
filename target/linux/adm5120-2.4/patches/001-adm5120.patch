diff -urN linux-2.4.32/arch/mips/am5120/5120_int.c linux-2.4.32-adm5120/arch/mips/am5120/5120_int.c
--- linux-2.4.32/arch/mips/am5120/5120_int.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/5120_int.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000, 2001 MIPS Technologies, Inc.
+ * Copyright (C) 2001 Ralf Baechle
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Routines for generic manipulation of the interrupts found on the MIPS 
+ * Malta board.
+ * The interrupt controller is located in the South Bridge a PIIX4 device 
+ * with two internal 82C95 interrupt controllers.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/random.h>
+#include <linux/ioport.h>
+
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/gt64120.h>
+#include <asm/am5120/adm5120.h>
+
+
+
+extern asmlinkage void mipsIRQ(void);
+//extern asmlinkage void do_IRQ(int irq, struct pt_regs *regs);
+extern void set_debug_traps(void);
+extern void breakpoint(void);
+extern int remote_debug;
+static spinlock_t mips_irq_lock = SPIN_LOCK_UNLOCKED;
+
+
+void am5120_hw0_irqdispatch(struct pt_regs *regs)
+{
+	unsigned long flags;
+	unsigned long intsrc;
+	int i;
+
+	spin_lock_irqsave(&mips_irq_lock, flags);
+
+	intsrc = ADM5120_INTC_REG(IRQ_STATUS_REG) & IRQ_MASK;
+
+	for (i = 0; intsrc; intsrc >>= 1, i++)
+		if (intsrc & 0x1)
+			do_IRQ(i, regs);
+
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+}
+
diff -urN linux-2.4.32/arch/mips/am5120/5120_rtc.c linux-2.4.32-adm5120/arch/mips/am5120/5120_rtc.c
--- linux-2.4.32/arch/mips/am5120/5120_rtc.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/5120_rtc.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,53 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/5120_rtc.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+#include <linux/mc146818rtc.h>
+#include <asm/am5120/adm5120.h>
+
+static unsigned char am5120_rtc_read_data(unsigned long addr)
+{
+	//outb(addr, MALTA_RTC_ADR_REG);
+	//return inb(MALTA_RTC_DAT_REG);
+	return 0; //??
+}
+
+static void am5120_rtc_write_data(unsigned char data, unsigned long addr)
+{
+	//outb(addr, MALTA_RTC_ADR_REG);
+	//outb(data, MALTA_RTC_DAT_REG);
+}
+
+static int am5120_rtc_bcd_mode(void)
+{
+	return 0;
+}
+
+struct rtc_ops am5120_rtc_ops = {
+	&am5120_rtc_read_data,
+	&am5120_rtc_write_data,
+	&am5120_rtc_bcd_mode
+};
diff -urN linux-2.4.32/arch/mips/am5120/cmdline.c linux-2.4.32-adm5120/arch/mips/am5120/cmdline.c
--- linux-2.4.32/arch/mips/am5120/cmdline.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/cmdline.c	2005-12-20 12:51:45.000000000 +0200
@@ -0,0 +1,75 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/cmdline.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/string.h>
+
+#include <asm/bootinfo.h>
+
+extern int prom_argc;
+extern int *_prom_argv;
+
+/*
+ * YAMON (32-bit PROM) pass arguments and environment as 32-bit pointer.
+ * This macro take care of sign extension.
+ */
+#define prom_argv(index) ((char *)(((int *)(int)_prom_argv)[(index)]))
+
+char arcs_cmdline[CL_SIZE];
+
+char * __init prom_getcmdline(void)
+{
+	return &(arcs_cmdline[0]);
+}
+
+
+void  __init prom_init_cmdline(void)
+{
+	char *cp;
+	int actr;
+
+	actr = 1; /* Always ignore argv[0] */
+
+#ifdef CONFIG_CMDLINE
+    strcpy(&(arcs_cmdline[0]), CONFIG_CMDLINE/*"root=/dev/ram0 console=ttyS0"*/);
+#else
+
+	cp = &(arcs_cmdline[0]);
+
+	while(actr < prom_argc) 
+	{
+	    strcpy(cp, prom_argv(actr));
+		cp += strlen(prom_argv(actr));
+		*cp++ = ' ';
+		actr++;
+	}
+	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+		--cp;
+	*cp = '\0';
+#endif
+}
diff -urN linux-2.4.32/arch/mips/am5120/irq.c linux-2.4.32-adm5120/arch/mips/am5120/irq.c
--- linux-2.4.32/arch/mips/am5120/irq.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/irq.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,171 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/irq.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+
+;*****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+//#include <linux/malloc.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/gdb-stub.h>
+
+#include <asm/am5120/adm5120.h>
+
+
+extern void breakpoint(void);
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+extern irq_desc_t irq_desc[];
+extern asmlinkage void mipsIRQ(void);
+
+
+static __inline void _irq_enable(int irql)
+{
+	ADM5120_INTC_REG(IRQ_ENABLE_REG) = (1 << irql);
+}
+
+static __inline void _irq_disable(int irql)
+{
+	ADM5120_INTC_REG(IRQ_DISABLE_REG) = (1<<irql);
+}
+
+void enable_am5120_irq(unsigned int irq)
+{
+	int s;
+
+	// Disable all interrupts (FIQ/IRQ) 
+	s = mips_int_lock();
+
+	if ((irq < 0) || (irq > INT_LVL_MAX)) 
+		goto err_exit;
+
+	_irq_enable(irq);
+
+err_exit:
+
+	// Restore the interrupts states 
+	mips_int_unlock(s);
+}
+
+void disable_am5120_irq(unsigned int irq)
+{
+	int s;
+
+	// Disable all interrupts (FIQ/IRQ) 
+	s = mips_int_lock();
+
+	if ((irq < 0) || (irq > INT_LVL_MAX)) 
+		goto err_exit;
+
+	_irq_disable(irq);
+
+err_exit:
+	// Restore the interrupts states 
+	mips_int_unlock(s);
+}
+
+unsigned int startup_am5120_irq(unsigned int irq)
+{
+	enable_am5120_irq(irq);
+
+	return 0;
+}
+
+	
+void shutdown_am5120_irq(unsigned int irq)
+{
+	disable_am5120_irq(irq);
+}
+	
+static inline void ack_am5120_irq(unsigned int irq_nr)
+{
+	ADM5120_INTC_REG(IRQ_DISABLE_REG) = (1 << irq_nr);
+}
+
+
+static void end_am5120_irq(unsigned int irq_nr)
+{
+	ADM5120_INTC_REG(IRQ_ENABLE_REG) = (1 << irq_nr);
+}
+
+
+void set_affinity_am5120_irq(unsigned int irq, unsigned long mask)
+{
+	return;
+}
+
+
+static hw_irq_controller am5120_irq_type = {
+	"ADM5120 INTC",
+	startup_am5120_irq,
+	shutdown_am5120_irq,
+	enable_am5120_irq,
+	disable_am5120_irq,
+	ack_am5120_irq,
+	end_am5120_irq,
+	set_affinity_am5120_irq
+};
+
+
+void __init init_am5120_irqs (void)
+{
+	int i;
+
+	for (i = 0; i <= INT_LVL_MAX; i++) 
+	{
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &am5120_irq_type;
+	}
+}
+
+
+void __init init_IRQ(void)
+{
+	set_except_vector(0, mipsIRQ);
+	
+	init_generic_irq();
+	
+	init_am5120_irqs();
+
+#ifdef CONFIG_REMOTE_DEBUG
+ 	printk("Setting debug traps - please connect the remote debugger.\n");
+
+	set_debug_traps();
+
+	breakpoint();
+#endif
+}
+
diff -urN linux-2.4.32/arch/mips/am5120/led.c linux-2.4.32-adm5120/arch/mips/am5120/led.c
--- linux-2.4.32/arch/mips/am5120/led.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/led.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,497 @@
+/*
+ * LED interface for WP3200
+ *
+ * Copyright (C) 2002, by Allen Hung
+ *
+ * 2005.06.22 Joco: fixed some type conversion warnings
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/fcntl.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include "led.h"
+
+#define BUF_LEN		30
+
+struct LED_DATA  {
+    char sts_buf[BUF_LEN+1];
+    unsigned long sts;
+};
+
+struct LED_DATA led_data[LED_DEV_NUM];
+// sam 01-30-2004 for watchdog
+static struct timer_list watchdog;
+// end sam
+
+static struct timer_list blink_timer[LED_DEV_NUM];
+static char cmd_buf[BUF_LEN+1];
+
+//------------------------------------------------------------
+static long atoh(char *p) 
+{
+    long v = 0, c;
+    while ( (c = *p++) )  {
+        if      ( c >= '0' && c <= '9' )  v = (v << 4) + c - '0';
+        else if ( c >= 'a' && c <= 'f' )  v = (v << 4) + c - 'a' + 0xA;
+        else if ( c >= 'A' && c <= 'F' )  v = (v << 4) + c - 'A' + 0xA;
+        else  break;
+    }
+    return v;
+}
+
+
+#define GPIO_VAL		(*(unsigned long *)0xb20000b8)
+#define GPIO_SEL		(*(unsigned long *)0xb20000bc)
+#define GPIO_SEL_I_O 	(*(unsigned long *)0xb20000b8)
+#define GPIO_O_EN		(*(unsigned long *)0xb20000b8)
+#define INIT_WATCHDOG_REGISTER 0x20
+
+// sam 1-30-2004 LED status 
+// bit map as following
+// BIT 4:0  Link status   -->PHY Link ->1 = up, 0 = down
+#define LINK_STATUS     (*(unsigned long *)0xb2000014)
+#define WATCHDOG_VAL    (*(unsigned long *)0xb20000c0)
+#define WATCHDOG_PERIOD 2000 // unit ms
+#define EXPIRE_TIME     300 // unit 10 ms
+#define CLEAR_TIMEER    0xffffa000l  // bit 14:0 -> count up timer, write 0 to clear
+#define ENABLE_WATCHDOG 0x80000000l  // bit 31 -> 1 enable , 0 disable watchdog
+#define WATCHDOG_SET_TMR_SHIFT 16    // bit 16:30 -> watchdog timer set
+// end sam
+//------------------------------------------------------------
+static void turn_led(int id, int on)
+{
+    unsigned long led_bit,led_bit_val;
+    if(id <= 7 && id >= 0) {
+	    led_bit = 1 << (id);
+
+	    led_bit_val = led_bit << 24;
+	
+	    switch ( on ) {
+    		case 0:  GPIO_VAL |=  led_bit_val;	break; // LED OFF
+    		case 1:  GPIO_VAL &= ~led_bit_val;	break; // LED ON
+    		case 2:  GPIO_VAL ^=  led_bit_val;	break; // LED inverse
+	    }
+    }
+}
+
+static void blink_wrapper(u_long id)
+{
+    u_long sts = led_data[id].sts;
+    if ( (sts & LED_BLINK_CMD) == LED_BLINK_CMD )  {
+	int period = sts & LED_BLINK_PERIOD;
+	blink_timer[id].expires = jiffies + (period * HZ / 1000);
+	turn_led(id, 2);
+	add_timer(&blink_timer[id]);
+    }
+    else if ( sts == LED_ON || sts == LED_OFF )
+	turn_led(id, sts==LED_ON ? 1 : 0);
+}
+//------------------------------------------------------------
+static void get_token_str(char *str, char token[][21], int token_num)
+{
+    int t, i;
+    for ( t = 0 ; t < token_num ; t++ )  {
+    	memset(token[t], 0, 21);
+    	while ( *str == ' ' )  str++;
+    	for ( i = 0 ; str[i] ; i++ )  {
+    	    if ( str[i] == '\t' || str[i] == ' ' || str[i] == '\n' )  break;
+    	    if ( i < 20 )  token[t][i] = str[i];
+    	}
+    	str += i;
+    }
+}
+
+//------------------------------------------------------------
+static void set_led_status_by_str(int id)
+{
+    char token[3][21], *p;
+    get_token_str(led_data[id].sts_buf, token, 3);
+    if ( strcmp(token[0], "LED") )   
+        goto set_led_off;
+    if ( !strcmp(token[1], "ON") )  {
+    	turn_led(id, 1);
+    	led_data[id].sts = LED_ON;
+    }
+    else if ( !strcmp(token[1], "OFF") )  {
+	    goto set_led_off;
+    }
+    else if ( !strcmp(token[1], "BLINK") ) {
+    	int period = 0;
+    	p = token[2];
+    	if ( !strcmp(p, "FAST") )
+    	    period = LED_BLINK_FAST & LED_BLINK_PERIOD;
+    	else if ( !strcmp(p, "SLOW") )
+    	    period = LED_BLINK_SLOW & LED_BLINK_PERIOD;
+    	else if ( !strcmp(p, "EXTRA_SLOW") )
+    	    period = LED_BLINK_EXTRA_SLOW & LED_BLINK_PERIOD;
+    	else if ( !strcmp(p, "OFF") )
+	    goto set_led_off;
+	else if ( *p >= '0' && *p <= '9' )  {
+    	while ( *p >= '0' && *p <= '9' )
+    	    period = period * 10 + (*p++) - '0';
+    	if ( period > 10000 )  period = 10000;
+	}
+	else
+    	period = LED_BLINK & LED_BLINK_PERIOD;
+    	if ( period == 0 )
+    	    goto set_led_off;
+	    sprintf(led_data[id].sts_buf, "LED BLINK %d\n", period);
+    	led_data[id].sts = LED_BLINK_CMD + period;
+    	turn_led(id, 2);
+     // Set timer for next blink
+	    del_timer(&blink_timer[id]);
+        blink_timer[id].function = blink_wrapper;
+        blink_timer[id].data = id;
+        init_timer(&blink_timer[id]);
+        blink_timer[id].expires = jiffies + (period * HZ / 1000);
+        add_timer(&blink_timer[id]);
+    }
+    else
+        goto set_led_off;
+    return;
+  set_led_off:
+    strcpy(led_data[id].sts_buf, "LED OFF\n");
+    led_data[id].sts = LED_OFF;
+    turn_led(id, 0);
+}
+
+//----------------------------------------------------------------------
+static int led_read_proc(char *buf, char **start, off_t fpos, int length, int *eof, void *data)
+{
+    int len, dev;
+    for ( len = dev = 0 ; dev < LED_DEV_NUM ; dev++ )  {
+    	len += sprintf(buf+len, "%d: %s", dev, led_data[dev].sts_buf);
+    }
+    len = strlen(buf) - fpos;
+    if ( len <= 0 ) {
+	*start = buf;
+	*eof = 1;
+	return 0;
+    }
+    *start = buf + fpos;
+    if ( len <= length )   *eof = 1;
+    return len < length ? len : length;
+}
+
+//----------------------------------------------------------------------
+static int led_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    int id = (int)file->private_data;
+    switch ( cmd )  {
+      case LED_ON:
+    	strcpy(led_data[id].sts_buf, "LED ON\n");
+	set_led_status_by_str(id);
+	break;
+      case LED_OFF:
+    	strcpy(led_data[id].sts_buf, "LED OFF\n");
+	set_led_status_by_str(id);
+	break;
+      default:
+        if ( (cmd & LED_BLINK_CMD) != LED_BLINK_CMD )
+	    break;
+      case LED_BLINK:
+      case LED_BLINK_FAST:
+      case LED_BLINK_SLOW:
+      case LED_BLINK_EXTRA_SLOW:
+        sprintf(led_data[id].sts_buf, "LED BLINK %d\n", (int)(cmd & LED_BLINK_PERIOD));
+	set_led_status_by_str(id);
+	break;
+    }
+    return 0;
+}
+
+static int led_open(struct inode *inode, struct file *file)
+{
+    int led_id = MINOR(inode->i_rdev);
+    unsigned long led_bit = 1 << (led_id);
+
+    if ( led_id >= LED_DEV_NUM )
+        return -ENODEV;
+
+    GPIO_SEL_I_O &= ~led_bit;   // 0 to GPIO
+    GPIO_O_EN |= (led_bit << 16);   // 0 to Output
+	
+    file->private_data = (void*)led_id;
+    return 0;
+}
+
+static ssize_t led_read(struct file *file, char *buf, size_t count, loff_t *fpos)
+{
+    int  rem, len;
+    int  id = (int)file->private_data;
+    char *p = led_data[id].sts_buf;
+    len = strlen(p);
+    rem = len - *fpos;
+    if ( rem <= 0 )  {
+    	*fpos = len;
+    	return 0;
+    }
+    if ( rem > count )   rem = count;
+    memcpy(buf, p+(*fpos), rem);
+    *fpos += rem;
+    return rem;
+}
+
+static ssize_t led_write(struct file *file, const char *buf, size_t count, loff_t *fpos)
+{
+    int  len;
+    int  id = (int)file->private_data;
+    char *p = id == REG_MINOR ? cmd_buf : led_data[id].sts_buf;
+    memset(p, 0, BUF_LEN);
+    p += *fpos;
+    len = 0;
+    while ( count > 0 )  {
+    	if ( *fpos < BUF_LEN )  {
+    	    int c = *buf++;
+            p[len] = c>='a' && c<='z' ? c-'a'+'A' : c;
+        }
+    	(*fpos)++;
+	    len++;
+    	count--;
+    }
+    return len;
+}
+
+static int led_flush(struct file *file)
+{
+    int  id = (int)file->private_data;
+    if ( file->f_mode & FMODE_WRITE )
+    	set_led_status_by_str(id);
+    return 0;
+}
+
+static struct file_operations led_fops = {
+    read:	led_read,
+    write:	led_write,
+    flush:	led_flush,
+    ioctl:	led_ioctl,
+    open:	led_open,
+};
+
+//----------------------------------------------
+static unsigned long *reg_addr;
+static int  dump_len;
+
+static int dump_content(char *buf)
+{
+    int  i=0, j, len=0;
+    unsigned long *p = reg_addr;
+    j = dump_len/4 + ((dump_len&3) ? 1 : 0);
+    len = sprintf(buf, "Reg Addr = %08lX,  Value = ", (unsigned long)p);
+    for ( i = 0 ; i < j ; i++, p++ ) 
+        len += sprintf(buf+len,"%08lX%c", *p, (i&7)==7||i==j-1?'\n':' ');
+    return len;
+}
+
+static ssize_t gpio_read(struct file *file, char *buf, size_t count, loff_t *fpos)
+{
+    int  rem, len;
+    int  id = (int)file->private_data;
+    char temp[80*10];
+    if ( id < GPIO_DEV_NUM )  {
+        int  gpio_bit = 1 << id;
+        len = sprintf(temp, "%d\n", ((GPIO_VAL >> 8)&gpio_bit) ? 1 : 0);
+    }
+    else   // REG device
+        len = dump_content(temp);
+    rem = len - *fpos;
+    if ( rem <= 0 )  {
+    	*fpos = len;
+    	return 0;
+    }
+    if ( rem > count )   rem = count;
+    memcpy(buf, temp+(*fpos), rem);
+    *fpos += rem;
+    return rem;
+}
+
+static int gpio_flush(struct file *file)
+{
+    long v, addr;
+    int  id = (int)file->private_data;
+    if ( id == REG_MINOR && (file->f_mode & FMODE_WRITE) )  {
+        char token[3][21], *p;
+        get_token_str(cmd_buf, token, 3);
+        // get reg address
+        p = token[0];
+        if ( *p == 0 )   return 0;
+        addr = atoh(p);
+        //---------------------
+        p = token[1];
+        if ( *p == 'W' )  {
+            int width = 0;
+            if ( !strcmp(p, "W") || !strcmp(p, "WW") )
+                width = 4;
+            else if ( !strcmp(p, "WH") )
+                width = 2;
+            else if ( !strcmp(p, "WB") )
+                width = 1;
+            else
+                return 0;
+            p = token[2];
+            if ( *p == 0 )   return 0;
+            v = atoh(p);
+            switch ( width )  {
+              case 1:  *((char *)addr) = (v & 0xFF);    break;
+              case 2:  *((short*)addr) = (v & 0xFFFF);  break;
+              case 4:  *((long *)addr) =  v;            break;
+            }
+        }
+        else  { // get dump len
+            char temp[80*10];
+            reg_addr = (unsigned long *)(addr & ~3);
+            dump_len = 4;
+            if ( *p )   {
+                dump_len = atoh(p);
+                dump_len = dump_len < 4 ? 4 : dump_len > 32*10 ? 32*10 : dump_len;
+            }
+            dump_content(temp);
+            //printk( KERN_INFO "%s", temp);
+        }
+        cmd_buf[0] = 0;
+    }
+    return 0;
+}
+
+static int gpio_open(struct inode *inode, struct file *file)
+{
+    int id = MINOR(inode->i_rdev);
+    if ( id >= GPIO_DEV_NUM && id != REG_MINOR )
+        return -ENODEV;
+    if ( id < GPIO_DEV_NUM )  {
+        int gpio_bit = 1 << id;
+		
+		GPIO_SEL = 0;
+      	GPIO_SEL |= gpio_bit;   // bit=0 for GPIO
+    }
+    file->private_data = (void*)id;
+    return 0;
+}
+
+static struct file_operations gpio_fops = {
+    read:	gpio_read,
+    open:	gpio_open,
+    flush:	gpio_flush,
+    write:	led_write,
+};
+
+//----------------------------------------------
+static void watchdog_wrapper(unsigned long period)
+{
+	// clear timer count
+	WATCHDOG_VAL &= CLEAR_TIMEER;
+	watchdog.expires = jiffies + (period * HZ / 1000);
+	add_timer(&watchdog);
+}
+//----------------------------------------------
+static int init_status;
+
+#define INIT_REGION	        0x01
+#define INIT_LED_REGISTER	0x02
+#define INIT_LED_PROC_READ	0x04
+#define INIT_GPIO_REGISTER	0x08
+
+static void led_exit(void)
+{
+    int id;
+    for ( id = 0 ; id < LED_DEV_NUM ; id++ )  {
+        del_timer(&blink_timer[id]);
+        turn_led(id, 0);
+    }
+    if ( init_status & INIT_LED_PROC_READ )
+    	remove_proc_entry("driver/led", NULL);
+    	
+    if ( init_status & INIT_LED_REGISTER )
+    	unregister_chrdev(LED_MAJOR, "led");
+
+    if ( init_status & INIT_GPIO_REGISTER )
+    	unregister_chrdev(GPIO_MAJOR, "gpio");
+
+    if ( init_status & INIT_REGION )
+    	release_region(GPIO_IO_BASE, GPIO_IO_EXTENT);
+}
+
+static int __init led_init(void)
+{
+    int result, id;
+    init_status = 0;
+	
+  //---- request region --------------------------
+  /*
+    if ( check_region(GPIO_IO_BASE, GPIO_IO_EXTENT) )  {
+	    printk(KERN_ERR "gpio: I/O port %lX is not free.\n", GPIO_IO_BASE);
+	    return -EIO;
+    }
+    request_region(GPIO_IO_BASE, GPIO_IO_EXTENT, "gpio");
+    init_status |= INIT_REGION;
+  */
+  //----- register device (LED)-------------------------
+    result = register_chrdev(LED_MAJOR, "led", &led_fops);
+    if ( result < 0 )   {
+    	printk(KERN_ERR "led: can't register char device\n" );
+    	led_exit();
+    	return result;
+    }
+    init_status |= INIT_LED_REGISTER;
+  //----- register device (GPIO)-------------------------
+    result = register_chrdev(GPIO_MAJOR, "gpio", &gpio_fops);
+    if ( result < 0 )   {
+    	printk(KERN_ERR "gpio: can't register char device\n" );
+    	led_exit();
+    	return result;
+    }
+    init_status |= INIT_GPIO_REGISTER;
+  // sam 1-30-2004 LAN Status
+  // ----- register device (LAN_STATUS)-------------------
+/*    result = register_chrdev(LAN_STATUS_MAJOR, "lanSt", &lanSt_fops);
+    if ( result < 0 )   {
+    	printk(KERN_ERR "lanSt: can't register char device\n" );
+    	led_exit();
+    	return result;
+    }
+    init_status |= INIT_LAN_STATUS_REGISTER;
+	*/
+ // -----------init watchdog timer-------------------------
+	 //del_timer(&blink_timer[id]);
+	 WATCHDOG_VAL = ENABLE_WATCHDOG | ( EXPIRE_TIME  << WATCHDOG_SET_TMR_SHIFT);
+    watchdog.function = watchdog_wrapper;
+    watchdog.data = WATCHDOG_PERIOD;
+    init_timer(&watchdog);
+    watchdog.expires = jiffies + (WATCHDOG_PERIOD * HZ / 1000);
+    add_timer(&watchdog);
+    init_status |= INIT_WATCHDOG_REGISTER;
+  
+ // end sam   
+  //------ read proc -------------------
+    if ( !create_proc_read_entry("driver/led", 0, 0, led_read_proc, NULL) )  {
+	printk(KERN_ERR "led: can't create /proc/driver/led\n");
+    	led_exit();
+    	return -ENOMEM;
+    }
+    init_status |= INIT_LED_PROC_READ;
+  //------------------------------
+//    reg_addr = (unsigned long *)0xB4000000;
+    reg_addr = (unsigned long *)0xB2000000;
+    dump_len = 4;
+    for ( id = 0 ; id < LED_DEV_NUM ; id++ )  {
+    	strcpy(led_data[id].sts_buf, "LED OFF\n" );
+    	set_led_status_by_str(id);
+    }
+    strcpy(led_data[0].sts_buf,"LED BLINK 100\n");
+    set_led_status_by_str(0);
+    printk(KERN_INFO "LED & GPIO Driver " LED_VERSION "\n");
+    return 0;
+}
+
+module_init(led_init);
+module_exit(led_exit);
+EXPORT_NO_SYMBOLS;
diff -urN linux-2.4.32/arch/mips/am5120/led.h linux-2.4.32-adm5120/arch/mips/am5120/led.h
--- linux-2.4.32/arch/mips/am5120/led.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/led.h	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,26 @@
+#ifndef _LED_H_INCLUDED
+#define _LED_H_INCLUDED
+
+#include <linux/config.h>
+
+#define LED_VERSION 		"v1.1"
+#define LED_MAJOR       	166
+#define LED_DEV_NUM		8 
+#define LED_GPIO_START      	1
+#define GPIO_MAJOR       	167
+#define GPIO_DEV_NUM		16
+#define REG_MINOR           	128
+//#define GPIO_IO_BASE        	0xB4002480
+#define GPIO_IO_BASE        	((unsigned long)0xb20000b8)
+#define GPIO_IO_EXTENT		0x40
+
+#define LED_ON              	0x010000
+#define LED_OFF             	0x020000
+#define LED_BLINK_CMD       	0x030000
+#define LED_BLINK_PERIOD    	0x00FFFF
+#define LED_BLINK           	(LED_BLINK_CMD|1000)
+#define LED_BLINK_FAST      	(LED_BLINK_CMD|250)
+#define LED_BLINK_SLOW      	(LED_BLINK_CMD|500)
+#define LED_BLINK_EXTRA_SLOW    (LED_BLINK_CMD|2000)
+
+#endif
diff -urN linux-2.4.32/arch/mips/am5120/Makefile linux-2.4.32-adm5120/arch/mips/am5120/Makefile
--- linux-2.4.32/arch/mips/am5120/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/Makefile	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,22 @@
+#
+# Makefile for Hawaii Aloha board
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+.S.s:
+	$(CPP) $(CFLAGS) $< -o $*.s
+.S.o:
+	$(CC) $(CFLAGS) -c $< -o $*.o
+
+O_TARGET:= am5120.o
+
+obj-y    := setup.o prom.o irq.o serial.o cmdline.o memory.o \
+			5120_int.o mipsIRQ.o 5120_rtc.o time.o pci.o led.o 
+
+#obj-$(CONFIG_BLK_DEV_INITRD)    += ramdisk.o
+#obj-$(CONFIG_REMOTE_DEBUG)      += dbg_io.o
+
+include $(TOPDIR)/Rules.make
diff -urN linux-2.4.32/arch/mips/am5120/memory.c linux-2.4.32-adm5120/arch/mips/am5120/memory.c
--- linux-2.4.32/arch/mips/am5120/memory.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/memory.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,113 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/memory.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/am5120/prom.h>
+#include <asm/am5120/adm5120.h>
+
+
+struct prom_pmemblock mdesc[PROM_MAX_PMEMBLOCKS];
+
+/* References to section boundaries */
+extern char _end;
+
+#define PFN_ALIGN(x)    (((unsigned long)(x) + (PAGE_SIZE - 1)) & PAGE_MASK)
+
+
+struct prom_pmemblock * __init prom_getmdesc(void)
+{
+	char *memsize_str;
+	unsigned int memsize;
+
+	memsize_str = prom_getenv("memsize");
+
+	if (!memsize_str) 
+	{
+		prom_printf("memsize not set in boot prom, set to default (8Mb)\n");
+		memsize = 0x00800000;
+	} 
+	else
+		memsize = simple_strtol(memsize_str, NULL, 0);
+
+	memset(mdesc, 0, sizeof(mdesc));
+
+	mdesc[0].type = BOOT_MEM_RAM;
+	mdesc[0].base = PHYSADDR(PFN_ALIGN(&_end));
+	mdesc[0].size = memsize - mdesc[0].base;
+
+	return &mdesc[0];
+}
+
+
+void __init prom_meminit(void)
+{
+	struct prom_pmemblock *p;
+
+	p = prom_getmdesc();
+
+	while (p->size) 
+	{
+		add_memory_region(p->base, p->size, p->type);
+        p++; 
+	}
+}
+
+
+void __init prom_free_prom_memory (void)
+{
+	int i;
+	unsigned long freed = 0;
+	unsigned long addr;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) 
+	{
+		if (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)
+			continue;
+
+		addr = boot_mem_map.map[i].addr;
+		while (addr < boot_mem_map.map[i].addr
+			      + boot_mem_map.map[i].size) 
+		{
+			ClearPageReserved(virt_to_page(__va(addr)));
+			set_page_count(virt_to_page(__va(addr)), 1);
+			free_page((unsigned long)__va(addr));
+			addr += PAGE_SIZE;
+			freed += PAGE_SIZE;
+		}
+	}
+
+	printk("Freeing prom memory: %ldkb freed\n", freed >> 10);
+}
+
+
diff -urN linux-2.4.32/arch/mips/am5120/mipsIRQ.S linux-2.4.32-adm5120/arch/mips/am5120/mipsIRQ.S
--- linux-2.4.32/arch/mips/am5120/mipsIRQ.S	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/mipsIRQ.S	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,138 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Interrupt exception dispatch code.
+ *
+ */
+#include <linux/config.h>
+
+#ifdef _LANGUAGE_ASSEMBLY
+#define __ASSEMBLY__ 
+#endif
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+//#include <asm/addrspace.h>
+
+/* A lot of complication here is taken away because:
+ *
+ * 1) We handle one interrupt and return, sitting in a loop and moving across
+ *    all the pending IRQ bits in the cause register is _NOT_ the answer, the
+ *    common case is one pending IRQ so optimize in that direction.
+ *
+ * 2) We need not check against bits in the status register IRQ mask, that
+ *    would make this routine slow as hell.
+ *
+ * 3) Linux only thinks in terms of all IRQs on or all IRQs off, nothing in
+ *    between like BSD spl() brain-damage.
+ *
+ * Furthermore, the IRQs on the MIPS board look basically (barring software
+ * IRQs which we don't use at all and all external interrupt sources are
+ * combined together on hardware interrupt 0 (MIPS IRQ 2)) like:
+ *
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware (ignored)
+ *             4        Hardware (ignored)
+ *             5        Hardware (ignored)
+ *             6        Hardware (ignored)
+ *             7        R4k timer (what we use)
+ *
+ * Note: On the SEAD board thing are a little bit different.
+ *       Here IRQ 2 (hw0) is wired to the UART0 and IRQ 3 (hw1) is wired
+ *       wired to UART1.
+ *	
+ * We handle the IRQ according to _our_ priority which is:
+ *
+ * Highest ----     R4k Timer
+ * Lowest  ----     Combined hardware interrupt
+ *
+ * then we just return, if multiple IRQs are pending then we will just take
+ * another exception, big deal.
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+
+NESTED(mipsIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	at
+
+	mfc0	s0, CP0_CAUSE	
+	mfc0	s1, CP0_STATUS
+	and     s0, s0, s1
+	
+	/* First we check for r4k counter/timer IRQ. */
+	andi	a0, s0, CAUSEF_IP7
+	beq		a0, zero, 1f
+	nop
+
+	move	a0, sp
+	jal		mips_timer_interrupt
+	nop
+
+	j		ret_from_irq
+	nop
+
+1:
+	andi	a0, s0, CAUSEF_IP2
+	beq		a0, zero, 1f	
+	nop
+	
+	move	a0, sp			
+	jal		am5120_hw0_irqdispatch	 
+	nop
+1:
+	j		ret_from_irq
+	nop							
+
+END(mipsIRQ)
+
+
+LEAF(mips_int_lock)
+	.set noreorder
+	mfc0	v0, CP0_STATUS
+	li		v1, ~STATUS_IE
+	and		v1, v1, v0
+	mtc0	v1, CP0_STATUS
+	j		ra
+	and		v0, v0, STATUS_IE
+	.set reorder
+END(mips_int_lock)
+
+
+LEAF(mips_int_unlock)
+	mfc0	v0, CP0_STATUS
+	and		a0, a0, STATUS_IE
+	or		v0, v0, a0
+	mtc0	v0, CP0_STATUS
+	j		ra
+	nop
+END(mips_int_unlock)
+
diff -urN linux-2.4.32/arch/mips/am5120/pci.c linux-2.4.32-adm5120/arch/mips/am5120/pci.c
--- linux-2.4.32/arch/mips/am5120/pci.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/pci.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,213 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : 
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/pci_channel.h>
+#include <asm/am5120/adm5120.h>
+
+#ifdef CONFIG_PCI
+
+volatile u32* pci_config_address_reg = (volatile u32*)KSEG1ADDR(0x115ffff0);
+volatile u32* pci_config_data_reg = (volatile u32*)KSEG1ADDR(0x115ffff8);
+
+#define PCI_ENABLE 0x80000000
+#define PCI_CMM_IOACC_EN		0x1
+#define PCI_CMM_MEMACC_EN		0x2
+#define PCI_CMM_MASTER_EN		0x4
+#define PCI_CMM_DEF				(PCI_CMM_IOACC_EN | PCI_CMM_MEMACC_EN | PCI_CMM_MASTER_EN)
+
+#define PCI_DEF_CACHE_LINE_SZ	4
+#define PCI_DEF_LATENCY_TIMER	0x20
+#define PCI_DEF_CACHE_LATENCY	((PCI_DEF_LATENCY_TIMER << 8) | PCI_DEF_CACHE_LINE_SZ)
+
+
+                             
+#define cfgaddr(dev, where) (((dev->bus->number & 0xff) << 0x10) |  \
+                             ((dev->devfn & 0xff) << 0x08) |        \
+                             (where & 0xfc)) | PCI_ENABLE
+
+
+/*
+ * We can't address 8 and 16 bit words directly.  Instead we have to
+ * read/write a 32bit word and mask/modify the data we actually want.
+ */
+static int am5120_read_config_byte (struct pci_dev *dev,
+                                   int where, unsigned char *val)
+{
+	*pci_config_address_reg = cfgaddr(dev, where);
+	*val = ((*pci_config_data_reg) >> ((where&3)<<3)) & 0xff;
+//	printk("pci_read_byte 0x%x == 0x%x\n", where, *val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int am5120_read_config_word (struct pci_dev *dev,
+                                   int where, unsigned short *val)
+{
+	if (where & 1)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	*pci_config_address_reg = cfgaddr(dev, where);
+	*val = ((*pci_config_data_reg) >> ((where&3)<<3)) & 0xffff;
+//	printk("pci_read_word 0x%x == 0x%x\n", where, *val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+int am5120_read_config_dword (struct pci_dev *dev,
+                                    int where, unsigned int *val)
+{
+	if (where & 3)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	*pci_config_address_reg = cfgaddr(dev, where);
+	*val = (*pci_config_data_reg);
+//	printk("pci_read_dword 0x%x == 0x%x\n", where, *val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int am5120_write_config_byte (struct pci_dev *dev,
+                                    int where, unsigned char val)
+{
+	*pci_config_address_reg = cfgaddr(dev, where);
+	*(volatile u8 *)(((int)pci_config_data_reg) + (where & 3)) = val;
+//	printk("pci_write_byte 0x%x = 0x%x\n", where, val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int am5120_write_config_word (struct pci_dev *dev,
+                                    int where, unsigned short val)
+{
+	if (where & 1)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	*pci_config_address_reg = cfgaddr(dev, where);
+	*(volatile u16 *)(((int)pci_config_data_reg) + (where & 2)) = (val);
+//	printk("pci_write_word 0x%x = 0x%x\n", where, val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int am5120_write_config_dword (struct pci_dev *dev,
+                                     int where, unsigned int val)
+{
+	if (where & 3)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	*pci_config_address_reg = cfgaddr(dev, where);
+	*pci_config_data_reg = (val);
+//	printk("pci_write_dword 0x%x = 0x%x\n", where, val);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+
+struct pci_ops am5120_pci_ops = {
+	am5120_read_config_byte,
+	am5120_read_config_word,
+	am5120_read_config_dword,
+	am5120_write_config_byte,
+	am5120_write_config_word,
+	am5120_write_config_dword
+};
+struct resource pciioport_resource = {
+	"pci IO space", 
+	0x11500000,  
+	0x115ffff0-1,
+	IORESOURCE_IO
+};
+
+struct resource pciiomem_resource = {
+	"pci memory space", 
+	0x11400000,
+	0x11500000-1,
+	IORESOURCE_MEM
+};
+
+static void am5120_pcibios_fixup(struct pci_dev *dev)
+{
+	printk("am5120 fix up\n");
+	pci_write_config_word(dev, PCI_COMMAND, PCI_CMM_DEF);
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, PCI_DEF_CACHE_LATENCY);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, 0);
+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_1, 0);
+
+}
+
+struct pci_channel mips_pci_channels[] = {
+	{ &am5120_pci_ops, &pciioport_resource, &pciiomem_resource,0,0xff},
+	{ (struct pci_ops *)NULL, (struct resource *)NULL,
+	  (struct resource *) NULL , (int) NULL , (int) NULL}
+};
+
+
+
+unsigned __init int pcibios_assign_all_busses(void)
+{
+        return 1;
+}
+
+void __init pcibios_fixup(void)
+{
+	printk("pcibios_fixup\n");
+}
+
+void __init pcibios_fixup_irqs(void)
+{
+   struct pci_dev *dev;
+   int slot_num;
+
+   printk("fixup IRQ\n");	
+   pci_for_each_dev(dev) {
+      slot_num = PCI_SLOT(dev->devfn);
+      switch(slot_num) {
+         case 2: 
+		 dev->irq = 6;  
+		 pci_write_config_word(dev, PCI_INTERRUPT_LINE, 6);
+		 break;
+         case 3: 
+		 dev->irq = 7;  
+		 pci_write_config_word(dev, PCI_INTERRUPT_LINE, 7);
+		 break;
+         case 4: 
+		 dev->irq = 8;  
+		 pci_write_config_word(dev, PCI_INTERRUPT_LINE, 8);
+		 break;
+         default: break;
+      }
+   }
+}
+
+void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+	printk("fixup resource\n");
+	if (dev->devfn == 0)
+	{
+		printk("fixup host controller\n");
+		am5120_pcibios_fixup(dev);
+	}
+}
+
+#endif /* CONFIG_PCI */
diff -urN linux-2.4.32/arch/mips/am5120/prom.c linux-2.4.32-adm5120/arch/mips/am5120/prom.c
--- linux-2.4.32/arch/mips/am5120/prom.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/prom.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,121 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/prom.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/am5120/prom.h>
+
+
+#define prom_envp(index) ((char *)(((int *)(int)_prom_envp)[(index)]))
+
+extern void am5120_serial_console_init(void);
+
+int prom_argc;
+int *_prom_argv, *_prom_envp;
+
+/* am5120 platform arguments */
+#define AM5120_ARGC		4
+#define AM5120_ENVC		2
+
+int am5120_argc = AM5120_ARGC;
+char *am5120_argv[AM5120_ARGC] = {"load_ramdisk=/dev/ram0",
+				  "root=/dev/ram0",
+				  "rw",
+				  "console=ttyS0"};
+
+
+char *am5120_envp[AM5120_ENVC] = {"memsize",
+				"0x001000000"};
+
+
+char *prom_getenv(char *envname)
+{
+	/*
+	 * Return a pointer to the given environment variable.
+	 * In 64-bit mode: we're using 64-bit pointers, but all pointers 
+	 * in the PROM structures are only 32-bit, so we need some 
+	 * workarounds, if we are running in 64-bit mode.
+	 */
+	int i, index=0;
+
+	if (_prom_envp == NULL)
+		return (NULL);
+
+	i = strlen(envname);
+
+	while(prom_envp(index)) {
+		if(strncmp(envname, prom_envp(index), i) == 0) {
+			return(prom_envp(index+1));
+		}
+		index += 2;
+	}
+
+	return(NULL);
+}
+
+/*
+ * initialize the prom module.
+ */
+int __init prom_init(int argc, char **argv, char **envp)
+{
+	prom_argc = am5120_argc;
+	_prom_argv = (int *)am5120_argv;
+	_prom_envp = (int *)am5120_envp;
+
+	/* you should these macros defined in include/asm/bootinfo.h */
+	mips_machgroup = MACH_GROUP_ADM_GW;
+	mips_machtype = MACH_ADM_GW_5120;
+
+	/* set IO port base to zero */ 
+//	mips_io_port_base = 0;
+
+	/* init print from uart0 */
+	setup_prom_printf(0);
+
+	prom_printf("\nLINUX started...\nADM5120 Demo board\n");
+	
+	/* init command line */
+	prom_init_cmdline();
+	
+	/* init memory map */
+	prom_meminit();
+
+	/* init serial console */
+	am5120_serial_console_init();
+	
+	return 0;
+}
+
+
diff -urN linux-2.4.32/arch/mips/am5120/serial.c linux-2.4.32-adm5120/arch/mips/am5120/serial.c
--- linux-2.4.32/arch/mips/am5120/serial.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/serial.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,1685 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/printf.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/serialP.h>
+#include <linux/serial_reg.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/devpts_fs.h>
+
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+#include <asm/am5120/adm5120.h>
+
+
+//#define SERIAL_DEBUG_OPEN	1
+//#define SERIAL_DEBUG_INTR	1
+
+/*
+ * IN_W
+ */
+static inline unsigned long IN_W(unsigned long _addr)
+{
+	return (*(volatile unsigned long *)(_addr));
+}
+
+
+/*
+ * OUT_W
+ */
+static inline void OUT_W(unsigned long _addr, unsigned long _value)
+{
+	(*((volatile unsigned long *)(_addr))) = _value;
+}
+
+
+/*
+ * serial_in
+ */
+static unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return IN_W(info->port + offset);
+}
+
+
+/*
+ * serial_out
+ */
+static void serial_out(struct async_struct *info, int offset,
+				int value)
+{
+	OUT_W(info->port + offset, value);
+}
+
+
+/*
+ * serial state 
+ */
+static struct serial_state rs_table[] = 
+{
+	{baud_base:UART_115200bps_DIVISOR, port:KSEG1ADDR(UART0_BASE), irq:1, flags:STD_COM_FLAGS, type:SERIAL_IO_MEM}
+};
+
+
+/*-------------------------------------------------------
+ * prom_printf 
+ * 
+ *-----------------------------------------------------*/
+/*
+ * Hooks to fake "prom" console I/O before devices 
+ * are fully initialized. 
+ */
+static struct async_struct prom_port_info = {0};
+
+void __init setup_prom_printf(int tty_no) 
+{
+	struct serial_state *ser = &rs_table[tty_no];
+
+	prom_port_info.state = ser;
+	prom_port_info.magic = SERIAL_MAGIC;
+	prom_port_info.port = ser->port;
+	prom_port_info.flags = ser->flags;
+
+	/* set baudrate to 115200 */
+	serial_out(&prom_port_info, UART_LCR_L_REG, prom_port_info.state->baud_base); 
+	serial_out(&prom_port_info, UART_LCR_M_REG, prom_port_info.state->baud_base >> 8);
+	
+	/* Set default line mode */
+	serial_out(&prom_port_info, UART_LCR_H_REG, UART_WLEN_8BITS | UART_ENABLE_FIFO);
+
+	/* Enable uart port */
+	serial_out(&prom_port_info, UART_CR_REG, UART_PORT_EN);
+}
+
+
+/* 
+ * putPromChar
+ */
+int putPromChar(char c)
+{
+    if (!prom_port_info.state) { 	/* need to init device first */
+		return 0;
+	}
+
+	while ((serial_in(&prom_port_info, UART_FR_REG) & UART_TX_FIFO_FULL) != 0)
+		;
+
+	serial_out(&prom_port_info, UART_DR_REG, c);
+
+	return 1;
+}
+
+
+/* 
+ * getPromChar
+ */
+char getPromChar(void)
+{
+	if (!prom_port_info.state) 	/* need to init device first */
+		return 0;
+
+	if ((serial_in(&prom_port_info, UART_FR_REG) & UART_RX_FIFO_EMPTY))
+		return 0;
+
+	return(serial_in(&prom_port_info, UART_DR_REG));
+}
+
+
+static char buf[1024];
+
+/*
+ * prom_printf
+ */
+void __init prom_printf(char *fmt, ...)
+{
+	va_list args;
+	int l;
+	char *p, *buf_end;
+	long flags;
+
+	int putPromChar(char);
+
+	/* Low level, brute force, not SMP safe... */
+	save_and_cli(flags);
+	va_start(args, fmt);
+	l = vsprintf(buf, fmt, args); /* hopefully i < sizeof(buf) */
+	va_end(args);
+
+	buf_end = buf + l;
+
+	for (p = buf; p < buf_end; p++) {
+		/* Crude cr/nl handling is better than none */
+		if(*p == '\n')putPromChar('\r');
+		putPromChar(*p);
+	}
+	restore_flags(flags);
+}
+
+
+/*-------------------------------------------------------
+ * console driver
+ * 
+ *-----------------------------------------------------*/
+/*
+ *	Print a string to the serial port trying not to disturb
+ *	any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void serial_console_write(struct console *co, const char *s,
+				unsigned count)
+{
+	int i;
+
+	for (i = 0; i < count; i++, s++)
+	{
+		if (*s == '\n')
+			putPromChar('\r');
+		putPromChar(*s);
+	}
+}
+
+/*
+ * Get serial console device
+ */
+static kdev_t serial_console_device(struct console *c)
+{
+	return MKDEV(TTY_MAJOR, 64 + c->index);
+}
+
+
+/*
+ *	Setup initial baud/bits/parity. We do two things here:
+ *	- construct a cflag setting for the first rs_open()
+ *	- initialize the serial port
+ *	Return non-zero if we didn't find a serial port.
+ */
+static int __init serial_console_setup(struct console *co, char *options)
+{
+	return 0;
+}
+
+
+/* 
+ * Console data structure
+ */
+static struct console sercons = {
+	name:		"ttyS",
+	write:		serial_console_write,
+	device:		serial_console_device,
+	setup:		serial_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+
+/*
+ *	Register console.
+ */
+void __init am5120_serial_console_init(void)
+{
+	register_console(&sercons);
+}
+
+
+/*------------------------------------------------------
+ * Register tty driver
+ *
+ *----------------------------------------------------*/
+
+static char *serial_version = "0.01";
+static char *serial_revdate = "2003-04-17";
+
+#define LOCAL_VERSTRING ""
+
+#define NR_PORTS	(sizeof(rs_table)/sizeof(struct serial_state))
+#define WAKEUP_CHARS 256
+#define RS_ISR_PASS_LIMIT 256
+
+static unsigned char *tmp_buf;
+#ifdef DECLARE_MUTEX
+static DECLARE_MUTEX(tmp_buf_sem);
+#else
+static struct semaphore tmp_buf_sem = MUTEX;
+#endif
+
+static struct tty_driver dev_tty_driver, callout_driver;
+static int serial_refcount;
+static struct tty_struct *serial_table[NR_PORTS];
+static struct termios *serial_termios[NR_PORTS];
+static struct termios *serial_termios_locked[NR_PORTS];
+static unsigned char *tmp_buf = 0;
+static struct async_struct *IRQ_ports[NR_IRQS] = {0};
+//static struct async_struct async_info[NR_PORTS];
+
+
+static void do_softint(void *private_)
+{
+	struct async_struct	*info = (struct async_struct *) private_;
+	struct tty_struct	*tty;
+	
+	tty = info->tty;
+	if (!tty)
+		return;
+
+	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event)) {
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		    tty->ldisc.write_wakeup)
+			(tty->ldisc.write_wakeup)(tty);
+		wake_up_interruptible(&tty->write_wait);
+#ifdef SERIAL_HAVE_POLL_WAIT
+		wake_up_interruptible(&tty->poll_wait);
+#endif
+	}
+}
+
+
+static int get_async_struct(int line, struct async_struct **ret_info)
+{
+	struct async_struct *info;
+	struct serial_state *sstate;
+
+	sstate = rs_table + line;
+	sstate->count++;
+	if (sstate->info) {
+		*ret_info = sstate->info;
+		return 0;
+	}
+
+	info = kmalloc(sizeof(struct async_struct), GFP_KERNEL);
+	if (!info) {
+		sstate->count--;
+		return -ENOMEM;
+	}
+
+	memset(info, 0, sizeof(struct async_struct));
+	init_waitqueue_head(&info->open_wait);
+	init_waitqueue_head(&info->close_wait);
+	init_waitqueue_head(&info->delta_msr_wait);
+	info->magic = SERIAL_MAGIC;
+	info->port = sstate->port;
+	info->flags = sstate->flags;
+	info->io_type = sstate->io_type;
+	info->iomem_base = sstate->iomem_base;
+	info->iomem_reg_shift = sstate->iomem_reg_shift;
+	info->xmit_fifo_size = sstate->xmit_fifo_size;
+	info->line = line;
+	info->tqueue.routine = do_softint;
+	info->tqueue.data = info;
+	info->state = sstate;
+	if (sstate->info) {
+		kfree(info);
+		*ret_info = sstate->info;
+		return 0;
+	}
+	*ret_info = sstate->info = info;
+	return 0;
+}
+
+
+static void transmit_chars(struct async_struct *info, int *intr_done)
+{
+	if (info->x_char) {
+		serial_out(info, UART_DR_REG, info->x_char);
+		info->state->icount.tx++;
+		info->x_char = 0;
+		if (intr_done)
+			*intr_done = 0;
+		return;
+	}
+
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		info->IER &= ~UART_TX_INT_EN;
+		serial_out(info, UART_CR_REG, info->IER);
+		return;
+	}
+	
+	do {
+		while ((serial_in(info, UART_FR_REG) & UART_TX_FIFO_FULL) != 0);
+
+		serial_out(info, UART_DR_REG, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);
+		info->state->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	} while (1);
+	
+	//if (CIRC_CNT(info->xmit.head,
+	//	     info->xmit.tail,
+	//	     SERIAL_XMIT_SIZE) < WAKEUP_CHARS)
+		//rs_sched_event(info, RS_EVENT_WRITE_WAKEUP);
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("THRE...");
+#endif
+
+	if (intr_done)
+		*intr_done = 0;
+
+	if (info->xmit.head == info->xmit.tail) {
+		info->IER &= ~UART_TX_INT_EN;
+		serial_out(info, UART_CR_REG, info->IER);
+	}
+}
+
+
+
+static void receive_chars(struct async_struct *info, struct pt_regs * regs)
+{
+	struct tty_struct *tty = info->tty;
+	unsigned char ch;
+	struct	async_icount *icount;
+	unsigned int status;
+	unsigned int rsr_flag;
+
+	icount = &info->state->icount;
+
+	do {
+		ch = serial_in(info, UART_DR_REG);
+
+		rsr_flag = serial_in(info, UART_RSR_REG);
+		serial_out(info, UART_RSR_REG, rsr_flag);
+
+		if (rsr_flag & UART_RX_ERROR)
+			goto ignore_char;
+			
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+
+		*tty->flip.char_buf_ptr = ch;
+		icount->rx++;
+		
+#ifdef SERIAL_DEBUG_INTR
+		printk("DR%02x...", ch);
+#endif
+		*tty->flip.flag_buf_ptr = 0;
+
+		tty->flip.flag_buf_ptr++;
+		tty->flip.char_buf_ptr++;
+		tty->flip.count++;
+
+		status = serial_in(info, UART_FR_REG);
+
+	} while (!(status & UART_RX_FIFO_EMPTY));
+
+ignore_char:
+
+	tty_flip_buffer_push(tty);
+}
+
+
+/*
+ * This is the serial driver's interrupt routine for a single port
+ */
+static void rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+	int status;
+	int pass_counter = 0;
+	struct async_struct * info;
+	
+#ifdef SERIAL_DEBUG_INTR
+	printk("rs_interrupt(%d)...", irq);
+#endif
+
+	info = IRQ_ports[irq];
+	if (!info || !info->tty)
+		return;
+
+	do {
+		status = serial_in(info, UART_IIR_REG);
+
+		if (status & (UART_RX_INT | UART_RX_TIMEOUT_INT))
+		{
+			//if ((serial_in(info, UART_FR_REG) & UART_RX_FIFO_EMPTY))
+			//	break;
+			receive_chars(info, regs);
+		}
+
+		if (status & UART_TX_INT)
+		{
+			transmit_chars(info, 0);
+		}
+		
+		if (pass_counter++ > RS_ISR_PASS_LIMIT) {
+			break;
+		}
+
+	} while (serial_in(info, UART_IIR_REG) & (UART_RX_INT | UART_RX_TIMEOUT_INT | UART_TX_INT));
+
+	info->last_active = jiffies;
+}
+
+
+static int startup(struct async_struct * info)
+{
+	unsigned long flags;
+	int	retval=0;
+	void (*handler)(int, void *, struct pt_regs *);
+	struct serial_state *state= info->state;
+	unsigned long page;
+
+	if (info->flags & ASYNC_INITIALIZED) 
+		return retval;
+
+	page = get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	save_flags(flags); 
+	
+	cli();
+
+	if (!CONFIGURED_SERIAL_PORT(state) || !state->type) 
+	{
+		if (info->tty)
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		free_page(page);
+		goto errout;
+	}
+	
+	if (info->xmit.buf)
+		free_page(page);
+	else
+		info->xmit.buf = (unsigned char *) page;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("starting up ttyS%d (irq %d)...", info->line, state->irq);
+#endif
+
+	/*
+	 * Allocate the IRQ if necessary
+	 */
+	if ((!IRQ_ports[state->irq] || !IRQ_ports[state->irq]->next_port)) 
+	{
+		if (IRQ_ports[state->irq]) 
+		{
+			retval = -EBUSY;
+			goto errout;
+		} 
+		else 
+			handler = rs_interrupt;
+
+		retval = request_irq(state->irq, handler, SA_SHIRQ,
+					"serial", &IRQ_ports[state->irq]);
+		if (retval) 
+		{
+			if (capable(CAP_SYS_ADMIN)) 
+			{
+				if (info->tty)
+					set_bit(TTY_IO_ERROR, &info->tty->flags);
+			}
+			goto errout;
+		}
+	}
+
+	/*
+	 * Insert serial port into IRQ chain.
+	 */
+	info->prev_port = 0;
+	info->next_port = IRQ_ports[state->irq];
+	
+	if (info->next_port)
+		info->next_port->prev_port = info;
+	
+	IRQ_ports[state->irq] = info;
+
+	/*
+	 * Now, initialize the UART 
+	 */
+	serial_out(info, UART_LCR_L_REG, info->state->baud_base); 
+	serial_out(info, UART_LCR_M_REG, info->state->baud_base >> 8);
+	serial_out(info, UART_LCR_H_REG, (UART_WLEN_8BITS | UART_ENABLE_FIFO));
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	info->IER = UART_RX_INT_EN | UART_RX_TIMEOUT_INT_EN | UART_PORT_EN;
+	serial_out(info, UART_CR_REG, info->IER);
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->xmit.head = info->xmit.tail = 0;
+	
+	/*
+	 * and set the speed of the serial port
+	 */
+	info->flags |= ASYNC_INITIALIZED;
+	restore_flags(flags);
+
+	return 0;
+	
+errout:
+	restore_flags(flags);
+	return retval;
+}
+
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port, linking in its async structure into
+ * the IRQ chain.   It also performs the serial-specific
+ * initialization for the tty structure.
+ */
+static int rs_open(struct tty_struct *tty, struct file * filp)
+{
+	struct async_struct	*info;
+	int 			retval, line;
+	unsigned long		page;
+
+	line = MINOR(tty->device) - tty->driver.minor_start;
+	if ((line < 0) || (line >= NR_PORTS)) 
+	{
+		return -ENODEV;
+	}
+
+	retval = get_async_struct(line, &info);
+	if (retval) 
+	{
+		return retval;
+	}
+
+	tty->driver_data = info;
+	info->tty = tty;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_open %s%d, count = %d\n", tty->driver.name, info->line,
+	       info->state->count);
+#endif
+	
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+
+	if (!tmp_buf) 
+	{
+		page = get_zeroed_page(GFP_KERNEL);
+		if (!page) 
+		{
+			return -ENOMEM;
+		}
+
+		if (tmp_buf)
+			free_page(page);
+		else
+			tmp_buf = (unsigned char *) page;
+	}
+
+	/*
+	 * If the port is the middle of closing, bail out now
+	 */
+	if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) 
+	{
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+
+		return -EAGAIN;
+	}
+
+	/*
+	 * Start up serial port
+	 */
+	retval = startup(info);
+	if (retval) 
+	{
+		return retval;
+	}
+
+#if 0
+	retval = block_til_ready(tty, filp, info);
+	if (retval) {
+#ifdef SERIAL_DEBUG_OPEN
+		printk("rs_open returning after block_til_ready with %d\n",
+		       retval);
+#endif
+		return retval;
+	}
+#endif
+
+	if ((info->state->count == 1) &&
+	    (info->flags & ASYNC_SPLIT_TERMIOS)) 
+	{
+		if (tty->driver.subtype == SERIAL_TYPE_NORMAL)
+			*tty->termios = info->state->normal_termios;
+		else 
+			*tty->termios = info->state->callout_termios;
+	}
+
+	info->session = current->session;
+	info->pgrp = current->pgrp;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_open ttys%d successful...", info->line);
+#endif
+
+	return 0;
+}
+
+
+/*
+ * rs_close()
+ * 
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we unlink its
+ * async structure from the interrupt chain if necessary, and we free
+ * that IRQ if nothing is left in the chain.
+ */
+static void rs_close(struct tty_struct *tty, struct file * filp)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state;
+	unsigned long flags;
+
+	state = info->state;
+	
+	save_flags(flags); 
+	cli();
+	
+	//if (tty_hung_up_p(filp)) {
+	//	DBG_CNT("before DEC-hung");
+	//	restore_flags(flags);
+	//	return;
+	//}
+	
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_close ttys%d, count = %d\n", info->line, state->count);
+#endif
+
+	if ((tty->count == 1) && (state->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  state->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		//printk("rs_close: bad serial port count; tty->count is 1, "
+		 //      "state->count is %d\n", state->count);
+		state->count = 1;
+	}
+
+	if (--state->count < 0) {
+		//printk("rs_close: bad serial port count for ttys%d: %d\n",
+		   //    info->line, state->count);
+		state->count = 0;
+	}
+
+	restore_flags(flags);
+	return;
+
+#if 0
+	info->flags |= ASYNC_CLOSING;
+	restore_flags(flags);
+	/*
+	 * Save the termios structure, since this port may have
+	 * separate termios for callout and dialin.
+	 */
+	if (info->flags & ASYNC_NORMAL_ACTIVE)
+		info->state->normal_termios = *tty->termios;
+	if (info->flags & ASYNC_CALLOUT_ACTIVE)
+		info->state->callout_termios = *tty->termios;
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify 
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
+
+	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->closing_wait);
+
+	/*
+	 * At this point we stop accepting input.  To do this, we
+	 * disable the receive line status interrupts, and tell the
+	 * interrupt driver to stop checking the data ready bit in the
+	 * line status register.
+	 */
+	//info->IER &= ~UART_IER_RLSI;
+	//info->read_status_mask &= ~UART_LSR_DR;
+	//if (info->flags & ASYNC_INITIALIZED) {
+		//	serial_out(info, UART_IER, info->IER);
+		/*
+		 * Before we drop DTR, make sure the UART transmitter
+		 * has completely drained; this is especially
+		 * important if there is a transmit FIFO!
+		 */
+	//	rs_wait_until_sent(tty, info->timeout);
+	//}
+	//shutdown(info);
+
+	if (tty->driver.flush_buffer)
+		tty->driver.flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = 0;
+	//if (info->blocked_open) {
+	//	if (info->close_delay) {
+	//		set_current_state(TASK_INTERRUPTIBLE);
+	//		schedule_timeout(info->close_delay);
+	//	}
+	//	wake_up_interruptible(&info->open_wait);
+	//}
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE|
+			 ASYNC_CLOSING);
+	
+	wake_up_interruptible(&info->close_wait);
+#endif
+}
+
+
+static int rs_write(struct tty_struct * tty, int from_user,
+		    const unsigned char *buf, int count)
+{
+	int	c, ret = 0;
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (!tty || !info->xmit.buf || !tmp_buf)
+		return 0;
+
+	save_flags(flags);
+	if (from_user) {
+		down(&tmp_buf_sem);
+		while (1) {
+			int c1;
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					      info->xmit.tail,
+					      SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0)
+				break;
+
+			c -= copy_from_user(tmp_buf, buf, c);
+			if (!c) {
+				if (!ret)
+					ret = -EFAULT;
+				break;
+			}
+			cli();
+			c1 = CIRC_SPACE_TO_END(info->xmit.head,
+					       info->xmit.tail,
+					       SERIAL_XMIT_SIZE);
+			if (c1 < c)
+				c = c1;
+			memcpy(info->xmit.buf + info->xmit.head, tmp_buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					   (SERIAL_XMIT_SIZE-1));
+			restore_flags(flags);
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		up(&tmp_buf_sem);
+	} else {
+		cli();
+		while (1) {
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					      info->xmit.tail,
+					      SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0) {
+				break;
+			}
+			memcpy(info->xmit.buf + info->xmit.head, buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					   (SERIAL_XMIT_SIZE-1));
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		restore_flags(flags);
+	}
+	if (info->xmit.head != info->xmit.tail
+	    && !tty->stopped
+	    && !tty->hw_stopped
+	    && !(info->IER & UART_TX_INT)) {
+		info->IER |= UART_TX_INT_EN;
+		serial_out(info, UART_CR_REG, info->IER);
+	}
+	return ret;
+}
+
+
+static void rs_put_char(struct tty_struct *tty, unsigned char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (!tty || !info->xmit.buf)
+		return;
+
+	save_flags(flags); 
+	cli();
+	
+	if (CIRC_SPACE(info->xmit.head,
+		       info->xmit.tail,
+		       SERIAL_XMIT_SIZE) == 0) {
+		restore_flags(flags);
+		return;
+	}
+
+	info->xmit.buf[info->xmit.head] = ch;
+	info->xmit.head = (info->xmit.head + 1) & (SERIAL_XMIT_SIZE-1);
+	restore_flags(flags);
+}
+
+
+static void rs_flush_chars(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+				
+	if (info->xmit.head == info->xmit.tail
+	    || tty->stopped
+	    || tty->hw_stopped
+	    || !info->xmit.buf)
+		return;
+
+	save_flags(flags); 
+	cli();
+	
+	info->IER |= UART_TX_INT_EN;
+	serial_out(info, UART_CR_REG, info->IER);
+	restore_flags(flags);
+}
+
+
+static int rs_write_room(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	return CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+
+static int rs_chars_in_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	return CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+
+static void rs_flush_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	save_flags(flags); 
+	cli();
+
+	info->xmit.head = info->xmit.tail = 0;
+	restore_flags(flags);
+	wake_up_interruptible(&tty->write_wait);
+#ifdef SERIAL_HAVE_POLL_WAIT
+	wake_up_interruptible(&tty->poll_wait);
+#endif
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+}
+
+
+static int get_serial_info(struct async_struct * info,
+			   struct serial_struct * retinfo)
+{
+	struct serial_struct tmp;
+	struct serial_state *state = info->state;
+   
+	if (!retinfo)
+		return -EFAULT;
+
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = state->type;
+	tmp.line = state->line;
+	tmp.port = state->port;
+	//if (HIGH_BITS_OFFSET)
+	//	tmp.port_high = state->port >> HIGH_BITS_OFFSET;
+	//else
+	tmp.port_high = 0;
+	tmp.irq = state->irq;
+	tmp.flags = state->flags;
+	tmp.xmit_fifo_size = state->xmit_fifo_size;
+	tmp.baud_base = state->baud_base;
+	tmp.close_delay = state->close_delay;
+	tmp.closing_wait = state->closing_wait;
+	tmp.custom_divisor = state->custom_divisor;
+	tmp.hub6 = state->hub6;
+	tmp.io_type = state->io_type;
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+
+#if 0
+static int set_serial_info(struct async_struct * info,
+			   struct serial_struct * new_info)
+{
+	struct serial_struct new_serial;
+ 	struct serial_state old_state, *state;
+	unsigned int		i,change_irq,change_port;
+	int 			retval = 0;
+	unsigned long		new_port;
+
+	if (copy_from_user(&new_serial,new_info,sizeof(new_serial)))
+		return -EFAULT;
+	state = info->state;
+	old_state = *state;
+
+	new_port = new_serial.port;
+	if (HIGH_BITS_OFFSET)
+		new_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;
+
+	change_irq = new_serial.irq != state->irq;
+	change_port = (new_port != ((int) state->port)) ||
+		(new_serial.hub6 != state->hub6);
+  
+	if (!capable(CAP_SYS_ADMIN)) {
+		if (change_irq || change_port ||
+		    (new_serial.baud_base != state->baud_base) ||
+		    (new_serial.type != state->type) ||
+		    (new_serial.close_delay != state->close_delay) ||
+		    (new_serial.xmit_fifo_size != state->xmit_fifo_size) ||
+		    ((new_serial.flags & ~ASYNC_USR_MASK) !=
+		     (state->flags & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		state->flags = ((state->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		state->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	new_serial.irq = irq_cannonicalize(new_serial.irq);
+
+	if ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) || 
+	    (new_serial.baud_base < 9600)|| (new_serial.type < PORT_UNKNOWN) ||
+	    (new_serial.type > PORT_MAX) || (new_serial.type == PORT_CIRRUS) ||
+	    (new_serial.type == PORT_STARTECH)) {
+		return -EINVAL;
+	}
+
+	if ((new_serial.type != state->type) ||
+	    (new_serial.xmit_fifo_size <= 0))
+		new_serial.xmit_fifo_size =
+			uart_config[new_serial.type].dfl_xmit_fifo_size;
+
+	/* Make sure address is not already in use */
+	if (new_serial.type) {
+		for (i = 0 ; i < NR_PORTS; i++)
+			if ((state != &rs_table[i]) &&
+			    (rs_table[i].port == new_port) &&
+			    rs_table[i].type)
+				return -EADDRINUSE;
+	}
+
+	if ((change_port || change_irq) && (state->count > 1))
+		return -EBUSY;
+
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
+
+	state->baud_base = new_serial.baud_base;
+	state->flags = ((state->flags & ~ASYNC_FLAGS) |
+			(new_serial.flags & ASYNC_FLAGS));
+	info->flags = ((state->flags & ~ASYNC_INTERNAL_FLAGS) |
+		       (info->flags & ASYNC_INTERNAL_FLAGS));
+	state->custom_divisor = new_serial.custom_divisor;
+	state->close_delay = new_serial.close_delay * HZ/100;
+	state->closing_wait = new_serial.closing_wait * HZ/100;
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	info->xmit_fifo_size = state->xmit_fifo_size =
+		new_serial.xmit_fifo_size;
+
+	if ((state->type != PORT_UNKNOWN) && state->port) {
+		release_region(state->port,8);
+	}
+	state->type = new_serial.type;
+	if (change_port || change_irq) {
+		/*
+		 * We need to shutdown the serial port at the old
+		 * port/irq combination.
+		 */
+		shutdown(info);
+		state->irq = new_serial.irq;
+		info->port = state->port = new_port;
+		info->hub6 = state->hub6 = new_serial.hub6;
+		if (info->hub6)
+			info->io_type = state->io_type = SERIAL_IO_HUB6;
+		else if (info->io_type == SERIAL_IO_HUB6)
+			info->io_type = state->io_type = SERIAL_IO_PORT;
+	}
+	if ((state->type != PORT_UNKNOWN) && state->port) {
+			request_region(state->port,8,"serial(set)");
+	}
+
+	
+check_and_exit:
+	if (!state->port || !state->type)
+		return 0;
+	if (info->flags & ASYNC_INITIALIZED) {
+		if (((old_state.flags & ASYNC_SPD_MASK) !=
+		     (state->flags & ASYNC_SPD_MASK)) ||
+		    (old_state.custom_divisor != state->custom_divisor)) {
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+				info->tty->alt_speed = 57600;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+				info->tty->alt_speed = 115200;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+				info->tty->alt_speed = 230400;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+				info->tty->alt_speed = 460800;
+			change_speed(info, 0);
+		}
+	} else {
+		retval = startup(info);
+	}
+	return retval;
+}
+#endif
+
+
+static int rs_ioctl(struct tty_struct *tty, struct file * file,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct async_icount cnow;	/* kernel counter temps */
+	struct serial_icounter_struct icount;
+	unsigned long flags;
+	
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
+	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+		    return -EIO;
+	}
+	
+	switch (cmd) {
+		//case TIOCMGET:
+		//	return get_modem_info(info, (unsigned int *) arg);
+		case TIOCMBIS:
+		case TIOCMBIC:
+		//case TIOCMSET:
+		//	return set_modem_info(info, cmd, (unsigned int *) arg);
+		case TIOCGSERIAL:
+			return get_serial_info(info,
+					       (struct serial_struct *) arg);
+		//case TIOCSSERIAL:
+		//	return set_serial_info(info,
+					       //(struct serial_struct *) arg);
+		//case TIOCSERCONFIG:
+		//	return do_autoconfig(info);
+
+		//case TIOCSERGETLSR: /* Get line status register */
+		//	return get_lsr_info(info, (unsigned int *) arg);
+
+		case TIOCSERGSTRUCT:
+			if (copy_to_user((struct async_struct *) arg,
+					 info, sizeof(struct async_struct)))
+				return -EFAULT;
+			return 0;
+				
+			
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+ 		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
+		case TIOCMIWAIT:
+#if 0
+			save_flags(flags); 
+			cli();
+			/* note the counters on entry */
+			cprev = info->state->icount;
+			restore_flags(flags);
+			/* Force modem status interrupts on */
+			info->IER |= UART_IER_MSI;
+			serial_out(info, UART_IER, info->IER);
+			while (1) {
+				interruptible_sleep_on(&info->delta_msr_wait);
+				/* see if a signal did it */
+				if (signal_pending(current))
+					return -ERESTARTSYS;
+				save_flags(flags); cli();
+				cnow = info->state->icount; /* atomic copy */
+				restore_flags(flags);
+				if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr && 
+				    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
+					return -EIO; /* no change => error */
+				if ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+				     ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+				     ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+				     ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
+					return 0;
+				}
+				cprev = cnow;
+			}
+			/* NOTREACHED */
+#endif
+
+		/* 
+		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+		 * Return: write counters to the user passed counter struct
+		 * NB: both 1->0 and 0->1 transitions are counted except for
+		 *     RI where only 0->1 is counted.
+		 */
+		case TIOCGICOUNT:
+			save_flags(flags); 
+			cli();
+			cnow = info->state->icount;
+			restore_flags(flags);
+			icount.cts = cnow.cts;
+			icount.dsr = cnow.dsr;
+			icount.rng = cnow.rng;
+			icount.dcd = cnow.dcd;
+			icount.rx = cnow.rx;
+			icount.tx = cnow.tx;
+			icount.frame = cnow.frame;
+			icount.overrun = cnow.overrun;
+			icount.parity = cnow.parity;
+			icount.brk = cnow.brk;
+			icount.buf_overrun = cnow.buf_overrun;
+			
+			if (copy_to_user((void *)arg, &icount, sizeof(icount)))
+				return -EFAULT;
+			return 0;
+		case TIOCSERGWILD:
+		case TIOCSERSWILD:
+			/* "setserial -W" is called in Debian boot */
+			printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
+			return 0;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void rs_throttle(struct tty_struct * tty)
+{
+#if 0
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+#ifdef SERIAL_DEBUG_THROTTLE
+	char	buf[64];
+	
+	printk("throttle %s: %d....\n", tty_name(tty, buf),
+	       tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (I_IXOFF(tty))
+		rs_send_xchar(tty, STOP_CHAR(tty));
+
+	if (tty->termios->c_cflag & CRTSCTS)
+		info->MCR &= ~UART_MCR_RTS;
+
+	save_flags(flags); cli();
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+#endif
+}
+
+
+static void rs_unthrottle(struct tty_struct * tty)
+{
+#if 0
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+#ifdef SERIAL_DEBUG_THROTTLE
+	char	buf[64];
+	
+	printk("unthrottle %s: %d....\n", tty_name(tty, buf),
+	       tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else
+			rs_send_xchar(tty, START_CHAR(tty));
+	}
+	//if (tty->termios->c_cflag & CRTSCTS)
+	//	info->MCR |= UART_MCR_RTS;
+	save_flags(flags); 
+	cli();
+	//serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+#endif
+}
+
+
+static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
+{
+#if 0
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	unsigned int cflag = tty->termios->c_cflag;
+	
+	if ((cflag == old_termios->c_cflag)
+	    && (RELEVANT_IFLAG(tty->termios->c_iflag) 
+		== RELEVANT_IFLAG(old_termios->c_iflag)))
+	  return;
+
+	/* Handle transition to B0 status */
+	if ((old_termios->c_cflag & CBAUD) &&
+	    !(cflag & CBAUD)) {
+		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
+		save_flags(flags); cli();
+		serial_out(info, UART_MCR, info->MCR);
+		restore_flags(flags);
+	}
+	
+	/* Handle transition away from B0 status */
+	if (!(old_termios->c_cflag & CBAUD) &&
+	    (cflag & CBAUD)) {
+		info->MCR |= UART_MCR_DTR;
+		if (!(tty->termios->c_cflag & CRTSCTS) || 
+		    !test_bit(TTY_THROTTLED, &tty->flags)) {
+			info->MCR |= UART_MCR_RTS;
+		}
+		save_flags(flags); cli();
+		serial_out(info, UART_MCR, info->MCR);
+		restore_flags(flags);
+	}
+	
+	/* Handle turning off CRTSCTS */
+	if ((old_termios->c_cflag & CRTSCTS) &&
+	    !(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		rs_start(tty);
+	}
+#endif
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop() and rs_start()
+ *
+ * This routines are called before setting or resetting tty->stopped.
+ * They enable or disable transmitter interrupts, as necessary.
+ * ------------------------------------------------------------
+ */
+static void rs_stop(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	save_flags(flags); 
+	cli();
+	
+	if (info->IER & UART_TX_INT_EN) {
+		info->IER &= ~UART_TX_INT_EN;
+		serial_out(info, UART_CR_REG, info->IER);
+	}
+	restore_flags(flags);
+}
+
+
+
+static void rs_start(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	save_flags(flags); 
+	cli();
+	
+	if (info->xmit.head != info->xmit.tail
+	    && info->xmit.buf
+	    && !(info->IER & UART_TX_INT_EN)) {
+		info->IER |= UART_TX_INT_EN;
+		serial_out(info, UART_CR_REG, info->IER);
+	}
+	restore_flags(flags);
+}
+
+
+/*
+ * rs_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void rs_hangup(struct tty_struct *tty)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state = info->state;
+	
+	state = info->state;
+	
+	rs_flush_buffer(tty);
+	
+	if (info->flags & ASYNC_CLOSING)
+		return;
+
+	info->event = 0;
+	state->count = 0;
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE);
+	info->tty = 0;
+	wake_up_interruptible(&info->open_wait);
+}
+
+
+/*
+ * rs_break() --- routine which turns the break handling on or off
+ */
+static void rs_break(struct tty_struct *tty, int break_state)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	if (!CONFIGURED_SERIAL_PORT(info))
+		return;
+	
+	save_flags(flags); 
+	cli();
+	if (break_state == -1)
+		info->LCR |= UART_SEND_BREAK;
+	else
+		info->LCR &= ~UART_SEND_BREAK;
+	
+	serial_out(info, UART_LCR_H_REG, info->LCR);
+	restore_flags(flags);
+}
+
+
+/*
+ * This function is used to send a high-priority XON/XOFF character to
+ * the device
+ */
+static void rs_send_xchar(struct tty_struct *tty, char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	info->x_char = ch;
+	if (ch) {
+		/* Make sure transmit interrupts are on */
+		info->IER |= UART_TX_INT_EN;
+		serial_out(info, UART_CR_REG, info->IER);
+	}
+}
+
+
+/*
+ * rs_wait_until_sent() --- wait until the transmitter is empty
+ */
+static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+#if 0
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	unsigned long orig_jiffies, char_time;
+	int lsr;
+	
+	if (info->state->type == PORT_UNKNOWN)
+		return;
+
+	if (info->xmit_fifo_size == 0)
+		return; /* Just in case.... */
+
+	orig_jiffies = jiffies;
+	/*
+	 * Set the check interval to be 1/5 of the estimated time to
+	 * send a single character, and make it at least 1.  The check
+	 * interval should also be less than the timeout.
+	 * 
+	 * Note: we have to use pretty tight timings here to satisfy
+	 * the NIST-PCTS.
+	 */
+	char_time = (info->timeout - HZ/50) / info->xmit_fifo_size;
+	char_time = char_time / 5;
+	if (char_time == 0)
+		char_time = 1;
+	if (timeout && timeout < char_time)
+		char_time = timeout;
+	/*
+	 * If the transmitter hasn't cleared in twice the approximate
+	 * amount of time to send the entire FIFO, it probably won't
+	 * ever clear.  This assumes the UART isn't doing flow
+	 * control, which is currently the case.  Hence, if it ever
+	 * takes longer than info->timeout, this is probably due to a
+	 * UART bug of some kind.  So, we clamp the timeout parameter at
+	 * 2*info->timeout.
+	 */
+	if (!timeout || timeout > 2*info->timeout)
+		timeout = 2*info->timeout;
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);
+	printk("jiff=%lu...", jiffies);
+#endif
+	while (!((lsr = serial_inp(info, UART_LSR)) & UART_LSR_TEMT)) {
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+		printk("lsr = %d (jiff=%lu)...", lsr, jiffies);
+#endif
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(char_time);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+	set_current_state(TASK_RUNNING);
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
+#endif
+#endif
+}
+
+/*
+ * /proc fs routines....
+ */
+
+static inline int line_info(char *buf, struct serial_state *state)
+{
+#if 0
+	struct async_struct *info = state->info, scr_info;
+	char	stat_buf[30], control, status;
+	int	ret;
+	unsigned long flags;
+
+	ret = sprintf(buf, "%d: uart:%s port:%lX irq:%d",
+		      state->line, uart_config[state->type].name, 
+		      state->port, state->irq);
+
+	if (!state->port || (state->type == PORT_UNKNOWN)) {
+		ret += sprintf(buf+ret, "\n");
+		return ret;
+	}
+
+	/*
+	 * Figure out the current RS-232 lines
+	 */
+	if (!info) {
+		info = &scr_info;	/* This is just for serial_{in,out} */
+
+		info->magic = SERIAL_MAGIC;
+		info->port = state->port;
+		info->flags = state->flags;
+		info->quot = 0;
+		info->tty = 0;
+	}
+	save_flags(flags); cli();
+	status = serial_in(info, UART_MSR);
+	control = info != &scr_info ? info->MCR : serial_in(info, UART_MCR);
+	restore_flags(flags); 
+
+	stat_buf[0] = 0;
+	stat_buf[1] = 0;
+	if (control & UART_MCR_RTS)
+		strcat(stat_buf, "|RTS");
+	if (status & UART_MSR_CTS)
+		strcat(stat_buf, "|CTS");
+	if (control & UART_MCR_DTR)
+		strcat(stat_buf, "|DTR");
+	if (status & UART_MSR_DSR)
+		strcat(stat_buf, "|DSR");
+	if (status & UART_MSR_DCD)
+		strcat(stat_buf, "|CD");
+	if (status & UART_MSR_RI)
+		strcat(stat_buf, "|RI");
+
+	if (info->quot) {
+		ret += sprintf(buf+ret, " baud:%d",
+			       state->baud_base / info->quot);
+	}
+
+	ret += sprintf(buf+ret, " tx:%d rx:%d",
+		      state->icount.tx, state->icount.rx);
+
+	if (state->icount.frame)
+		ret += sprintf(buf+ret, " fe:%d", state->icount.frame);
+	
+	if (state->icount.parity)
+		ret += sprintf(buf+ret, " pe:%d", state->icount.parity);
+	
+	if (state->icount.brk)
+		ret += sprintf(buf+ret, " brk:%d", state->icount.brk);	
+
+	if (state->icount.overrun)
+		ret += sprintf(buf+ret, " oe:%d", state->icount.overrun);
+
+	/*
+	 * Last thing is the RS-232 status lines
+	 */
+	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	return ret;
+#endif
+	return 0;
+}
+
+
+int rs_read_proc(char *page, char **start, off_t off, int count,
+		 int *eof, void *data)
+{
+	int i, len = 0, l;
+	off_t	begin = 0;
+
+	len += sprintf(page, "serinfo:1.0 driver:%s%s revision:%s\n",
+		       serial_version, LOCAL_VERSTRING, serial_revdate);
+	for (i = 0; i < NR_PORTS && len < 4000; i++) {
+		l = line_info(page + len, &rs_table[i]);
+		len += l;
+		if (len+begin > off+count)
+			goto done;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= len+begin)
+		return 0;
+	*start = page + (off-begin);
+	return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+
+/* 
+ * This routine must be called by kernel at boot time 
+ */
+int serial5120_init(void) 
+{
+
+	memset(&dev_tty_driver, 0, sizeof(struct tty_driver));
+
+	dev_tty_driver.magic = TTY_DRIVER_MAGIC;
+	dev_tty_driver.driver_name = "/dev/ttyS0";
+	dev_tty_driver.name = "ttyS0";
+	dev_tty_driver.major = TTY_MAJOR;
+	dev_tty_driver.minor_start = 64;
+	dev_tty_driver.num = 1;
+	dev_tty_driver.type = TTY_DRIVER_TYPE_SERIAL;
+	dev_tty_driver.subtype = SERIAL_TYPE_NORMAL;
+	dev_tty_driver.init_termios = tty_std_termios;
+	dev_tty_driver.init_termios.c_cflag =
+		B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+	dev_tty_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	dev_tty_driver.refcount = &serial_refcount;
+	dev_tty_driver.table = serial_table;
+	dev_tty_driver.termios = serial_termios;
+	dev_tty_driver.termios_locked = serial_termios_locked;
+
+	dev_tty_driver.open = rs_open;
+	dev_tty_driver.close = rs_close;
+	dev_tty_driver.write = rs_write;
+	dev_tty_driver.put_char = rs_put_char;
+	dev_tty_driver.flush_chars = rs_flush_chars;
+	dev_tty_driver.write_room = rs_write_room;
+	dev_tty_driver.chars_in_buffer = rs_chars_in_buffer;
+	dev_tty_driver.flush_buffer = rs_flush_buffer;
+	dev_tty_driver.ioctl = rs_ioctl;
+	dev_tty_driver.throttle = rs_throttle;
+	dev_tty_driver.unthrottle = rs_unthrottle;
+	dev_tty_driver.set_termios = rs_set_termios;
+	dev_tty_driver.stop = rs_stop;
+	dev_tty_driver.start = rs_start;
+	dev_tty_driver.hangup = rs_hangup;
+	dev_tty_driver.break_ctl = rs_break;
+	dev_tty_driver.send_xchar = rs_send_xchar;
+	dev_tty_driver.wait_until_sent = rs_wait_until_sent;
+	dev_tty_driver.read_proc = rs_read_proc;
+
+	if (tty_register_driver(&dev_tty_driver))
+		panic("Couldn't register serial driver\n");		
+
+	return 0;
+}
diff -urN linux-2.4.32/arch/mips/am5120/serial_ref.c linux-2.4.32-adm5120/arch/mips/am5120/serial_ref.c
--- linux-2.4.32/arch/mips/am5120/serial_ref.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/serial_ref.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,2853 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/serial.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+
+
+static char *serial_version = "0.01";
+static char *serial_revdate = "2003-04-17";
+
+
+#include <linux/config.h>
+#include <linux/version.h>
+
+#undef SERIAL_PARANOIA_CHECK
+#define CONFIG_SERIAL_NOPAUSE_IO
+#define SERIAL_DO_RESTART
+
+
+/* Set of debugging defines */
+
+#undef SERIAL_DEBUG_INTR
+#undef SERIAL_DEBUG_OPEN
+#undef SERIAL_DEBUG_FLOW
+#undef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+#undef SERIAL_DEBUG_PCI
+#undef SERIAL_DEBUG_AUTOCONF
+
+#ifdef MODULE
+#undef CONFIG_AU1000_SERIAL_CONSOLE
+#endif
+
+#define CONFIG_SERIAL_RSA
+
+#define RS_STROBE_TIME (10*HZ)
+#define RS_ISR_PASS_LIMIT 256
+  
+/*
+ * End of serial driver configuration section.
+ */
+
+#include <linux/module.h>
+
+#include <linux/types.h>
+#ifdef LOCAL_HEADERS
+#include "serial_local.h"
+#else
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <asm/au1000.h>
+#include <asm/serial.h>
+#define LOCAL_VERSTRING ""
+#endif
+
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/major.h>
+#include <linux/string.h>
+#include <linux/fcntl.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#ifdef CONFIG_AU1000_SERIAL_CONSOLE
+#include <linux/console.h>
+#endif
+#ifdef CONFIG_MAGIC_SYSRQ
+#include <linux/sysrq.h>
+#endif
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+
+#ifdef CONFIG_MAC_SERIAL
+#define SERIAL_DEV_OFFSET	2
+#else
+#define SERIAL_DEV_OFFSET	0
+#endif
+
+#ifdef SERIAL_INLINE
+#define _INLINE_ inline
+#else
+#define _INLINE_
+#endif
+
+static char *serial_name = "Serial driver";
+
+static DECLARE_TASK_QUEUE(tq_serial);
+
+static struct tty_driver serial_driver, callout_driver;
+static int serial_refcount;
+
+static struct timer_list serial_timer;
+
+extern unsigned long get_au1000_uart_baud_base(void);
+
+/* serial subtype definitions */
+#ifndef SERIAL_TYPE_NORMAL
+#define SERIAL_TYPE_NORMAL	1
+#define SERIAL_TYPE_CALLOUT	2
+#endif
+
+/* number of characters left in xmit buffer before we ask for more */
+#define WAKEUP_CHARS 256
+
+/*
+ * IRQ_timeout		- How long the timeout should be for each IRQ
+ * 				should be after the IRQ has been active.
+ */
+
+static struct async_struct *IRQ_ports[NR_IRQS];
+static int IRQ_timeout[NR_IRQS];
+#ifdef CONFIG_AU1000_SERIAL_CONSOLE
+static struct console sercons;
+static int lsr_break_flag;
+#endif
+#if defined(CONFIG_AU1000_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+static unsigned long break_pressed; /* break, really ... */
+#endif
+
+static void autoconfig(struct serial_state * state);
+static void change_speed(struct async_struct *info, struct termios *old);
+static void rs_wait_until_sent(struct tty_struct *tty, int timeout);
+
+/*
+ * Here we define the default xmit fifo size used for each type of
+ * UART
+ */
+static struct serial_uart_config uart_config[] = {
+	{ "unknown", 1, 0 }, 
+	{ "8250", 1, 0 }, 
+	{ "16450", 1, 0 }, 
+	{ "16550", 1, 0 }, 
+	{ 0, 0}
+};
+
+
+static struct serial_state rs_table[RS_TABLE_SIZE] = {
+	SERIAL_PORT_DFNS	/* Defined in serial.h */
+};
+
+#define NR_PORTS	(sizeof(rs_table)/sizeof(struct serial_state))
+
+#ifndef PREPARE_FUNC
+#define PREPARE_FUNC(dev)  (dev->prepare)
+#define ACTIVATE_FUNC(dev)  (dev->activate)
+#define DEACTIVATE_FUNC(dev)  (dev->deactivate)
+#endif
+
+#define HIGH_BITS_OFFSET ((sizeof(long)-sizeof(int))*8)
+
+static struct tty_struct *serial_table[NR_PORTS];
+static struct termios *serial_termios[NR_PORTS];
+static struct termios *serial_termios_locked[NR_PORTS];
+
+
+#if defined(MODULE) && defined(SERIAL_DEBUG_MCOUNT)
+#define DBG_CNT(s) printk("(%s): [%x] refc=%d, serc=%d, ttyc=%d -> %s\n", \
+ kdevname(tty->device), (info->flags), serial_refcount,info->count,tty->count,s)
+#else
+#define DBG_CNT(s)
+#endif
+
+/*
+ * tmp_buf is used as a temporary buffer by serial_write.  We need to
+ * lock it in case the copy_from_user blocks while swapping in a page,
+ * and some other program tries to do a serial write at the same time.
+ * Since the lock will only come under contention when the system is
+ * swapping and available memory is low, it makes sense to share one
+ * buffer across all the serial ports, since it significantly saves
+ * memory if large numbers of serial ports are open.
+ */
+static unsigned char *tmp_buf;
+#ifdef DECLARE_MUTEX
+static DECLARE_MUTEX(tmp_buf_sem);
+#else
+static struct semaphore tmp_buf_sem = MUTEX;
+#endif
+
+
+static inline int serial_paranoia_check(struct async_struct *info,
+					kdev_t device, const char *routine)
+{
+#ifdef SERIAL_PARANOIA_CHECK
+	static const char *badmagic =
+		"Warning: bad magic number for serial struct (%s) in %s\n";
+	static const char *badinfo =
+		"Warning: null async_struct for (%s) in %s\n";
+
+	if (!info) {
+		printk(badinfo, kdevname(device), routine);
+		return 1;
+	}
+	if (info->magic != SERIAL_MAGIC) {
+		printk(badmagic, kdevname(device), routine);
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+
+static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
+{
+	return (inl(info->port+offset) & 0xffff);
+}
+
+static _INLINE_ void serial_out(struct async_struct *info, int offset, int value)
+{
+	outl(value & 0xffff, info->port+offset);
+}
+
+
+/*
+ * We used to support using pause I/O for certain machines.  We
+ * haven't supported this for a while, but just in case it's badly
+ * needed for certain old 386 machines, I've left these #define's
+ * in....
+ */
+#define serial_inp(info, offset)		serial_in(info, offset)
+#define serial_outp(info, offset, value)	serial_out(info, offset, value)
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop() and rs_start()
+ *
+ * This routines are called before setting or resetting tty->stopped.
+ * They enable or disable transmitter interrupts, as necessary.
+ * ------------------------------------------------------------
+ */
+static void rs_stop(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "rs_stop"))
+		return;
+	
+	save_flags(flags); cli();
+	if (info->IER & UART_IER_THRI) {
+		info->IER &= ~UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+	restore_flags(flags);
+}
+
+static void rs_start(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	if (serial_paranoia_check(info, tty->device, "rs_start"))
+		return;
+	
+	save_flags(flags); cli();
+	if (info->xmit.head != info->xmit.tail
+	    && info->xmit.buf
+	    && !(info->IER & UART_IER_THRI)) {
+		info->IER |= UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+	restore_flags(flags);
+}
+
+/*
+ * ----------------------------------------------------------------------
+ *
+ * Here starts the interrupt handling routines.  All of the following
+ * subroutines are declared as inline and are folded into
+ * rs_interrupt().  They were separated out for readability's sake.
+ *
+ * Note: rs_interrupt() is a "fast" interrupt, which means that it
+ * runs with interrupts turned off.  People who may want to modify
+ * rs_interrupt() should try to keep the interrupt handler as fast as
+ * possible.  After you are done making modifications, it is not a bad
+ * idea to do:
+ * 
+ * gcc -S -DKERNEL -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer serial.c
+ *
+ * and look at the resulting assemble code in serial.s.
+ *
+ * 				- Ted Ts'o (tytso@mit.edu), 7-Mar-93
+ * -----------------------------------------------------------------------
+ */
+
+/*
+ * This routine is used by the interrupt handler to schedule
+ * processing in the software interrupt portion of the driver.
+ */
+static _INLINE_ void rs_sched_event(struct async_struct *info,
+				  int event)
+{
+	info->event |= 1 << event;
+	queue_task(&info->tqueue, &tq_serial);
+	mark_bh(SERIAL_BH);
+}
+
+static _INLINE_ void receive_chars(struct async_struct *info,
+				 int *status, struct pt_regs * regs)
+{
+	struct tty_struct *tty = info->tty;
+	unsigned char ch;
+	int ignored = 0;
+	struct	async_icount *icount;
+
+	icount = &info->state->icount;
+	do {
+		ch = serial_inp(info, UART_RX);
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+			goto ignore_char;
+		*tty->flip.char_buf_ptr = ch;
+		icount->rx++;
+		
+#ifdef SERIAL_DEBUG_INTR
+		printk("DR%02x:%02x...", ch, *status);
+#endif
+		*tty->flip.flag_buf_ptr = 0;
+		if (*status & (UART_LSR_BI | UART_LSR_PE |
+			       UART_LSR_FE | UART_LSR_OE)) {
+			/*
+			 * For statistics only
+			 */
+			if (*status & UART_LSR_BI) {
+				*status &= ~(UART_LSR_FE | UART_LSR_PE);
+				icount->brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+#if defined(CONFIG_AU1000_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+				if (info->line == sercons.index) {
+					if (!break_pressed) {
+						break_pressed = jiffies;
+						goto ignore_char;
+					}
+					break_pressed = 0;
+				}
+#endif
+				if (info->flags & ASYNC_SAK)
+					do_SAK(tty);
+			} else if (*status & UART_LSR_PE)
+				icount->parity++;
+			else if (*status & UART_LSR_FE)
+				icount->frame++;
+			if (*status & UART_LSR_OE)
+				icount->overrun++;
+
+			/*
+			 * Now check to see if character should be
+			 * ignored, and mask off conditions which
+			 * should be ignored.
+			 */
+			if (*status & info->ignore_status_mask) {
+				if (++ignored > 100)
+					break;
+				goto ignore_char;
+			}
+			*status &= info->read_status_mask;
+
+#ifdef CONFIG_AU1000_SERIAL_CONSOLE
+			if (info->line == sercons.index) {
+				/* Recover the break flag from console xmit */
+				*status |= lsr_break_flag;
+				lsr_break_flag = 0;
+			}
+#endif
+			if (*status & (UART_LSR_BI)) {
+#ifdef SERIAL_DEBUG_INTR
+				printk("handling break....");
+#endif
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			} else if (*status & UART_LSR_PE)
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+			else if (*status & UART_LSR_FE)
+				*tty->flip.flag_buf_ptr = TTY_FRAME;
+			if (*status & UART_LSR_OE) {
+				/*
+				 * Overrun is special, since it's
+				 * reported immediately, and doesn't
+				 * affect the current character
+				 */
+				tty->flip.count++;
+				tty->flip.flag_buf_ptr++;
+				tty->flip.char_buf_ptr++;
+				*tty->flip.flag_buf_ptr = TTY_OVERRUN;
+				if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+					goto ignore_char;
+			}
+		}
+#if defined(CONFIG_AU1000_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+		if (break_pressed && info->line == sercons.index) {
+			if (ch != 0 &&
+			    time_before(jiffies, break_pressed + HZ*5)) {
+				handle_sysrq(ch, regs, NULL, NULL);
+				break_pressed = 0;
+				goto ignore_char;
+			}
+			break_pressed = 0;
+		}
+#endif
+		tty->flip.flag_buf_ptr++;
+		tty->flip.char_buf_ptr++;
+		tty->flip.count++;
+	ignore_char:
+		*status = serial_inp(info, UART_LSR);
+	} while (*status & UART_LSR_DR);
+	tty_flip_buffer_push(tty);
+}
+
+static _INLINE_ void transmit_chars(struct async_struct *info, int *intr_done)
+{
+	int count;
+
+	if (info->x_char) {
+		serial_outp(info, UART_TX, info->x_char);
+		info->state->icount.tx++;
+		info->x_char = 0;
+		if (intr_done)
+			*intr_done = 0;
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+	    || info->tty->stopped
+	    || info->tty->hw_stopped) {
+		info->IER &= ~UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+		return;
+	}
+	
+	count = info->xmit_fifo_size;
+	do {
+		serial_out(info, UART_TX, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);
+		info->state->icount.tx++;
+		if (info->xmit.head == info->xmit.tail)
+			break;
+	} while (--count > 0);
+	
+	if (CIRC_CNT(info->xmit.head,
+		     info->xmit.tail,
+		     SERIAL_XMIT_SIZE) < WAKEUP_CHARS)
+		rs_sched_event(info, RS_EVENT_WRITE_WAKEUP);
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("THRE...");
+#endif
+	if (intr_done)
+		*intr_done = 0;
+
+	if (info->xmit.head == info->xmit.tail) {
+		info->IER &= ~UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+}
+
+static _INLINE_ void check_modem_status(struct async_struct *info)
+{
+	int	status;
+	struct	async_icount *icount;
+	
+	status = serial_in(info, UART_MSR);
+
+	if (status & UART_MSR_ANY_DELTA) {
+		icount = &info->state->icount;
+		/* update input line counters */
+		if (status & UART_MSR_TERI)
+			icount->rng++;
+		if (status & UART_MSR_DDSR)
+			icount->dsr++;
+		if (status & UART_MSR_DDCD) {
+			icount->dcd++;
+#ifdef CONFIG_HARD_PPS
+			if ((info->flags & ASYNC_HARDPPS_CD) &&
+			    (status & UART_MSR_DCD))
+				hardpps();
+#endif
+		}
+		if (status & UART_MSR_DCTS)
+			icount->cts++;
+		wake_up_interruptible(&info->delta_msr_wait);
+	}
+
+	if ((info->flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
+#if (defined(SERIAL_DEBUG_OPEN) || defined(SERIAL_DEBUG_INTR))
+		printk("ttys%d CD now %s...", info->line,
+		       (status & UART_MSR_DCD) ? "on" : "off");
+#endif		
+		if (status & UART_MSR_DCD)
+			wake_up_interruptible(&info->open_wait);
+		else if (!((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+			   (info->flags & ASYNC_CALLOUT_NOHUP))) {
+#ifdef SERIAL_DEBUG_OPEN
+			printk("doing serial hangup...");
+#endif
+			if (info->tty)
+				tty_hangup(info->tty);
+		}
+	}
+	if (info->flags & ASYNC_CTS_FLOW) {
+		if (info->tty->hw_stopped) {
+			if (status & UART_MSR_CTS) {
+#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))
+				printk("CTS tx start...");
+#endif
+				info->tty->hw_stopped = 0;
+				info->IER |= UART_IER_THRI;
+				serial_out(info, UART_IER, info->IER);
+				rs_sched_event(info, RS_EVENT_WRITE_WAKEUP);
+				return;
+			}
+		} else {
+			if (!(status & UART_MSR_CTS)) {
+#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))
+				printk("CTS tx stop...");
+#endif
+				info->tty->hw_stopped = 1;
+				info->IER &= ~UART_IER_THRI;
+				serial_out(info, UART_IER, info->IER);
+			}
+		}
+	}
+}
+
+
+
+/*
+ * This is the serial driver's interrupt routine for a single port
+ */
+static void rs_interrupt_single(int irq, void *dev_id, struct pt_regs * regs)
+{
+	int status;
+	int pass_counter = 0;
+	struct async_struct * info;
+	
+#ifdef SERIAL_DEBUG_INTR
+	printk("rs_interrupt_single(%d)...", irq);
+#endif
+
+	info = IRQ_ports[irq];
+	if (!info || !info->tty)
+		return;
+
+	do {
+		status = serial_inp(info, UART_LSR);
+#ifdef SERIAL_DEBUG_INTR
+		printk("status = %x...", status);
+#endif
+		if (status & UART_LSR_DR)
+			receive_chars(info, &status, regs);
+		check_modem_status(info);
+		if (status & UART_LSR_THRE)
+			transmit_chars(info, 0);
+		if (pass_counter++ > RS_ISR_PASS_LIMIT) {
+#if 0
+			printk("rs_single loop break.\n");
+#endif
+			break;
+		}
+	} while (!(serial_in(info, UART_IIR) & UART_IIR_NO_INT));
+	info->last_active = jiffies;
+#ifdef SERIAL_DEBUG_INTR
+	printk("end.\n");
+#endif
+}
+
+
+/*
+ * -------------------------------------------------------------------
+ * Here ends the serial interrupt routines.
+ * -------------------------------------------------------------------
+ */
+
+/*
+ * This routine is used to handle the "bottom half" processing for the
+ * serial driver, known also the "software interrupt" processing.
+ * This processing is done at the kernel interrupt level, after the
+ * rs_interrupt() has returned, BUT WITH INTERRUPTS TURNED ON.  This
+ * is where time-consuming activities which can not be done in the
+ * interrupt driver proper are done; the interrupt driver schedules
+ * them using rs_sched_event(), and they get done here.
+ */
+static void do_serial_bh(void)
+{
+	run_task_queue(&tq_serial);
+}
+
+static void do_softint(void *private_)
+{
+	struct async_struct	*info = (struct async_struct *) private_;
+	struct tty_struct	*tty;
+	
+	tty = info->tty;
+	if (!tty)
+		return;
+
+	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event)) {
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		    tty->ldisc.write_wakeup)
+			(tty->ldisc.write_wakeup)(tty);
+		wake_up_interruptible(&tty->write_wait);
+#ifdef SERIAL_HAVE_POLL_WAIT
+		wake_up_interruptible(&tty->poll_wait);
+#endif
+	}
+}
+
+/*
+ * This subroutine is called when the RS_TIMER goes off.  It is used
+ * by the serial driver to handle ports that do not have an interrupt
+ * (irq=0).  This doesn't work very well for 16450's, but gives barely
+ * passable results for a 16550A.  (Although at the expense of much
+ * CPU overhead).
+ */
+static void rs_timer(unsigned long dummy)
+{
+	static unsigned long last_strobe;
+	struct async_struct *info;
+	unsigned int	i;
+	unsigned long flags;
+
+	if ((jiffies - last_strobe) >= RS_STROBE_TIME) {
+		for (i=0; i < NR_IRQS; i++) {
+			info = IRQ_ports[i];
+			if (!info)
+				continue;
+			save_flags(flags); cli();
+				rs_interrupt_single(i, NULL, NULL);
+			restore_flags(flags);
+		}
+	}
+	last_strobe = jiffies;
+	mod_timer(&serial_timer, jiffies + RS_STROBE_TIME);
+
+#if 0
+	if (IRQ_ports[0]) {
+		save_flags(flags); cli();
+		rs_interrupt_single(0, NULL, NULL);
+		restore_flags(flags);
+
+		mod_timer(&serial_timer, jiffies + IRQ_timeout[0]);
+	}
+#endif
+}
+
+/*
+ * ---------------------------------------------------------------
+ * Low level utility subroutines for the serial driver:  routines to
+ * figure out the appropriate timeout for an interrupt chain, routines
+ * to initialize and startup a serial port, and routines to shutdown a
+ * serial port.  Useful stuff like that.
+ * ---------------------------------------------------------------
+ */
+
+/*
+ * This routine figures out the correct timeout for a particular IRQ.
+ * It uses the smallest timeout of all of the serial ports in a
+ * particular interrupt chain.  Now only used for IRQ 0....
+ */
+static void figure_IRQ_timeout(int irq)
+{
+	struct	async_struct	*info;
+	int	timeout = 60*HZ;	/* 60 seconds === a long time :-) */
+
+	info = IRQ_ports[irq];
+	if (!info) {
+		IRQ_timeout[irq] = 60*HZ;
+		return;
+	}
+	while (info) {
+		if (info->timeout < timeout)
+			timeout = info->timeout;
+		info = info->next_port;
+	}
+	if (!irq)
+		timeout = timeout / 2;
+	IRQ_timeout[irq] = (timeout > 3) ? timeout-2 : 1;
+}
+
+
+static int startup(struct async_struct * info)
+{
+	unsigned long flags;
+	int	retval=0;
+	void (*handler)(int, void *, struct pt_regs *);
+	struct serial_state *state= info->state;
+	unsigned long page;
+
+	page = get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	save_flags(flags); cli();
+
+	if (info->flags & ASYNC_INITIALIZED) {
+		free_page(page);
+		goto errout;
+	}
+
+	if (!CONFIGURED_SERIAL_PORT(state) || !state->type) {
+		if (info->tty)
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		free_page(page);
+		goto errout;
+	}
+	if (info->xmit.buf)
+		free_page(page);
+	else
+		info->xmit.buf = (unsigned char *) page;
+
+
+	if (inl(UART_MOD_CNTRL + state->port) != 0x3) {
+		outl(3, UART_MOD_CNTRL + state->port);
+		au_sync_delay(10);
+	}
+#ifdef SERIAL_DEBUG_OPEN
+	printk("starting up ttys%d (irq %d)...", info->line, state->irq);
+#endif
+
+
+	/*
+	 * Clear the FIFO buffers and disable them
+	 * (they will be reenabled in change_speed())
+	 */
+	if (uart_config[state->type].flags & UART_CLEAR_FIFO) {
+		serial_outp(info, UART_FCR, UART_FCR_ENABLE_FIFO);
+		serial_outp(info, UART_FCR, (UART_FCR_ENABLE_FIFO |
+					     UART_FCR_CLEAR_RCVR |
+					     UART_FCR_CLEAR_XMIT));
+		serial_outp(info, UART_FCR, 0);
+	}
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) serial_inp(info, UART_LSR);
+	(void) serial_inp(info, UART_RX);
+	(void) serial_inp(info, UART_IIR);
+	(void) serial_inp(info, UART_MSR);
+
+	/*
+	 * At this point there's no way the LSR could still be 0xFF;
+	 * if it is, then bail out, because there's likely no UART
+	 * here.
+	 */
+	if (!(info->flags & ASYNC_BUGGY_UART) &&
+	    (serial_inp(info, UART_LSR) == 0xff)) {
+		printk("LSR safety check engaged!\n");
+		if (capable(CAP_SYS_ADMIN)) {
+			if (info->tty)
+				set_bit(TTY_IO_ERROR, &info->tty->flags);
+		} else
+			retval = -ENODEV;
+		goto errout;
+	}
+	
+	/*
+	 * Allocate the IRQ if necessary
+	 */
+#if 0
+	/* au1000, uart0 irq is 0 */
+	if (state->irq && (!IRQ_ports[state->irq] || !IRQ_ports[state->irq]->next_port)) {
+#endif
+	if ((!IRQ_ports[state->irq] || !IRQ_ports[state->irq]->next_port)) {
+		if (IRQ_ports[state->irq]) {
+			retval = -EBUSY;
+			goto errout;
+		} else 
+			handler = rs_interrupt_single;
+
+		retval = request_irq(state->irq, handler, SA_SHIRQ,
+				     "serial", &IRQ_ports[state->irq]);
+		if (retval) {
+			if (capable(CAP_SYS_ADMIN)) {
+				if (info->tty)
+					set_bit(TTY_IO_ERROR,
+						&info->tty->flags);
+				retval = 0;
+			}
+			goto errout;
+		}
+	}
+
+	/*
+	 * Insert serial port into IRQ chain.
+	 */
+	info->prev_port = 0;
+	info->next_port = IRQ_ports[state->irq];
+	if (info->next_port)
+		info->next_port->prev_port = info;
+	IRQ_ports[state->irq] = info;
+	figure_IRQ_timeout(state->irq);
+
+	/*
+	 * Now, initialize the UART 
+	 */
+	serial_outp(info, UART_LCR, UART_LCR_WLEN8);
+
+	info->MCR = 0;
+	if (info->tty->termios->c_cflag & CBAUD)
+		info->MCR = UART_MCR_DTR | UART_MCR_RTS;
+	{
+		if (state->irq != 0)
+			info->MCR |= UART_MCR_OUT2;
+	}
+	info->MCR |= ALPHA_KLUDGE_MCR; 		/* Don't ask */
+	serial_outp(info, UART_MCR, info->MCR);
+	
+	/*
+	 * Finally, enable interrupts
+	 */
+	info->IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;
+	serial_outp(info, UART_IER, info->IER);	/* enable interrupts */
+	
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void)serial_inp(info, UART_LSR);
+	(void)serial_inp(info, UART_RX);
+	(void)serial_inp(info, UART_IIR);
+	(void)serial_inp(info, UART_MSR);
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	info->xmit.head = info->xmit.tail = 0;
+
+	/*
+	 * Set up serial timers...
+	 */
+	mod_timer(&serial_timer, jiffies + 2*HZ/100);
+
+	/*
+	 * Set up the tty->alt_speed kludge
+	 */
+	if (info->tty) {
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			info->tty->alt_speed = 57600;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			info->tty->alt_speed = 115200;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			info->tty->alt_speed = 230400;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			info->tty->alt_speed = 460800;
+	}
+	
+	/*
+	 * and set the speed of the serial port
+	 */
+	change_speed(info, 0);
+
+	info->flags |= ASYNC_INITIALIZED;
+	restore_flags(flags);
+	return 0;
+	
+errout:
+	restore_flags(flags);
+	return retval;
+}
+
+/*
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void shutdown(struct async_struct * info)
+{
+	unsigned long	flags;
+	struct serial_state *state;
+	int		retval;
+
+	if (!(info->flags & ASYNC_INITIALIZED))
+		return;
+
+	state = info->state;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("Shutting down serial port %d (irq %d)....", info->line,
+	       state->irq);
+#endif
+	
+	save_flags(flags); cli(); /* Disable interrupts */
+
+	/*
+	 * clear delta_msr_wait queue to avoid mem leaks: we may free the irq
+	 * here so the queue might never be waken up
+	 */
+	wake_up_interruptible(&info->delta_msr_wait);
+	
+	/*
+	 * First unlink the serial port from the IRQ chain...
+	 */
+	if (info->next_port)
+		info->next_port->prev_port = info->prev_port;
+	if (info->prev_port)
+		info->prev_port->next_port = info->next_port;
+	else
+		IRQ_ports[state->irq] = info->next_port;
+	figure_IRQ_timeout(state->irq);
+	
+	/*
+	 * Free the IRQ, if necessary
+	 */
+//	if (state->irq && (!IRQ_ports[state->irq] ||
+	if ((!IRQ_ports[state->irq] ||
+			  !IRQ_ports[state->irq]->next_port)) {
+		if (IRQ_ports[state->irq]) {
+			free_irq(state->irq, &IRQ_ports[state->irq]);
+			retval = request_irq(state->irq, rs_interrupt_single,
+					     SA_SHIRQ, "serial",
+					     &IRQ_ports[state->irq]);
+			
+			if (retval)
+				printk("serial shutdown: request_irq: error %d"
+				       "  Couldn't reacquire IRQ.\n", retval);
+		} else
+			free_irq(state->irq, &IRQ_ports[state->irq]);
+	}
+
+	if (info->xmit.buf) {
+		unsigned long pg = (unsigned long) info->xmit.buf;
+		info->xmit.buf = 0;
+		free_page(pg);
+	}
+
+	info->IER = 0;
+	serial_outp(info, UART_IER, 0x00);	/* disable all intrs */
+		info->MCR &= ~UART_MCR_OUT2;
+	info->MCR |= ALPHA_KLUDGE_MCR; 		/* Don't ask */
+	
+	/* disable break condition */
+	serial_out(info, UART_LCR, serial_inp(info, UART_LCR) & ~UART_LCR_SBC);
+	
+	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
+		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
+	serial_outp(info, UART_MCR, info->MCR);
+
+	/* disable FIFO's */	
+	serial_outp(info, UART_FCR, (UART_FCR_ENABLE_FIFO |
+				     UART_FCR_CLEAR_RCVR |
+				     UART_FCR_CLEAR_XMIT));
+	serial_outp(info, UART_FCR, 0);
+
+	(void)serial_in(info, UART_RX);    /* read data port to reset things */
+	
+	if (info->tty)
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->flags &= ~ASYNC_INITIALIZED;
+#ifndef CONFIG_REMOTE_DEBUG
+	outl(0, UART_MOD_CNTRL + state->port);
+	au_sync_delay(10);
+#endif
+	restore_flags(flags);
+}
+
+
+/*
+ * This routine is called to set the UART divisor registers to match
+ * the specified baud rate for a serial port.
+ */
+static void change_speed(struct async_struct *info,
+			 struct termios *old_termios)
+{
+	int	quot = 0, baud_base, baud;
+	unsigned cflag, cval, fcr = 0;
+	int	bits;
+	unsigned long	flags;
+
+	if (!info->tty || !info->tty->termios)
+		return;
+	cflag = info->tty->termios->c_cflag;
+	if (!CONFIGURED_SERIAL_PORT(info))
+		return;
+
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	      case CS5: cval = 0x00; bits = 7; break;
+	      case CS6: cval = 0x01; bits = 8; break;
+	      case CS7: cval = 0x02; bits = 9; break;
+	      case CS8: cval = 0x03; bits = 10; break;
+	      /* Never happens, but GCC is too dumb to figure it out */
+	      default:  cval = 0x00; bits = 7; break;
+	      }
+	if (cflag & CSTOPB) {
+		cval |= 0x04;
+		bits++;
+	}
+	if (cflag & PARENB) {
+		cval |= UART_LCR_PARITY;
+		bits++;
+	}
+	if (!(cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+#ifdef CMSPAR
+	if (cflag & CMSPAR)
+		cval |= UART_LCR_SPAR;
+#endif
+
+	/* Determine divisor based on baud rate */
+	baud = tty_get_baud_rate(info->tty);
+	if (!baud) {
+		baud = 9600;	/* B0 transition handled in rs_set_termios */
+	}
+	baud_base = get_au1000_uart_baud_base();
+
+	//if (baud == 38400 &&
+	if (((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)) {
+		quot = info->state->custom_divisor;
+	}
+	else {
+		if (baud == 134)
+			/* Special case since 134 is really 134.5 */
+			quot = (2*baud_base / 269);
+		else if (baud)
+			quot = baud_base / baud;
+	}
+	/* If the quotient is zero refuse the change */
+	if (!quot && old_termios) {
+		info->tty->termios->c_cflag &= ~CBAUD;
+		info->tty->termios->c_cflag |= (old_termios->c_cflag & CBAUD);
+		baud = tty_get_baud_rate(info->tty);
+		if (!baud)
+			baud = 9600;
+		if (baud == 38400 &&
+		    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
+			quot = info->state->custom_divisor;
+		else {
+			if (baud == 134)
+				/* Special case since 134 is really 134.5 */
+				quot = (2*baud_base / 269);
+			else if (baud)
+				quot = baud_base / baud;
+		}
+	}
+	/* As a last resort, if the quotient is zero, default to 9600 bps */
+	if (!quot)
+		quot = baud_base / 9600;
+	
+	info->quot = quot;
+	info->timeout = ((info->xmit_fifo_size*HZ*bits*quot) / baud_base);
+	info->timeout += HZ/50;		/* Add .02 seconds of slop */
+
+	/* Set up FIFO's */
+	if (uart_config[info->state->type].flags & UART_USE_FIFO) {
+		if ((info->state->baud_base / quot) < 2400)
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIGGER_1;
+		else
+			fcr = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIGGER_8;
+	}
+	
+	/* CTS flow control flag and modem status interrupts */
+	info->IER &= ~UART_IER_MSI;
+	if (info->flags & ASYNC_HARDPPS_CD)
+		info->IER |= UART_IER_MSI;
+	if (cflag & CRTSCTS) {
+		info->flags |= ASYNC_CTS_FLOW;
+		info->IER |= UART_IER_MSI;
+	} else
+		info->flags &= ~ASYNC_CTS_FLOW;
+	if (cflag & CLOCAL)
+		info->flags &= ~ASYNC_CHECK_CD;
+	else {
+		info->flags |= ASYNC_CHECK_CD;
+		info->IER |= UART_IER_MSI;
+	}
+	serial_out(info, UART_IER, info->IER);
+
+	/*
+	 * Set up parity check flag
+	 */
+#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+	info->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (I_INPCK(info->tty))
+		info->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+		info->read_status_mask |= UART_LSR_BI;
+	
+	/*
+	 * Characters to ignore
+	 */
+	info->ignore_status_mask = 0;
+	if (I_IGNPAR(info->tty))
+		info->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (I_IGNBRK(info->tty)) {
+		info->ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignore parity and break indicators, ignore 
+		 * overruns too.  (For real raw support).
+		 */
+		if (I_IGNPAR(info->tty))
+			info->ignore_status_mask |= UART_LSR_OE;
+	}
+	/*
+	 * !!! ignore all characters if CREAD is not set
+	 */
+	if ((cflag & CREAD) == 0)
+		info->ignore_status_mask |= UART_LSR_DR;
+	save_flags(flags); cli();
+
+	serial_outp(info, UART_CLK, quot & 0xffff);
+	serial_outp(info, UART_LCR, cval);
+	info->LCR = cval;				/* Save LCR */
+	restore_flags(flags);
+}
+
+static void rs_put_char(struct tty_struct *tty, unsigned char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "rs_put_char"))
+		return;
+
+	if (!tty || !info->xmit.buf)
+		return;
+
+	save_flags(flags); cli();
+	if (CIRC_SPACE(info->xmit.head,
+		       info->xmit.tail,
+		       SERIAL_XMIT_SIZE) == 0) {
+		restore_flags(flags);
+		return;
+	}
+
+	info->xmit.buf[info->xmit.head] = ch;
+	info->xmit.head = (info->xmit.head + 1) & (SERIAL_XMIT_SIZE-1);
+	restore_flags(flags);
+}
+
+static void rs_flush_chars(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+				
+	if (serial_paranoia_check(info, tty->device, "rs_flush_chars"))
+		return;
+
+	if (info->xmit.head == info->xmit.tail
+	    || tty->stopped
+	    || tty->hw_stopped
+	    || !info->xmit.buf)
+		return;
+
+	save_flags(flags); cli();
+	info->IER |= UART_IER_THRI;
+	serial_out(info, UART_IER, info->IER);
+	restore_flags(flags);
+}
+
+static int rs_write(struct tty_struct * tty, int from_user,
+		    const unsigned char *buf, int count)
+{
+	int	c, ret = 0;
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+				
+	if (serial_paranoia_check(info, tty->device, "rs_write"))
+		return 0;
+
+	if (!tty || !info->xmit.buf || !tmp_buf)
+		return 0;
+
+	save_flags(flags);
+	if (from_user) {
+		down(&tmp_buf_sem);
+		while (1) {
+			int c1;
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					      info->xmit.tail,
+					      SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0)
+				break;
+
+			c -= copy_from_user(tmp_buf, buf, c);
+			if (!c) {
+				if (!ret)
+					ret = -EFAULT;
+				break;
+			}
+			cli();
+			c1 = CIRC_SPACE_TO_END(info->xmit.head,
+					       info->xmit.tail,
+					       SERIAL_XMIT_SIZE);
+			if (c1 < c)
+				c = c1;
+			memcpy(info->xmit.buf + info->xmit.head, tmp_buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					   (SERIAL_XMIT_SIZE-1));
+			restore_flags(flags);
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		up(&tmp_buf_sem);
+	} else {
+		cli();
+		while (1) {
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					      info->xmit.tail,
+					      SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0) {
+				break;
+			}
+			memcpy(info->xmit.buf + info->xmit.head, buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					   (SERIAL_XMIT_SIZE-1));
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		restore_flags(flags);
+	}
+	if (info->xmit.head != info->xmit.tail
+	    && !tty->stopped
+	    && !tty->hw_stopped
+	    && !(info->IER & UART_IER_THRI)) {
+		info->IER |= UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+	return ret;
+}
+
+static int rs_write_room(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->device, "rs_write_room"))
+		return 0;
+	return CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+static int rs_chars_in_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+				
+	if (serial_paranoia_check(info, tty->device, "rs_chars_in_buffer"))
+		return 0;
+	return CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+static void rs_flush_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	if (serial_paranoia_check(info, tty->device, "rs_flush_buffer"))
+		return;
+	save_flags(flags); cli();
+	info->xmit.head = info->xmit.tail = 0;
+	restore_flags(flags);
+	wake_up_interruptible(&tty->write_wait);
+#ifdef SERIAL_HAVE_POLL_WAIT
+	wake_up_interruptible(&tty->poll_wait);
+#endif
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+}
+
+/*
+ * This function is used to send a high-priority XON/XOFF character to
+ * the device
+ */
+static void rs_send_xchar(struct tty_struct *tty, char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->device, "rs_send_char"))
+		return;
+
+	info->x_char = ch;
+	if (ch) {
+		/* Make sure transmit interrupts are on */
+		info->IER |= UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void rs_throttle(struct tty_struct * tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+#ifdef SERIAL_DEBUG_THROTTLE
+	char	buf[64];
+	
+	printk("throttle %s: %d....\n", tty_name(tty, buf),
+	       tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->device, "rs_throttle"))
+		return;
+	
+	if (I_IXOFF(tty))
+		rs_send_xchar(tty, STOP_CHAR(tty));
+
+	if (tty->termios->c_cflag & CRTSCTS)
+		info->MCR &= ~UART_MCR_RTS;
+
+	save_flags(flags); cli();
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+}
+
+static void rs_unthrottle(struct tty_struct * tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+#ifdef SERIAL_DEBUG_THROTTLE
+	char	buf[64];
+	
+	printk("unthrottle %s: %d....\n", tty_name(tty, buf),
+	       tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->device, "rs_unthrottle"))
+		return;
+	
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else
+			rs_send_xchar(tty, START_CHAR(tty));
+	}
+	if (tty->termios->c_cflag & CRTSCTS)
+		info->MCR |= UART_MCR_RTS;
+	save_flags(flags); cli();
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl() and friends
+ * ------------------------------------------------------------
+ */
+
+static int get_serial_info(struct async_struct * info,
+			   struct serial_struct * retinfo)
+{
+	struct serial_struct tmp;
+	struct serial_state *state = info->state;
+   
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = state->type;
+	tmp.line = state->line;
+	tmp.port = state->port;
+	if (HIGH_BITS_OFFSET)
+		tmp.port_high = state->port >> HIGH_BITS_OFFSET;
+	else
+		tmp.port_high = 0;
+	tmp.irq = state->irq;
+	tmp.flags = state->flags;
+	tmp.xmit_fifo_size = state->xmit_fifo_size;
+	tmp.baud_base = state->baud_base;
+	tmp.close_delay = state->close_delay;
+	tmp.closing_wait = state->closing_wait;
+	tmp.custom_divisor = state->custom_divisor;
+	tmp.hub6 = state->hub6;
+	tmp.io_type = state->io_type;
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int set_serial_info(struct async_struct * info,
+			   struct serial_struct * new_info)
+{
+	struct serial_struct new_serial;
+ 	struct serial_state old_state, *state;
+	unsigned int		i,change_irq,change_port;
+	int 			retval = 0;
+	unsigned long		new_port;
+
+	if (copy_from_user(&new_serial,new_info,sizeof(new_serial)))
+		return -EFAULT;
+	state = info->state;
+	old_state = *state;
+
+	new_port = new_serial.port;
+	if (HIGH_BITS_OFFSET)
+		new_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;
+
+	change_irq = new_serial.irq != state->irq;
+	change_port = (new_port != ((int) state->port)) ||
+		(new_serial.hub6 != state->hub6);
+  
+	if (!capable(CAP_SYS_ADMIN)) {
+		if (change_irq || change_port ||
+		    (new_serial.baud_base != state->baud_base) ||
+		    (new_serial.type != state->type) ||
+		    (new_serial.close_delay != state->close_delay) ||
+		    (new_serial.xmit_fifo_size != state->xmit_fifo_size) ||
+		    ((new_serial.flags & ~ASYNC_USR_MASK) !=
+		     (state->flags & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		state->flags = ((state->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		state->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	new_serial.irq = irq_cannonicalize(new_serial.irq);
+
+	if ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) || 
+	    (new_serial.baud_base < 9600)|| (new_serial.type < PORT_UNKNOWN) ||
+	    (new_serial.type > PORT_MAX) || (new_serial.type == PORT_CIRRUS) ||
+	    (new_serial.type == PORT_STARTECH)) {
+		return -EINVAL;
+	}
+
+	if ((new_serial.type != state->type) ||
+	    (new_serial.xmit_fifo_size <= 0))
+		new_serial.xmit_fifo_size =
+			uart_config[new_serial.type].dfl_xmit_fifo_size;
+
+	/* Make sure address is not already in use */
+	if (new_serial.type) {
+		for (i = 0 ; i < NR_PORTS; i++)
+			if ((state != &rs_table[i]) &&
+			    (rs_table[i].port == new_port) &&
+			    rs_table[i].type)
+				return -EADDRINUSE;
+	}
+
+	if ((change_port || change_irq) && (state->count > 1))
+		return -EBUSY;
+
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
+
+	state->baud_base = new_serial.baud_base;
+	state->flags = ((state->flags & ~ASYNC_FLAGS) |
+			(new_serial.flags & ASYNC_FLAGS));
+	info->flags = ((state->flags & ~ASYNC_INTERNAL_FLAGS) |
+		       (info->flags & ASYNC_INTERNAL_FLAGS));
+	state->custom_divisor = new_serial.custom_divisor;
+	state->close_delay = new_serial.close_delay * HZ/100;
+	state->closing_wait = new_serial.closing_wait * HZ/100;
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	info->xmit_fifo_size = state->xmit_fifo_size =
+		new_serial.xmit_fifo_size;
+
+	if ((state->type != PORT_UNKNOWN) && state->port) {
+		release_region(state->port,8);
+	}
+	state->type = new_serial.type;
+	if (change_port || change_irq) {
+		/*
+		 * We need to shutdown the serial port at the old
+		 * port/irq combination.
+		 */
+		shutdown(info);
+		state->irq = new_serial.irq;
+		info->port = state->port = new_port;
+		info->hub6 = state->hub6 = new_serial.hub6;
+		if (info->hub6)
+			info->io_type = state->io_type = SERIAL_IO_HUB6;
+		else if (info->io_type == SERIAL_IO_HUB6)
+			info->io_type = state->io_type = SERIAL_IO_PORT;
+	}
+	if ((state->type != PORT_UNKNOWN) && state->port) {
+			request_region(state->port,8,"serial(set)");
+	}
+
+	
+check_and_exit:
+	if (!state->port || !state->type)
+		return 0;
+	if (info->flags & ASYNC_INITIALIZED) {
+		if (((old_state.flags & ASYNC_SPD_MASK) !=
+		     (state->flags & ASYNC_SPD_MASK)) ||
+		    (old_state.custom_divisor != state->custom_divisor)) {
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+				info->tty->alt_speed = 57600;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+				info->tty->alt_speed = 115200;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+				info->tty->alt_speed = 230400;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+				info->tty->alt_speed = 460800;
+			change_speed(info, 0);
+		}
+	} else {
+		retval = startup(info);
+	}
+	return retval;
+}
+
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ * 	    is emptied.  On bus types like RS485, the transmitter must
+ * 	    release the bus after transmitting. This must be done when
+ * 	    the transmit shift register is empty, not be done when the
+ * 	    transmit holding register is empty.  This functionality
+ * 	    allows an RS485 driver to be written in user space. 
+ */
+static int get_lsr_info(struct async_struct * info, unsigned int *value)
+{
+	unsigned char status;
+	unsigned int result;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	status = serial_in(info, UART_LSR);
+	restore_flags(flags);
+	result = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);
+
+	/*
+	 * If we're about to load something into the transmit
+	 * register, we'll pretend the transmitter isn't empty to
+	 * avoid a race condition (depending on when the transmit
+	 * interrupt happens).
+	 */
+	if (info->x_char || 
+	    ((CIRC_CNT(info->xmit.head, info->xmit.tail,
+		       SERIAL_XMIT_SIZE) > 0) &&
+	     !info->tty->stopped && !info->tty->hw_stopped))
+		result &= TIOCSER_TEMT;
+
+	if (copy_to_user(value, &result, sizeof(int)))
+		return -EFAULT;
+	return 0;
+}
+
+
+static int get_modem_info(struct async_struct * info, unsigned int *value)
+{
+	unsigned char control, status;
+	unsigned int result;
+	unsigned long flags;
+
+	control = info->MCR;
+	save_flags(flags); cli();
+	status = serial_in(info, UART_MSR);
+	restore_flags(flags);
+	result =  ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)
+		| ((control & UART_MCR_DTR) ? TIOCM_DTR : 0)
+#ifdef TIOCM_OUT1
+		| ((control & UART_MCR_OUT1) ? TIOCM_OUT1 : 0)
+		| ((control & UART_MCR_OUT2) ? TIOCM_OUT2 : 0)
+#endif
+		| ((status  & UART_MSR_DCD) ? TIOCM_CAR : 0)
+		| ((status  & UART_MSR_RI) ? TIOCM_RNG : 0)
+		| ((status  & UART_MSR_DSR) ? TIOCM_DSR : 0)
+		| ((status  & UART_MSR_CTS) ? TIOCM_CTS : 0);
+
+	if (copy_to_user(value, &result, sizeof(int)))
+		return -EFAULT;
+	return 0;
+}
+
+static int set_modem_info(struct async_struct * info, unsigned int cmd,
+			  unsigned int *value)
+{
+	unsigned int arg;
+	unsigned long flags;
+
+	if (copy_from_user(&arg, value, sizeof(int)))
+		return -EFAULT;
+
+	switch (cmd) {
+	case TIOCMBIS: 
+		if (arg & TIOCM_RTS)
+			info->MCR |= UART_MCR_RTS;
+		if (arg & TIOCM_DTR)
+			info->MCR |= UART_MCR_DTR;
+#ifdef TIOCM_OUT1
+		if (arg & TIOCM_OUT1)
+			info->MCR |= UART_MCR_OUT1;
+		if (arg & TIOCM_OUT2)
+			info->MCR |= UART_MCR_OUT2;
+#endif
+		if (arg & TIOCM_LOOP)
+			info->MCR |= UART_MCR_LOOP;
+		break;
+	case TIOCMBIC:
+		if (arg & TIOCM_RTS)
+			info->MCR &= ~UART_MCR_RTS;
+		if (arg & TIOCM_DTR)
+			info->MCR &= ~UART_MCR_DTR;
+#ifdef TIOCM_OUT1
+		if (arg & TIOCM_OUT1)
+			info->MCR &= ~UART_MCR_OUT1;
+		if (arg & TIOCM_OUT2)
+			info->MCR &= ~UART_MCR_OUT2;
+#endif
+		if (arg & TIOCM_LOOP)
+			info->MCR &= ~UART_MCR_LOOP;
+		break;
+	case TIOCMSET:
+		info->MCR = ((info->MCR & ~(UART_MCR_RTS |
+#ifdef TIOCM_OUT1
+					    UART_MCR_OUT1 |
+					    UART_MCR_OUT2 |
+#endif
+					    UART_MCR_LOOP |
+					    UART_MCR_DTR))
+			     | ((arg & TIOCM_RTS) ? UART_MCR_RTS : 0)
+#ifdef TIOCM_OUT1
+			     | ((arg & TIOCM_OUT1) ? UART_MCR_OUT1 : 0)
+			     | ((arg & TIOCM_OUT2) ? UART_MCR_OUT2 : 0)
+#endif
+			     | ((arg & TIOCM_LOOP) ? UART_MCR_LOOP : 0)
+			     | ((arg & TIOCM_DTR) ? UART_MCR_DTR : 0));
+		break;
+	default:
+		return -EINVAL;
+	}
+	save_flags(flags); cli();
+	info->MCR |= ALPHA_KLUDGE_MCR; 		/* Don't ask */
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+	return 0;
+}
+
+static int do_autoconfig(struct async_struct * info)
+{
+	int retval;
+	
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	
+	if (info->state->count > 1)
+		return -EBUSY;
+	
+	shutdown(info);
+
+	autoconfig(info->state);
+	retval = startup(info);
+	if (retval)
+		return retval;
+	return 0;
+}
+
+/*
+ * rs_break() --- routine which turns the break handling on or off
+ */
+static void rs_break(struct tty_struct *tty, int break_state)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	if (serial_paranoia_check(info, tty->device, "rs_break"))
+		return;
+
+	if (!CONFIGURED_SERIAL_PORT(info))
+		return;
+	save_flags(flags); cli();
+	if (break_state == -1)
+		info->LCR |= UART_LCR_SBC;
+	else
+		info->LCR &= ~UART_LCR_SBC;
+	serial_out(info, UART_LCR, info->LCR);
+	restore_flags(flags);
+}
+
+
+static int rs_ioctl(struct tty_struct *tty, struct file * file,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct async_icount cprev, cnow;	/* kernel counter temps */
+	struct serial_icounter_struct icount;
+	unsigned long flags;
+	
+	if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
+		return -ENODEV;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+	    (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
+	    (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+		    return -EIO;
+	}
+	
+	switch (cmd) {
+		case TIOCMGET:
+			return get_modem_info(info, (unsigned int *) arg);
+		case TIOCMBIS:
+		case TIOCMBIC:
+		case TIOCMSET:
+			return set_modem_info(info, cmd, (unsigned int *) arg);
+		case TIOCGSERIAL:
+			return get_serial_info(info,
+					       (struct serial_struct *) arg);
+		case TIOCSSERIAL:
+			return set_serial_info(info,
+					       (struct serial_struct *) arg);
+		case TIOCSERCONFIG:
+			return do_autoconfig(info);
+
+		case TIOCSERGETLSR: /* Get line status register */
+			return get_lsr_info(info, (unsigned int *) arg);
+
+		case TIOCSERGSTRUCT:
+			if (copy_to_user((struct async_struct *) arg,
+					 info, sizeof(struct async_struct)))
+				return -EFAULT;
+			return 0;
+				
+			
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+ 		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
+		case TIOCMIWAIT:
+			save_flags(flags); cli();
+			/* note the counters on entry */
+			cprev = info->state->icount;
+			restore_flags(flags);
+			/* Force modem status interrupts on */
+			info->IER |= UART_IER_MSI;
+			serial_out(info, UART_IER, info->IER);
+			while (1) {
+				interruptible_sleep_on(&info->delta_msr_wait);
+				/* see if a signal did it */
+				if (signal_pending(current))
+					return -ERESTARTSYS;
+				save_flags(flags); cli();
+				cnow = info->state->icount; /* atomic copy */
+				restore_flags(flags);
+				if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr && 
+				    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
+					return -EIO; /* no change => error */
+				if ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+				     ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+				     ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+				     ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
+					return 0;
+				}
+				cprev = cnow;
+			}
+			/* NOTREACHED */
+
+		/* 
+		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+		 * Return: write counters to the user passed counter struct
+		 * NB: both 1->0 and 0->1 transitions are counted except for
+		 *     RI where only 0->1 is counted.
+		 */
+		case TIOCGICOUNT:
+			save_flags(flags); cli();
+			cnow = info->state->icount;
+			restore_flags(flags);
+			icount.cts = cnow.cts;
+			icount.dsr = cnow.dsr;
+			icount.rng = cnow.rng;
+			icount.dcd = cnow.dcd;
+			icount.rx = cnow.rx;
+			icount.tx = cnow.tx;
+			icount.frame = cnow.frame;
+			icount.overrun = cnow.overrun;
+			icount.parity = cnow.parity;
+			icount.brk = cnow.brk;
+			icount.buf_overrun = cnow.buf_overrun;
+			
+			if (copy_to_user((void *)arg, &icount, sizeof(icount)))
+				return -EFAULT;
+			return 0;
+		case TIOCSERGWILD:
+		case TIOCSERSWILD:
+			/* "setserial -W" is called in Debian boot */
+			printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
+			return 0;
+
+		default:
+			return -ENOIOCTLCMD;
+		}
+	return 0;
+}
+
+static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	unsigned int cflag = tty->termios->c_cflag;
+	
+	if (   (cflag == old_termios->c_cflag)
+	    && (   RELEVANT_IFLAG(tty->termios->c_iflag) 
+		== RELEVANT_IFLAG(old_termios->c_iflag)))
+	  return;
+
+	change_speed(info, old_termios);
+
+	/* Handle transition to B0 status */
+	if ((old_termios->c_cflag & CBAUD) &&
+	    !(cflag & CBAUD)) {
+		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
+		save_flags(flags); cli();
+		serial_out(info, UART_MCR, info->MCR);
+		restore_flags(flags);
+	}
+	
+	/* Handle transition away from B0 status */
+	if (!(old_termios->c_cflag & CBAUD) &&
+	    (cflag & CBAUD)) {
+		info->MCR |= UART_MCR_DTR;
+		if (!(tty->termios->c_cflag & CRTSCTS) || 
+		    !test_bit(TTY_THROTTLED, &tty->flags)) {
+			info->MCR |= UART_MCR_RTS;
+		}
+		save_flags(flags); cli();
+		serial_out(info, UART_MCR, info->MCR);
+		restore_flags(flags);
+	}
+	
+	/* Handle turning off CRTSCTS */
+	if ((old_termios->c_cflag & CRTSCTS) &&
+	    !(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		rs_start(tty);
+	}
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_close()
+ * 
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we unlink its
+ * async structure from the interrupt chain if necessary, and we free
+ * that IRQ if nothing is left in the chain.
+ * ------------------------------------------------------------
+ */
+static void rs_close(struct tty_struct *tty, struct file * filp)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state;
+	unsigned long flags;
+
+	if (!info || serial_paranoia_check(info, tty->device, "rs_close"))
+		return;
+
+	state = info->state;
+	
+	save_flags(flags); cli();
+	
+	if (tty_hung_up_p(filp)) {
+		DBG_CNT("before DEC-hung");
+		MOD_DEC_USE_COUNT;
+		restore_flags(flags);
+		return;
+	}
+	
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_close ttys%d, count = %d\n", info->line, state->count);
+#endif
+	if ((tty->count == 1) && (state->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  state->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("rs_close: bad serial port count; tty->count is 1, "
+		       "state->count is %d\n", state->count);
+		state->count = 1;
+	}
+	if (--state->count < 0) {
+		printk("rs_close: bad serial port count for ttys%d: %d\n",
+		       info->line, state->count);
+		state->count = 0;
+	}
+	if (state->count) {
+		DBG_CNT("before DEC-2");
+		MOD_DEC_USE_COUNT;
+		restore_flags(flags);
+		return;
+	}
+	info->flags |= ASYNC_CLOSING;
+	restore_flags(flags);
+	/*
+	 * Save the termios structure, since this port may have
+	 * separate termios for callout and dialin.
+	 */
+	if (info->flags & ASYNC_NORMAL_ACTIVE)
+		info->state->normal_termios = *tty->termios;
+	if (info->flags & ASYNC_CALLOUT_ACTIVE)
+		info->state->callout_termios = *tty->termios;
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify 
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
+	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->closing_wait);
+	/*
+	 * At this point we stop accepting input.  To do this, we
+	 * disable the receive line status interrupts, and tell the
+	 * interrupt driver to stop checking the data ready bit in the
+	 * line status register.
+	 */
+	info->IER &= ~UART_IER_RLSI;
+	info->read_status_mask &= ~UART_LSR_DR;
+	if (info->flags & ASYNC_INITIALIZED) {
+		serial_out(info, UART_IER, info->IER);
+		/*
+		 * Before we drop DTR, make sure the UART transmitter
+		 * has completely drained; this is especially
+		 * important if there is a transmit FIFO!
+		 */
+		rs_wait_until_sent(tty, info->timeout);
+	}
+	shutdown(info);
+	if (tty->driver.flush_buffer)
+		tty->driver.flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = 0;
+	if (info->blocked_open) {
+		if (info->close_delay) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(info->close_delay);
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE|
+			 ASYNC_CLOSING);
+	wake_up_interruptible(&info->close_wait);
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * rs_wait_until_sent() --- wait until the transmitter is empty
+ */
+static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	unsigned long orig_jiffies, char_time;
+	int lsr;
+	
+	if (serial_paranoia_check(info, tty->device, "rs_wait_until_sent"))
+		return;
+
+	if (info->state->type == PORT_UNKNOWN)
+		return;
+
+	if (info->xmit_fifo_size == 0)
+		return; /* Just in case.... */
+
+	orig_jiffies = jiffies;
+	/*
+	 * Set the check interval to be 1/5 of the estimated time to
+	 * send a single character, and make it at least 1.  The check
+	 * interval should also be less than the timeout.
+	 * 
+	 * Note: we have to use pretty tight timings here to satisfy
+	 * the NIST-PCTS.
+	 */
+	char_time = (info->timeout - HZ/50) / info->xmit_fifo_size;
+	char_time = char_time / 5;
+	if (char_time == 0)
+		char_time = 1;
+	if (timeout && timeout < char_time)
+		char_time = timeout;
+	/*
+	 * If the transmitter hasn't cleared in twice the approximate
+	 * amount of time to send the entire FIFO, it probably won't
+	 * ever clear.  This assumes the UART isn't doing flow
+	 * control, which is currently the case.  Hence, if it ever
+	 * takes longer than info->timeout, this is probably due to a
+	 * UART bug of some kind.  So, we clamp the timeout parameter at
+	 * 2*info->timeout.
+	 */
+	if (!timeout || timeout > 2*info->timeout)
+		timeout = 2*info->timeout;
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);
+	printk("jiff=%lu...", jiffies);
+#endif
+	while (!((lsr = serial_inp(info, UART_LSR)) & UART_LSR_TEMT)) {
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+		printk("lsr = %d (jiff=%lu)...", lsr, jiffies);
+#endif
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(char_time);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+	set_current_state(TASK_RUNNING);
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
+#endif
+}
+
+/*
+ * rs_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void rs_hangup(struct tty_struct *tty)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state = info->state;
+	
+	if (serial_paranoia_check(info, tty->device, "rs_hangup"))
+		return;
+
+	state = info->state;
+	
+	rs_flush_buffer(tty);
+	if (info->flags & ASYNC_CLOSING)
+		return;
+	shutdown(info);
+	info->event = 0;
+	state->count = 0;
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE);
+	info->tty = 0;
+	wake_up_interruptible(&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready(struct tty_struct *tty, struct file * filp,
+			   struct async_struct *info)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	struct serial_state *state = info->state;
+	int		retval;
+	int		do_clocal = 0, extra_count = 0;
+	unsigned long	flags;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (tty_hung_up_p(filp) ||
+	    (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+#ifdef SERIAL_DO_RESTART
+		return ((info->flags & ASYNC_HUP_NOTIFY) ?
+			-EAGAIN : -ERESTARTSYS);
+#else
+		return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * If this is a callout device, then just make sure the normal
+	 * device isn't being used.
+	 */
+	if (tty->driver.subtype == SERIAL_TYPE_CALLOUT) {
+		if (info->flags & ASYNC_NORMAL_ACTIVE)
+			return -EBUSY;
+		if ((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    (info->flags & ASYNC_SESSION_LOCKOUT) &&
+		    (info->session != current->session))
+		    return -EBUSY;
+		if ((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    (info->flags & ASYNC_PGRP_LOCKOUT) &&
+		    (info->pgrp != current->pgrp))
+		    return -EBUSY;
+		info->flags |= ASYNC_CALLOUT_ACTIVE;
+		return 0;
+	}
+	
+	/*
+	 * If non-blocking mode is set, or the port is not enabled,
+	 * then make the check up front and then exit.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) ||
+	    (tty->flags & (1 << TTY_IO_ERROR))) {
+		if (info->flags & ASYNC_CALLOUT_ACTIVE)
+			return -EBUSY;
+		info->flags |= ASYNC_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	if (info->flags & ASYNC_CALLOUT_ACTIVE) {
+		if (state->normal_termios.c_cflag & CLOCAL)
+			do_clocal = 1;
+	} else {
+		if (tty->termios->c_cflag & CLOCAL)
+			do_clocal = 1;
+	}
+	
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, state->count is dropped by one, so that
+	 * rs_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready before block: ttys%d, count = %d\n",
+	       state->line, state->count);
+#endif
+	save_flags(flags); cli();
+	if (!tty_hung_up_p(filp)) {
+		extra_count = 1;
+		state->count--;
+	}
+	restore_flags(flags);
+	info->blocked_open++;
+	while (1) {
+		save_flags(flags); cli();
+		if (!(info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    (tty->termios->c_cflag & CBAUD))
+			serial_out(info, UART_MCR,
+				   serial_inp(info, UART_MCR) |
+				   (UART_MCR_DTR | UART_MCR_RTS));
+		restore_flags(flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (tty_hung_up_p(filp) ||
+		    !(info->flags & ASYNC_INITIALIZED)) {
+#ifdef SERIAL_DO_RESTART
+			if (info->flags & ASYNC_HUP_NOTIFY)
+				retval = -EAGAIN;
+			else
+				retval = -ERESTARTSYS;	
+#else
+			retval = -EAGAIN;
+#endif
+			break;
+		}
+		if (!(info->flags & ASYNC_CALLOUT_ACTIVE) &&
+		    !(info->flags & ASYNC_CLOSING) &&
+		    (do_clocal || (serial_in(info, UART_MSR) &
+				   UART_MSR_DCD)))
+			break;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+#ifdef SERIAL_DEBUG_OPEN
+		printk("block_til_ready blocking: ttys%d, count = %d\n",
+		       info->line, state->count);
+#endif
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&info->open_wait, &wait);
+	if (extra_count)
+		state->count++;
+	info->blocked_open--;
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready after blocking: ttys%d, count = %d\n",
+	       info->line, state->count);
+#endif
+	if (retval)
+		return retval;
+	info->flags |= ASYNC_NORMAL_ACTIVE;
+	return 0;
+}
+
+static int get_async_struct(int line, struct async_struct **ret_info)
+{
+	struct async_struct *info;
+	struct serial_state *sstate;
+
+	sstate = rs_table + line;
+	sstate->count++;
+	if (sstate->info) {
+		*ret_info = sstate->info;
+		return 0;
+	}
+	info = kmalloc(sizeof(struct async_struct), GFP_KERNEL);
+	if (!info) {
+		sstate->count--;
+		return -ENOMEM;
+	}
+	memset(info, 0, sizeof(struct async_struct));
+	init_waitqueue_head(&info->open_wait);
+	init_waitqueue_head(&info->close_wait);
+	init_waitqueue_head(&info->delta_msr_wait);
+	info->magic = SERIAL_MAGIC;
+	info->port = sstate->port;
+	info->flags = sstate->flags;
+	info->io_type = sstate->io_type;
+	info->iomem_base = sstate->iomem_base;
+	info->iomem_reg_shift = sstate->iomem_reg_shift;
+	info->xmit_fifo_size = sstate->xmit_fifo_size;
+	info->line = line;
+	info->tqueue.routine = do_softint;
+	info->tqueue.data = info;
+	info->state = sstate;
+	if (sstate->info) {
+		kfree(info);
+		*ret_info = sstate->info;
+		return 0;
+	}
+	*ret_info = sstate->info = info;
+	return 0;
+}
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port, linking in its async structure into
+ * the IRQ chain.   It also performs the serial-specific
+ * initialization for the tty structure.
+ */
+static int rs_open(struct tty_struct *tty, struct file * filp)
+{
+	struct async_struct	*info;
+	int 			retval, line;
+	unsigned long		page;
+
+	MOD_INC_USE_COUNT;
+	line = MINOR(tty->device) - tty->driver.minor_start;
+	if ((line < 0) || (line >= NR_PORTS)) {
+		MOD_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+	retval = get_async_struct(line, &info);
+	if (retval) {
+		MOD_DEC_USE_COUNT;
+		return retval;
+	}
+	tty->driver_data = info;
+	info->tty = tty;
+	if (serial_paranoia_check(info, tty->device, "rs_open")) {
+		MOD_DEC_USE_COUNT;		
+		return -ENODEV;
+	}
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_open %s%d, count = %d\n", tty->driver.name, info->line,
+	       info->state->count);
+#endif
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+
+	if (!tmp_buf) {
+		page = get_zeroed_page(GFP_KERNEL);
+		if (!page) {
+			MOD_DEC_USE_COUNT;
+			return -ENOMEM;
+		}
+		if (tmp_buf)
+			free_page(page);
+		else
+			tmp_buf = (unsigned char *) page;
+	}
+
+	/*
+	 * If the port is the middle of closing, bail out now
+	 */
+	if (tty_hung_up_p(filp) ||
+	    (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+		MOD_DEC_USE_COUNT;
+#ifdef SERIAL_DO_RESTART
+		return ((info->flags & ASYNC_HUP_NOTIFY) ?
+			-EAGAIN : -ERESTARTSYS);
+#else
+		return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * Start up serial port
+	 */
+	retval = startup(info);
+	if (retval) {
+		MOD_DEC_USE_COUNT;
+		return retval;
+	}
+
+	retval = block_til_ready(tty, filp, info);
+	if (retval) {
+#ifdef SERIAL_DEBUG_OPEN
+		printk("rs_open returning after block_til_ready with %d\n",
+		       retval);
+#endif
+		MOD_DEC_USE_COUNT;
+		return retval;
+	}
+
+	if ((info->state->count == 1) &&
+	    (info->flags & ASYNC_SPLIT_TERMIOS)) {
+		if (tty->driver.subtype == SERIAL_TYPE_NORMAL)
+			*tty->termios = info->state->normal_termios;
+		else 
+			*tty->termios = info->state->callout_termios;
+		change_speed(info, 0);
+	}
+#ifdef CONFIG_AU1000_SERIAL_CONSOLE
+	if (sercons.cflag && sercons.index == line) {
+		tty->termios->c_cflag = sercons.cflag;
+		sercons.cflag = 0;
+		change_speed(info, 0);
+	}
+#endif
+	info->session = current->session;
+	info->pgrp = current->pgrp;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("rs_open ttys%d successful...", info->line);
+#endif
+	return 0;
+}
+
+/*
+ * /proc fs routines....
+ */
+
+static inline int line_info(char *buf, struct serial_state *state)
+{
+	struct async_struct *info = state->info, scr_info;
+	char	stat_buf[30], control, status;
+	int	ret;
+	unsigned long flags;
+
+	ret = sprintf(buf, "%d: uart:%s port:%lX irq:%d",
+		      state->line, uart_config[state->type].name, 
+		      state->port, state->irq);
+
+	if (!state->port || (state->type == PORT_UNKNOWN)) {
+		ret += sprintf(buf+ret, "\n");
+		return ret;
+	}
+
+	/*
+	 * Figure out the current RS-232 lines
+	 */
+	if (!info) {
+		info = &scr_info;	/* This is just for serial_{in,out} */
+
+		info->magic = SERIAL_MAGIC;
+		info->port = state->port;
+		info->flags = state->flags;
+		info->quot = 0;
+		info->tty = 0;
+	}
+	save_flags(flags); cli();
+	status = serial_in(info, UART_MSR);
+	control = info != &scr_info ? info->MCR : serial_in(info, UART_MCR);
+	restore_flags(flags); 
+
+	stat_buf[0] = 0;
+	stat_buf[1] = 0;
+	if (control & UART_MCR_RTS)
+		strcat(stat_buf, "|RTS");
+	if (status & UART_MSR_CTS)
+		strcat(stat_buf, "|CTS");
+	if (control & UART_MCR_DTR)
+		strcat(stat_buf, "|DTR");
+	if (status & UART_MSR_DSR)
+		strcat(stat_buf, "|DSR");
+	if (status & UART_MSR_DCD)
+		strcat(stat_buf, "|CD");
+	if (status & UART_MSR_RI)
+		strcat(stat_buf, "|RI");
+
+	if (info->quot) {
+		ret += sprintf(buf+ret, " baud:%d",
+			       state->baud_base / info->quot);
+	}
+
+	ret += sprintf(buf+ret, " tx:%d rx:%d",
+		      state->icount.tx, state->icount.rx);
+
+	if (state->icount.frame)
+		ret += sprintf(buf+ret, " fe:%d", state->icount.frame);
+	
+	if (state->icount.parity)
+		ret += sprintf(buf+ret, " pe:%d", state->icount.parity);
+	
+	if (state->icount.brk)
+		ret += sprintf(buf+ret, " brk:%d", state->icount.brk);	
+
+	if (state->icount.overrun)
+		ret += sprintf(buf+ret, " oe:%d", state->icount.overrun);
+
+	/*
+	 * Last thing is the RS-232 status lines
+	 */
+	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	return ret;
+}
+
+int rs_read_proc(char *page, char **start, off_t off, int count,
+		 int *eof, void *data)
+{
+	int i, len = 0, l;
+	off_t	begin = 0;
+
+	len += sprintf(page, "serinfo:1.0 driver:%s%s revision:%s\n",
+		       serial_version, LOCAL_VERSTRING, serial_revdate);
+	for (i = 0; i < NR_PORTS && len < 4000; i++) {
+		l = line_info(page + len, &rs_table[i]);
+		len += l;
+		if (len+begin > off+count)
+			goto done;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= len+begin)
+		return 0;
+	*start = page + (off-begin);
+	return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+/*
+ * ---------------------------------------------------------------------
+ * rs_init() and friends
+ *
+ * rs_init() is called at boot-time to initialize the serial driver.
+ * ---------------------------------------------------------------------
+ */
+
+/*
+ * This routine prints out the appropriate serial driver version
+ * number, and identifies which options were configured into this
+ * driver.
+ */
+static char serial_options[] __initdata =
+       " no serial options enabled\n";
+#undef SERIAL_OPT
+
+static _INLINE_ void show_serial_version(void)
+{
+ 	printk(KERN_INFO "%s version %s%s (%s) with%s", serial_name,
+	       serial_version, LOCAL_VERSTRING, serial_revdate,
+	       serial_options);
+}
+
+
+/*
+ * This routine is called by rs_init() to initialize a specific serial
+ * port.  It determines what type of UART chip this serial port is
+ * using: 8250, 16450, 16550, 16550A.  The important question is
+ * whether or not this UART is a 16550A or not, since this will
+ * determine whether or not we can use its FIFO features or not.
+ */
+static void autoconfig(struct serial_state * state)
+{
+	struct async_struct *info, scr_info;
+	unsigned long flags;
+
+
+#ifdef SERIAL_DEBUG_AUTOCONF
+	printk("Testing ttyS%d (0x%04lx, 0x%04x)...\n", state->line,
+	       state->port, (unsigned) state->iomem_base);
+#endif
+	
+	if (!CONFIGURED_SERIAL_PORT(state))
+		return;
+
+	if (inl(UART_MOD_CNTRL + state->port) != 0x3) {
+		outl(3, UART_MOD_CNTRL + state->port);
+		au_sync_delay(10);
+	}
+		
+	state->type = PORT_16550;
+	info = &scr_info;	/* This is just for serial_{in,out} */
+
+	info->magic = SERIAL_MAGIC;
+	info->state = state;
+	info->port = state->port;
+	info->flags = state->flags;
+	info->io_type = state->io_type;
+	info->iomem_base = state->iomem_base;
+	info->iomem_reg_shift = state->iomem_reg_shift;
+
+
+	save_flags(flags); cli();
+	state->xmit_fifo_size =	uart_config[state->type].dfl_xmit_fifo_size;
+
+	if (info->port) {
+			request_region(info->port,8,"serial(auto)");
+	}
+
+	/*
+	 * Reset the UART.
+	 */
+	serial_outp(info, UART_FCR, (UART_FCR_ENABLE_FIFO |
+				     UART_FCR_CLEAR_RCVR |
+				     UART_FCR_CLEAR_XMIT));
+	serial_outp(info, UART_FCR, 0);
+	(void)serial_in(info, UART_RX);
+	serial_outp(info, UART_IER, 0);
+
+#ifndef CONFIG_REMOTE_DEBUG
+	outl(0, UART_MOD_CNTRL + state->port);
+	au_sync_delay(10);
+#endif
+	restore_flags(flags);
+}
+
+int register_serial(struct serial_struct *req);
+void unregister_serial(int line);
+
+EXPORT_SYMBOL(register_serial);
+EXPORT_SYMBOL(unregister_serial);
+
+
+/*
+ * The serial driver boot-time initialization code!
+ */
+static int __init rs_init(void)
+{
+	int i;
+	struct serial_state * state;
+
+	init_bh(SERIAL_BH, do_serial_bh);
+	init_timer(&serial_timer);
+	serial_timer.function = rs_timer;
+	mod_timer(&serial_timer, jiffies + RS_STROBE_TIME);
+
+	for (i = 0; i < NR_IRQS; i++) {
+		IRQ_ports[i] = 0;
+		IRQ_timeout[i] = 0;
+	}
+#ifdef CONFIG_AU1000_SERIAL_CONSOLE
+	/*
+	 *	The interrupt of the serial console port
+	 *	can't be shared.
+	 */
+	if (sercons.flags & CON_CONSDEV) {
+		for(i = 0; i < NR_PORTS; i++)
+			if (i != sercons.index &&
+			    rs_table[i].irq == rs_table[sercons.index].irq)
+				rs_table[i].irq = 0;
+	}
+#endif
+	show_serial_version();
+
+	/* Initialize the tty_driver structure */
+	
+	memset(&serial_driver, 0, sizeof(struct tty_driver));
+	serial_driver.magic = TTY_DRIVER_MAGIC;
+	serial_driver.driver_name = "serial";
+#if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
+	serial_driver.name = "tts/%d";
+#else
+	serial_driver.name = "ttyS";
+#endif
+	serial_driver.major = TTY_MAJOR;
+	serial_driver.minor_start = 64 + SERIAL_DEV_OFFSET;
+	serial_driver.num = NR_PORTS;
+	serial_driver.type = TTY_DRIVER_TYPE_SERIAL;
+	serial_driver.subtype = SERIAL_TYPE_NORMAL;
+	serial_driver.init_termios = tty_std_termios;
+	serial_driver.init_termios.c_cflag =
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	serial_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	serial_driver.refcount = &serial_refcount;
+	serial_driver.table = serial_table;
+	serial_driver.termios = serial_termios;
+	serial_driver.termios_locked = serial_termios_locked;
+
+	serial_driver.open = rs_open;
+	serial_driver.close = rs_close;
+	serial_driver.write = rs_write;
+	serial_driver.put_char = rs_put_char;
+	serial_driver.flush_chars = rs_flush_chars;
+	serial_driver.write_room = rs_write_room;
+	serial_driver.chars_in_buffer = rs_chars_in_buffer;
+	serial_driver.flush_buffer = rs_flush_buffer;
+	serial_driver.ioctl = rs_ioctl;
+	serial_driver.throttle = rs_throttle;
+	serial_driver.unthrottle = rs_unthrottle;
+	serial_driver.set_termios = rs_set_termios;
+	serial_driver.stop = rs_stop;
+	serial_driver.start = rs_start;
+	serial_driver.hangup = rs_hangup;
+	serial_driver.break_ctl = rs_break;
+	serial_driver.send_xchar = rs_send_xchar;
+	serial_driver.wait_until_sent = rs_wait_until_sent;
+	serial_driver.read_proc = rs_read_proc;
+	
+	/*
+	 * The callout device is just like normal device except for
+	 * major number and the subtype code.
+	 */
+	callout_driver = serial_driver;
+#if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
+	callout_driver.name = "cua/%d";
+#else
+	callout_driver.name = "cua";
+#endif
+	callout_driver.major = TTYAUX_MAJOR;
+	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
+	callout_driver.read_proc = 0;
+	callout_driver.proc_entry = 0;
+
+	if (tty_register_driver(&serial_driver))
+		panic("Couldn't register serial driver");
+	if (tty_register_driver(&callout_driver))
+		panic("Couldn't register callout driver");
+	
+	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
+		state->baud_base = get_au1000_uart_baud_base();
+		state->magic = SSTATE_MAGIC;
+		state->line = i;
+		state->type = PORT_UNKNOWN;
+		state->custom_divisor = 0;
+		state->close_delay = 5*HZ/10;
+		state->closing_wait = 30*HZ;
+		state->callout_termios = callout_driver.init_termios;
+		state->normal_termios = serial_driver.init_termios;
+		state->icount.cts = state->icount.dsr = 
+			state->icount.rng = state->icount.dcd = 0;
+		state->icount.rx = state->icount.tx = 0;
+		state->icount.frame = state->icount.parity = 0;
+		state->icount.overrun = state->icount.brk = 0;
+		state->irq = irq_cannonicalize(state->irq);
+		if (state->hub6)
+			state->io_type = SERIAL_IO_HUB6;
+		if (state->port && check_region(state->port,8)) {
+			continue;
+		}
+
+		if (state->flags & ASYNC_BOOT_AUTOCONF) {
+			autoconfig(state);
+		}
+	}
+	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
+		if (state->type == PORT_UNKNOWN) {
+			continue;
+		}
+		printk(KERN_INFO "ttyS%02d%s at 0x%04lx (irq = %d) is a %s\n",
+		       state->line + SERIAL_DEV_OFFSET,
+		       (state->flags & ASYNC_FOURPORT) ? " FourPort" : "",
+		       state->port, state->irq,
+		       uart_config[state->type].name);
+		tty_register_devfs(&serial_driver, 0,
+				   serial_driver.minor_start + state->line);
+		tty_register_devfs(&callout_driver, 0,
+				   callout_driver.minor_start + state->line);
+	}
+	return 0;
+}
+
+/*
+ * register_serial and unregister_serial allows for 16x50 serial ports to be
+ * configured at run-time, to support PCMCIA modems.
+ */
+ 
+/**
+ *	register_serial - configure a 16x50 serial port at runtime
+ *	@req: request structure
+ *
+ *	Configure the serial port specified by the request. If the
+ *	port exists and is in use an error is returned. If the port
+ *	is not currently in the table it is added.
+ *
+ *	The port is then probed and if neccessary the IRQ is autodetected
+ *	If this fails an error is returned.
+ *
+ *	On success the port is ready to use and the line number is returned.
+ */
+ 
+int register_serial(struct serial_struct *req)
+{
+	int i;
+	unsigned long flags;
+	struct serial_state *state;
+	struct async_struct *info;
+	unsigned long port;
+
+	port = req->port;
+	if (HIGH_BITS_OFFSET)
+		port += (unsigned long) req->port_high << HIGH_BITS_OFFSET;
+
+	save_flags(flags); cli();
+	for (i = 0; i < NR_PORTS; i++) {
+		if ((rs_table[i].port == port) &&
+		    (rs_table[i].iomem_base == req->iomem_base))
+			break;
+	}
+	if (i == NR_PORTS) {
+		for (i = 0; i < NR_PORTS; i++)
+			if ((rs_table[i].type == PORT_UNKNOWN) &&
+			    (rs_table[i].count == 0))
+				break;
+	}
+	if (i == NR_PORTS) {
+		restore_flags(flags);
+		return -1;
+	}
+	state = &rs_table[i];
+	if (rs_table[i].count) {
+		restore_flags(flags);
+		printk("Couldn't configure serial #%d (port=%ld,irq=%d): "
+		       "device already open\n", i, port, req->irq);
+		return -1;
+	}
+	state->irq = req->irq;
+	state->port = port;
+	state->flags = req->flags;
+	state->io_type = req->io_type;
+	state->iomem_base = req->iomem_base;
+	state->iomem_reg_shift = req->iomem_reg_shift;
+	if (req->baud_base)
+		state->baud_base = req->baud_base;
+	if ((info = state->info) != NULL) {
+		info->port = port;
+		info->flags = req->flags;
+		info->io_type = req->io_type;
+		info->iomem_base = req->iomem_base;
+		info->iomem_reg_shift = req->iomem_reg_shift;
+	}
+	autoconfig(state);
+	if (state->type == PORT_UNKNOWN) {
+		restore_flags(flags);
+		printk("register_serial(): autoconfig failed\n");
+		return -1;
+	}
+	restore_flags(flags);
+
+       printk(KERN_INFO "ttyS%02d at %s 0x%04lx (irq = %d) is a %s\n",
+	      state->line + SERIAL_DEV_OFFSET,
+	      state->iomem_base ? "iomem" : "port",
+	      state->iomem_base ? (unsigned long)state->iomem_base :
+	      state->port, state->irq, uart_config[state->type].name);
+	tty_register_devfs(&serial_driver, 0,
+			   serial_driver.minor_start + state->line); 
+	tty_register_devfs(&callout_driver, 0,
+			   callout_driver.minor_start + state->line);
+	return state->line + SERIAL_DEV_OFFSET;
+}
+
+/**
+ *	unregister_serial - deconfigure a 16x50 serial port
+ *	@line: line to deconfigure
+ *
+ *	The port specified is deconfigured and its resources are freed. Any
+ *	user of the port is disconnected as if carrier was dropped. Line is
+ *	the port number returned by register_serial().
+ */
+
+void unregister_serial(int line)
+{
+	unsigned long flags;
+	struct serial_state *state = &rs_table[line];
+
+	save_flags(flags); cli();
+	if (state->info && state->info->tty)
+		tty_hangup(state->info->tty);
+	state->type = PORT_UNKNOWN;
+	printk(KERN_INFO "tty%02d unloaded\n", state->line);
+	/* These will be hidden, because they are devices that will no longer
+	 * be available to the system. (ie, PCMCIA modems, once ejected)
+	 */
+	tty_unregister_devfs(&serial_driver,
+			     serial_driver.minor_start + state->line);
+	tty_unregister_devfs(&callout_driver,
+			     callout_driver.minor_start + state->line);
+	restore_flags(flags);
+}
+
+static void __exit rs_fini(void) 
+{
+	unsigned long flags;
+	int e1, e2;
+	int i;
+	struct async_struct *info;
+
+	/* printk("Unloading %s: version %s\n", serial_name, serial_version); */
+	del_timer_sync(&serial_timer);
+	save_flags(flags); cli();
+        remove_bh(SERIAL_BH);
+	if ((e1 = tty_unregister_driver(&serial_driver)))
+		printk("serial: failed to unregister serial driver (%d)\n",
+		       e1);
+	if ((e2 = tty_unregister_driver(&callout_driver)))
+		printk("serial: failed to unregister callout driver (%d)\n", 
+		       e2);
+	restore_flags(flags);
+
+	for (i = 0; i < NR_PORTS; i++) {
+		if ((info = rs_table[i].info)) {
+			rs_table[i].info = NULL;
+			kfree(info);
+		}
+		if ((rs_table[i].type != PORT_UNKNOWN) && rs_table[i].port) {
+				release_region(rs_table[i].port, 8);
+		}
+	}
+	if (tmp_buf) {
+		unsigned long pg = (unsigned long) tmp_buf;
+		tmp_buf = NULL;
+		free_page(pg);
+	}
+}
+
+module_init(rs_init);
+module_exit(rs_fini);
+MODULE_DESCRIPTION("Au1000 serial driver");
+
diff -urN linux-2.4.32/arch/mips/am5120/setup.c linux-2.4.32-adm5120/arch/mips/am5120/setup.c
--- linux-2.4.32/arch/mips/am5120/setup.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/setup.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,119 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : daniell@admtek.com.tw
+;    File    : arch/mips/am5120/setup.c
+;	 Date    : 2003.3.4
+;    Abstract: 
+;
+;Modification History:
+;
+;*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/types.h>
+#include <linux/string.h>	/* for memset */
+
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/am5120/adm5120.h>
+
+
+extern struct rtc_ops am5120_rtc_ops;
+extern struct rtc_ops *rtc_ops;
+
+void  mips_timer_setup(struct irqaction *irq);
+void  mips_time_init(void);
+
+int am5120_pci_module;
+
+
+void am5120_restart(char *command)
+{
+    int i;
+
+	/* Disable All ports*/
+	ADM5120_SW_REG(Port_conf0_REG) |= SW_DISABLE_PORT_MASK;
+
+	/* Disable CPU port */
+	ADM5120_SW_REG(CPUp_conf_REG) |= SW_CPU_PORT_DISABLE;
+
+	// Wait until switch DMA idle. At least 1ms is required!!!!
+    for (i=0; i <1000000; i++);
+
+    ADM5120_SW_REG(SftRest_REG) = SOFTWARE_RESET;
+}
+
+
+void am5120_halt(void)
+{
+        printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+        while (1);
+}
+
+
+void am5120_power_off(void)
+{
+        am5120_halt();
+}
+
+
+void __init am5120_setup(void)
+{
+    printk("am5120_setup() starts.\n");
+
+    board_time_init = mips_time_init;
+    board_timer_setup = mips_timer_setup;
+
+    _machine_restart = am5120_restart;
+    _machine_halt = am5120_halt;
+    _machine_power_off = am5120_power_off;
+
+    rtc_ops = &am5120_rtc_ops;
+
+    //Jeffrey
+    set_io_port_base(KSEG1);
+
+    //check pci in existence or not
+    if (ADM5120_SW_REG(CODE_REG) & CPU_PQFP_MODE)
+    {
+		printk("System no PCI BIOS\n");
+		am5120_pci_module = 0;
+    }
+    else
+    {
+		printk("System has PCI BIOS\n");
+		am5120_pci_module = 1;
+    }
+}
+
+
+const char *get_system_type(void)
+{
+	return "ADM5120 Demo Board";
+}
diff -urN linux-2.4.32/arch/mips/am5120/time.c linux-2.4.32-adm5120/arch/mips/am5120/time.c
--- linux-2.4.32/arch/mips/am5120/time.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/am5120/time.c	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Setting up the clock on the MIPS boards.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/hardirq.h>
+#include <asm/div64.h>
+#include <asm/cpu.h>
+#include <asm/am5120/adm5120.h>
+
+#include <linux/interrupt.h>
+#include <linux/timex.h>
+#include <asm/time.h>
+
+
+
+//static unsigned int r4k_offset; /* Amount to increment compare reg each time */
+//static unsigned int r4k_cur;    /* What counter should be at next timer irq */
+
+//extern unsigned int mips_counter_frequency;
+extern unsigned int mips_hpt_frequency;
+
+#define ALLINTS (IE_IRQ0 | IE_IRQ5 | STATUS_IE)
+
+
+#define MIPS_CPU_TIMER_IRQ 7
+
+
+void mips_timer_interrupt(struct pt_regs *regs)
+{
+	int cpu = smp_processor_id();
+	int irq = MIPS_CPU_TIMER_IRQ;
+
+	irq_enter(cpu, irq);
+	kstat.irqs[cpu][irq]++;
+	timer_interrupt(irq, NULL, regs);
+
+	irq_exit(cpu, irq);
+
+	if (softirq_pending(cpu))
+		do_softirq();
+}
+
+
+void __init mips_time_init(void)
+{
+	unsigned long clock;
+
+	clock = (ADM5120_SW_REG(CODE_REG) & CODE_CLK_MASK) >> CODE_CLK_SHIFT;
+
+	switch (clock)
+	{
+	case CPU_CLK_175MHZ:
+		mips_hpt_frequency = CPU_SPEED_175M;
+		printk("CPU clock: 175MHz\n");
+		break;
+
+	case CPU_CLK_200MHZ:
+		mips_hpt_frequency = CPU_SPEED_200M;
+		printk("CPU clock: 200MHz\n");
+		break;
+
+	case CPU_CLK_225MHZ:
+		mips_hpt_frequency = CPU_SPEED_225M;
+		printk("CPU clock: 225MHz\n");
+		break;
+
+	case CPU_CLK_250MHZ:
+		mips_hpt_frequency = CPU_SPEED_250M;
+		printk("CPU clock: 250MHz\n");
+		break;
+	}
+}
+
+
+void __init mips_timer_setup(struct irqaction *irq)
+{
+    /* to generate the first timer interrupt */
+	write_32bit_cp0_register(CP0_COMPARE, mips_hpt_frequency);	
+	write_32bit_cp0_register(CP0_COUNT, 0);
+//	clear_cp0_status(ST0_BEV);
+//	set_cp0_status(ALLINTS);
+	clear_c0_status(ST0_BEV);
+	set_c0_status(ALLINTS);
+}
diff -urN linux-2.4.32/arch/mips/config-shared.in linux-2.4.32-adm5120/arch/mips/config-shared.in
--- linux-2.4.32/arch/mips/config-shared.in	2005-12-20 12:43:09.000000000 +0200
+++ linux-2.4.32-adm5120/arch/mips/config-shared.in	2005-12-20 12:54:54.000000000 +0200
@@ -20,6 +20,7 @@
 mainmenu_option next_comment
 comment 'Machine selection'
 dep_bool 'Support for Acer PICA 1 chipset (EXPERIMENTAL)' CONFIG_ACER_PICA_61 $CONFIG_EXPERIMENTAL
+dep_bool 'Support for ADM5120 board' CONFIG_MIPS_AM5120 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Bosporus board' CONFIG_MIPS_BOSPORUS $CONFIG_MIPS32
 dep_bool 'Support for FIC Multimedia Player board' CONFIG_MIPS_FICMMP $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Mirage board' CONFIG_MIPS_MIRAGE $CONFIG_MIPS32
@@ -440,6 +441,12 @@
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_PC_KEYB y
 fi
+if [ "$CONFIG_MIPS_AM5120" = "y" ]; then
+   define_bool CONFIG_NEW_IRQ y
+   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
 if [ "$CONFIG_MIPS_SEAD" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
    define_int CONFIG_L1_CACHE_SHIFT 5
diff -urN linux-2.4.32/arch/mips/config-shared.in.orig linux-2.4.32-adm5120/arch/mips/config-shared.in.orig
--- linux-2.4.32/arch/mips/config-shared.in.orig	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/arch/mips/config-shared.in.orig	2005-12-20 12:22:41.000000000 +0200
@@ -0,0 +1,1088 @@
+mainmenu_name "Linux/MIPS Kernel Configuration"
+
+mainmenu_option next_comment
+comment 'Code maturity level options'
+bool 'Prompt for development and/or incomplete code/drivers' CONFIG_EXPERIMENTAL
+endmenu
+
+mainmenu_option next_comment
+comment 'Loadable module support'
+bool 'Enable loadable module support' CONFIG_MODULES
+if [ "$CONFIG_MODULES" = "y" ]; then
+   bool '  Set version information on all module symbols' CONFIG_MODVERSIONS
+   bool '  Kernel module loader' CONFIG_KMOD
+fi
+endmenu
+
+#
+# Keep these alphabetically sorted
+#
+mainmenu_option next_comment
+comment 'Machine selection'
+dep_bool 'Support for Acer PICA 1 chipset (EXPERIMENTAL)' CONFIG_ACER_PICA_61 $CONFIG_EXPERIMENTAL
+dep_bool 'Support for ADM5120 board' CONFIG_MIPS_AM5120 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Bosporus board' CONFIG_MIPS_BOSPORUS $CONFIG_MIPS32
+dep_bool 'Support for FIC Multimedia Player board' CONFIG_MIPS_FICMMP $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Mirage board' CONFIG_MIPS_MIRAGE $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1000 board' CONFIG_MIPS_DB1000 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1100 board' CONFIG_MIPS_DB1100 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1500 board' CONFIG_MIPS_DB1500 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1550 board' CONFIG_MIPS_DB1550 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1200 board' CONFIG_MIPS_DB1200 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1000 board' CONFIG_MIPS_PB1000 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1100 board' CONFIG_MIPS_PB1100 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1500 board' CONFIG_MIPS_PB1500 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1550 board' CONFIG_MIPS_PB1550 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy PB1200 board' CONFIG_MIPS_PB1200 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
+dep_bool 'Support for MyCable XXS1500 board' CONFIG_MIPS_XXS1500 $CONFIG_MIPS32
+dep_bool 'Support for 4G Systems MTX-1 board' CONFIG_MIPS_MTX1 $CONFIG_MIPS32
+dep_bool 'Support for Cogent CSB250 board' CONFIG_COGENT_CSB250 $CONFIG_MIPS32
+dep_bool 'Support for BAGET MIPS series (EXPERIMENTAL)' CONFIG_BAGET_MIPS $CONFIG_MIPS32 $CONFIG_EXPERIMENTAL
+bool 'Support for CASIO CASSIOPEIA E-10/15/55/65' CONFIG_CASIO_E55
+dep_bool 'Support for Cobalt Server (EXPERIMENTAL)' CONFIG_MIPS_COBALT $CONFIG_EXPERIMENTAL
+if [ "$CONFIG_MIPS32" = "y" -o "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   bool 'Support for DECstations' CONFIG_DECSTATION
+fi
+dep_bool 'Support for Galileo EV64120 Evaluation board (EXPERIMENTAL)' CONFIG_MIPS_EV64120 $CONFIG_EXPERIMENTAL
+if [ "$CONFIG_MIPS_EV64120" = "y" ]; then
+   bool '  Enable Second PCI (PCI1)' CONFIG_EVB_PCI1
+   choice '  Galileo Chip Clock' \
+	"75	CONFIG_SYSCLK_75 \
+	 83.3	CONFIG_SYSCLK_83 \
+	 100	CONFIG_SYSCLK_100" 83.3
+fi
+dep_bool 'Support for Galileo EV96100 Evaluation board (EXPERIMENTAL)' CONFIG_MIPS_EV96100 $CONFIG_EXPERIMENTAL
+bool 'Support for Globespan IVR board' CONFIG_MIPS_IVR
+bool 'Support for Hewlett Packard LaserJet board' CONFIG_HP_LASERJET
+bool 'Support for IBM WorkPad z50' CONFIG_IBM_WORKPAD
+if [ "$CONFIG_IBM_WORKPAD" = "y" ]; then
+   tristate '  NEC VRC4171 support' CONFIG_VRC4171
+fi
+bool 'Support for LASAT Networks platforms' CONFIG_LASAT
+if [ "$CONFIG_LASAT" = "y" ]; then
+   tristate '  PICVUE LCD display driver' CONFIG_PICVUE
+   dep_tristate '   PICVUE LCD display driver /proc interface' CONFIG_PICVUE_PROC $CONFIG_PICVUE
+   bool '  DS1603 RTC driver' CONFIG_DS1603
+   if [ "$CONFIG_DS1603" = "y" ]; then
+      define_bool CONFIG_MIPS_RTC y
+   fi
+   bool '  LASAT sysctl interface' CONFIG_LASAT_SYSCTL
+fi
+bool 'Support for ITE 8172G board' CONFIG_MIPS_ITE8172
+if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
+   bool '  Support for older IT8172 (Rev C)' CONFIG_IT8172_REVC
+fi
+bool 'Support for MIPS Atlas board' CONFIG_MIPS_ATLAS
+bool 'Support for MIPS Magnum 4000' CONFIG_MIPS_MAGNUM_4000
+bool 'Support for MIPS Malta board' CONFIG_MIPS_MALTA
+dep_bool 'Support for MIPS SEAD board (EXPERIMENTAL)' CONFIG_MIPS_SEAD $CONFIG_EXPERIMENTAL
+bool 'Support for Momentum Ocelot board' CONFIG_MOMENCO_OCELOT
+bool 'Support for Momentum Ocelot-G board' CONFIG_MOMENCO_OCELOT_G
+bool 'Support for Momentum Ocelot-C and -CS boards' CONFIG_MOMENCO_OCELOT_C
+bool 'Support for Momentum Jaguar-ATX boards' CONFIG_MOMENCO_JAGUAR_ATX
+bool 'Support for PMC-Sierra Big Sur board' CONFIG_PMC_BIG_SUR
+bool 'Support for PMC-Sierra Stretch board' CONFIG_PMC_STRETCH
+bool 'Support for PMC-Sierra Yosemite board' CONFIG_PMC_YOSEMITE
+if [ "$CONFIG_PMC_YOSEMITE" = "y" ]; then
+   bool '  Hypertransport Support for PMC-Sierra Yosemite'  CONFIG_HYPERTRANSPORT
+fi
+dep_bool 'Support for NEC DDB Vrc-5074 (EXPERIMENTAL)' CONFIG_DDB5074 $CONFIG_EXPERIMENTAL
+bool 'Support for NEC DDB Vrc-5476' CONFIG_DDB5476
+bool 'Support for NEC DDB Vrc-5477' CONFIG_DDB5477
+if [ "$CONFIG_DDB5477" = "y" ]; then
+   int '   bus frequency (in kHZ, 0 for auto-detect)' CONFIG_DDB5477_BUS_FREQUENCY 0
+fi
+bool 'Support for NEC Osprey board' CONFIG_NEC_OSPREY
+bool 'Support for NEC Eagle/Hawk board' CONFIG_NEC_EAGLE
+if [ "$CONFIG_NEC_EAGLE" = "y" ]; then
+   tristate '  NEC VRC4173 support' CONFIG_VRC4173
+fi
+bool 'Support for Olivetti M700-10' CONFIG_OLIVETTI_M700
+dep_bool 'Support for Philips Nino (EXPERIMENTAL)' CONFIG_NINO $CONFIG_MIPS32 $CONFIG_EXPERIMENTAL
+if [ "$CONFIG_NINO" = "y" ]; then
+   choice 'Nino Model Number' \
+	"Model-300/301/302/319			CONFIG_NINO_4MB \
+	 Model-200/210/312/320/325/350/390	CONFIG_NINO_8MB \
+	 Model-500/510				CONFIG_NINO_16MB" Model-200
+fi
+bool 'Support for SGI IP22 (Indy/Indigo2)' CONFIG_SGI_IP22
+dep_bool 'Support for SGI IP27 (Origin200/2000)' CONFIG_SGI_IP27 $CONFIG_MIPS64
+if [ "$CONFIG_SGI_IP27" = "y" ]; then
+   bool '  IP27 N-Mode' CONFIG_SGI_SN0_N_MODE
+   bool '  Discontiguous Memory Support' CONFIG_DISCONTIGMEM
+   bool '  NUMA Support' CONFIG_NUMA
+   bool '  Mapped kernel support' CONFIG_MAPPED_KERNEL
+   bool '  Kernel text replication support' CONFIG_REPLICATE_KTEXT
+   bool '  Exception handler replication support' CONFIG_REPLICATE_EXHANDLERS
+   define_bool CONFIG_SMP_CAPABLE y
+   #bool '  IP27 XXL' CONFIG_SGI_SN0_XXL
+fi
+dep_bool 'Support for Broadcom BCM1xxx SOCs (EXPERIMENTAL)' CONFIG_SIBYTE_SB1xxx_SOC $CONFIG_EXPERIMENTAL
+if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
+   choice '   BCM1xxx SOC-based board' \
+          "BCM91250A-SWARM      CONFIG_SIBYTE_SWARM \
+           BCM91250E-Sentosa    CONFIG_SIBYTE_SENTOSA \
+           BCM91125E-Rhone      CONFIG_SIBYTE_RHONE \
+           BCM91120x-Carmel     CONFIG_SIBYTE_CARMEL \
+           BCM91250PT-PTSwarm   CONFIG_SIBYTE_PTSWARM \
+           BCM91250C2-LittleSur CONFIG_SIBYTE_LITTLESUR \
+           BCM91120C-CRhine     CONFIG_SIBYTE_CRHINE \
+           BCM91125C-CRhone     CONFIG_SIBYTE_CRHONE \
+           Other                CONFIG_SIBYTE_UNKNOWN" BCM91250A-SWARM
+
+   if [ "$CONFIG_SIBYTE_UNKNOWN" = "y" ]; then
+      choice '   BCM1xxx SOC Type' \
+          "BCM1250     CONFIG_SIBYTE_SB1250 \
+           BCM1120     CONFIG_SIBYTE_BCM1120 \
+           BCM1125     CONFIG_SIBYTE_BCM1125 \
+           BCM1125H    CONFIG_SIBYTE_BCM1125H" BCM1250
+      unset CONFIG_SIBYTE_BOARD
+   else
+      define_bool CONFIG_SIBYTE_BOARD y
+      if [ "$CONFIG_SIBYTE_SWARM" = "y" -o \
+           "$CONFIG_SIBYTE_LITTLESUR" = "y" -o \
+           "$CONFIG_SIBYTE_PTSWARM" = "y" -o \
+           "$CONFIG_SIBYTE_SENTOSA" = "y" ]; then
+         define_bool CONFIG_SIBYTE_SB1250 y
+         unset CONFIG_SIBYTE_BCM1120
+         unset CONFIG_SIBYTE_BCM1125
+         unset CONFIG_SIBYTE_BCM1125H
+      fi
+      if [ "$CONFIG_SIBYTE_CRHINE" = "y" -o \
+           "$CONFIG_SIBYTE_CARMEL" = "y" ]; then
+         define_bool CONFIG_SIBYTE_BCM1120 y
+         unset CONFIG_SIBYTE_SB1250
+         unset CONFIG_SIBYTE_BCM1125
+         unset CONFIG_SIBYTE_BCM1125H
+      fi
+      if [ "$CONFIG_SIBYTE_CRHONE" = "y" -o \
+           "$CONFIG_SIBYTE_RHONE" = "y" ]; then
+         define_bool CONFIG_SIBYTE_BCM1125H y
+         unset CONFIG_SIBYTE_SB1250
+         unset CONFIG_SIBYTE_BCM1120
+         unset CONFIG_SIBYTE_BCM1125
+      fi
+   fi
+
+   if [ "$CONFIG_SIBYTE_BCM1120" = "y" -o \
+        "$CONFIG_SIBYTE_BCM1125" = "y" -o \
+        "$CONFIG_SIBYTE_BCM1125H" = "y" ]; then
+      define_bool CONFIG_SIBYTE_BCM112X y
+      choice 'BCM112x Stepping' \
+         "Hybrid CONFIG_CPU_SB1_PASS_2 \
+          An     CONFIG_CPU_SB1_PASS_3" An
+   else
+      unset CONFIG_SIBYTE_BCM112X
+      choice 'BCM1250 Stepping' \
+         "Pass1   CONFIG_CPU_SB1_PASS_1 \
+          An      CONFIG_CPU_SB1_PASS_2 \
+          Bn      CONFIG_CPU_SB1_PASS_2_2 \
+          Cn      CONFIG_CPU_SB1_PASS_4" An
+   fi
+
+   bool '   Booting from CFE' CONFIG_SIBYTE_CFE
+   dep_bool '     Use firmware console' CONFIG_SIBYTE_CFE_CONSOLE $CONFIG_SIBYTE_CFE
+   if [ "$CONFIG_SIBYTE_CFE" = "n" ]; then
+      define_bool CONFIG_SIBYTE_STANDALONE y
+      int  '   Memory size (in megabytes)' CONFIG_SIBYTE_STANDALONE_RAM_SIZE 32
+   fi
+
+   bool '   Support for Bus Watcher statistics' CONFIG_SIBYTE_BUS_WATCHER
+   if [ "$CONFIG_SIBYTE_TBPROF" = "n" ]; then
+      dep_bool '     Capture bus trace before bus error' CONFIG_SIBYTE_BW_TRACE $CONFIG_SIBYTE_BUS_WATCHER
+   fi
+
+   bool '   Support for SB1/SOC profiling - SB1/SCD perf counters' CONFIG_SIBYTE_SB1250_PROF
+   bool '   Support for ZBbus profiling' CONFIG_SIBYTE_TBPROF
+
+   if [ "$CONFIG_SIBYTE_SWARM" = "y" -o \
+        "$CONFIG_SIBYTE_LITTLESUR" = "y" -o \
+        "$CONFIG_SIBYTE_PTSWARM" = "y" -o \
+        "$CONFIG_SIBYTE_CARMEL" = "y" ]; then
+      define_bool CONFIG_SIBYTE_GENBUS_IDE y
+   fi
+
+   if [ "$CONFIG_SIBYTE_SB1250" = "y" -a \
+        "$CONFIG_SIBYTE_STANDALONE" != "y" ]; then
+      define_bool CONFIG_SMP_CAPABLE y
+   fi
+   define_bool CONFIG_MIPS_RTC y
+fi
+bool 'Support for SNI RM200 PCI' CONFIG_SNI_RM200_PCI
+bool 'Support for TANBAC TB0226 (Mbase)' CONFIG_TANBAC_TB0226
+bool 'Support for TANBAC TB0229 (VR4131DIMM)' CONFIG_TANBAC_TB0229
+if [ "$CONFIG_TANBAC_TB0229" = "y" ]; then
+   bool '  Add TANBAC TB0219 Base board support' CONFIG_TANBAC_TB0219
+fi
+
+dep_bool 'Support for Toshiba JMR-TX3927 board' CONFIG_TOSHIBA_JMR3927 $CONFIG_MIPS32
+bool 'Support for Toshiba RBTX49[23]7 Reference Board' CONFIG_TOSHIBA_RBTX4927
+bool 'Support for Victor MP-C303/304' CONFIG_VICTOR_MPC30X
+if [ "$CONFIG_VICTOR_MPC30X" = "y" ]; then
+   tristate '  NEC VRC4173 support' CONFIG_VRC4173
+fi
+bool 'Support for ZAO Networks Capcella' CONFIG_ZAO_CAPCELLA
+
+dep_bool 'High Memory Support' CONFIG_HIGHMEM $CONFIG_MIPS32
+
+define_bool CONFIG_RWSEM_GENERIC_SPINLOCK y
+define_bool CONFIG_RWSEM_XCHGADD_ALGORITHM n
+
+#
+# Select some configuration options automatically based on user selections.
+#
+if [ "$CONFIG_ACER_PICA_61" = "y" ]; then
+   define_bool CONFIG_ARC32 y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_MIPS_JAZZ y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_CASIO_E55" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SCSI n
+fi
+if [ "$CONFIG_MIPS_MIRAGE" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MIPS_FICMMP" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_BOSPORUS" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MIPS_PB1000" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1000 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+fi
+if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_PB1100" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+fi
+if [ "$CONFIG_MIPS_PB1550" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1550 y
+   define_bool CONFIG_NONCOHERENT_IO n
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_PB1200" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_DB1000" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1000 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
+if [ "$CONFIG_MIPS_DB1500" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
+if [ "$CONFIG_MIPS_DB1550" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1550 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_DB1200" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1200 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_HYDROGEN3" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1100 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE y
+fi
+if [ "$CONFIG_MIPS_XXS1500" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_MTX1" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_COGENT_CSB250" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1500 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_COBALT" = "y" ]; then
+   define_bool CONFIG_BOOT_ELF32 y
+   define_bool CONFIG_COBALT_LCD y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_DECSTATION" = "y" ]; then
+   define_bool CONFIG_EARLY_PRINTK y
+   define_bool CONFIG_BOOT_ELF32 y
+   define_bool CONFIG_IRQ_CPU y
+   define_int CONFIG_L1_CACHE_SHIFT 4
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MIPS_EV64120" = "y" ]; then
+   define_bool CONFIG_MIPS_GT64120 y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MIPS_EV96100" = "y" ]; then
+   define_bool CONFIG_MIPS_GT64120 y
+   define_bool CONFIG_MIPS_GT96100 y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+fi
+if [ "$CONFIG_MIPS_IVR" = "y" ]; then
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_IT8172_CIR y
+fi
+if [ "$CONFIG_HP_LASERJET" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_IBM_WORKPAD" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_SCSI n
+fi
+if [ "$CONFIG_LASAT" = "y" ]; then
+   define_bool CONFIG_BOARD_SCACHE y
+   define_bool CONFIG_R5000_CPU_SCACHE y
+   define_bool CONFIG_MIPS_GT64120 y
+   define_bool CONFIG_MIPS_NILE4 y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
+   define_bool CONFIG_IT8712 y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_IT8172_CIR y
+fi
+if [ "$CONFIG_MIPS_ATLAS" = "y" ]; then
+   define_bool CONFIG_BOOT_ELF32 y
+   define_int CONFIG_L1_CACHE_SHIFT 5
+   define_bool CONFIG_MIPS_BONITO64 y
+   define_bool CONFIG_MIPS_GT64120 y
+   define_bool CONFIG_MIPS_MSC y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+fi
+if [ "$CONFIG_MIPS_MAGNUM_4000" = "y" -o \
+     "$CONFIG_OLIVETTI_M700"    = "y" ]; then
+   define_bool CONFIG_ARC32 y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_FB y
+   define_bool CONFIG_FB_G364 y
+   define_bool CONFIG_MIPS_JAZZ y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_MALTA" = "y" ]; then
+   define_bool CONFIG_BOOT_ELF32 y
+   define_bool CONFIG_HAVE_STD_PC_SERIAL_PORT y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_MIPS_BONITO64 y
+   define_bool CONFIG_MIPS_GT64120 y
+   define_bool CONFIG_MIPS_MSC y
+   define_int CONFIG_L1_CACHE_SHIFT 5
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "CONFIG_MIPS_AM5120" = "y" ]; then
+   define_bool CONFIG_PCI y
+   define_bool CONFIG_HAVE_STD_PC_SERIAL_PORT y
+   define_bool CONFIG_NEW_IRQ y
+#+Jeffrey
+   define_bool CONFIG_NEW_PCI y
+   define_bool CONFIG_PCI_AUTO y
+#-Jeffrey
+   define_bool CONFIG_NEW_IRQ y
+   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE y
+#   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_SEAD" = "y" ]; then
+   define_bool CONFIG_BOOT_ELF32 y
+   define_int CONFIG_L1_CACHE_SHIFT 5
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MOMENCO_OCELOT" = "y" ]; then
+   define_bool CONFIG_SYSCLK_100 y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_MOMENCO_OCELOT_G" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_IRQ_CPU_RM7K y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SYSCLK_100 y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+fi
+if [ "$CONFIG_MOMENCO_OCELOT_C" = "y" ]; then
+   define_bool CONFIG_SWAP_IO_SPACE y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_BOOT_ELF32 y
+fi
+if [ "$CONFIG_PMC_BIG_SUR" = "y" ]; then
+   define_bool CONFIG_BOOT_ELF32 y
+fi
+if [ "$CONFIG_MOMENCO_JAGUAR_ATX" = "y" ]; then
+   define_bool CONFIG_SWAP_IO_SPACE y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_BOOT_ELF32 y
+fi
+
+if [ "$CONFIG_PMC_STRETCH" = "y" ]; then
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_PCI y
+   define_bool CONFIG_BOOT_ELF32 y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+
+if [ "$CONFIG_PMC_YOSEMITE" = "y" ]; then
+   define_bool CONFIG_SWAP_IO_SPACE y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_BOOT_ELF32 y
+   define_bool CONFIG_HIGHMEM y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+
+if [ "$CONFIG_DDB5074" = "y" ]; then
+   define_bool CONFIG_HAVE_STD_PC_SERIAL_PORT y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_IRQ_CPU y
+fi
+if [ "$CONFIG_DDB5476"  = "y" ]; then
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_HAVE_STD_PC_SERIAL_PORT y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_DDB5477" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+   define_bool CONFIG_I8259 y
+fi
+if [ "$CONFIG_NEC_OSPREY" = "y" ]; then
+   define_bool CONFIG_VR4181 y
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SCSI n
+fi
+if [ "$CONFIG_NEC_EAGLE" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SCSI n
+fi
+if [ "$CONFIG_NINO" = "y" ]; then
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_SGI_IP22" = "y" ]; then
+   define_bool CONFIG_ARC32 y
+   define_bool CONFIG_ARC_PROMLIB y
+   define_bool CONFIG_BOARD_SCACHE y
+   define_bool CONFIG_BOOT_ELF32 y
+   define_bool CONFIG_SWAP_IO_SPACE_W n
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_IRQ_CPU y
+   define_int CONFIG_L1_CACHE_SHIFT 5
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_SGI_IP27" = "y" ]; then
+   define_bool CONFIG_BOOT_ELF64 y
+   define_bool CONFIG_ARC64 y
+   define_int CONFIG_L1_CACHE_SHIFT 7
+   #define_bool CONFIG_MAPPED_PCI_IO y
+   define_bool CONFIG_QL_ISP_A64 y
+fi
+if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_BOOT_ELF32 y
+fi
+if [ "$CONFIG_SNI_RM200_PCI" = "y" ]; then
+   define_bool CONFIG_ARC32 y
+   define_bool CONFIG_ARC_MEMORY y
+   define_bool CONFIG_ARC_PROMLIB y
+   define_bool CONFIG_I8259 y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_TANBAC_TB0226" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SERIAL_MANY_PORTS y
+fi
+if [ "$CONFIG_TANBAC_TB0229" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SERIAL_MANY_PORTS y
+fi
+if [ "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
+   define_bool CONFIG_TOSHIBA_BOARDS y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" ]; then
+   define_bool CONFIG_SWAP_IO_SPACE_W y
+   define_bool CONFIG_SWAP_IO_SPACE_L y
+   define_bool CONFIG_ISA y
+   define_bool CONFIG_NONCOHERENT_IO y
+fi
+if [ "$CONFIG_VICTOR_MPC30X" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_SCSI n
+fi
+if [ "$CONFIG_ZAO_CAPCELLA" = "y" ]; then
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_DUMMY_KEYB y
+   define_bool CONFIG_SCSI n
+fi
+
+if [ "$CONFIG_MIPS_AU1000" != "y" ]; then
+   define_bool CONFIG_MIPS_AU1000 n
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'CPU selection'
+
+choice 'CPU type' \
+	"MIPS32	CONFIG_CPU_MIPS32 \
+	 MIPS64	CONFIG_CPU_MIPS64 \
+	 R3000	CONFIG_CPU_R3000 \
+	 R39XX	CONFIG_CPU_TX39XX \
+	 R41xx	CONFIG_CPU_VR41XX \
+	 R4300	CONFIG_CPU_R4300 \
+	 R4x00	CONFIG_CPU_R4X00 \
+	 R49XX	CONFIG_CPU_TX49XX \
+	 R5000	CONFIG_CPU_R5000 \
+	 R5432	CONFIG_CPU_R5432 \
+	 R6000	CONFIG_CPU_R6000 \
+	 R52xx	CONFIG_CPU_NEVADA \
+	 R8000	CONFIG_CPU_R8000 \
+	 R10000	CONFIG_CPU_R10000 \
+	 RM7000	CONFIG_CPU_RM7000 \
+	 RM9000	CONFIG_CPU_RM9000 \
+	 SB1	CONFIG_CPU_SB1" R4x00
+
+if [ "$CONFIG_CPU_R3000" = "n" -a "$CONFIG_CPU_TX39XX" = "n" -a \
+     "$CONFIG_EXPERIMENTAL" = "y" ]; then
+   choice 'Kernel page size'					\
+	"4KB                    CONFIG_PAGE_SIZE_4KB		\
+	 16KB                   CONFIG_PAGE_SIZE_16KB		\
+	 64KB                   CONFIG_PAGE_SIZE_64KB" 4KB
+else
+   define_bool CONFIG_PAGE_SIZE_4KB y
+fi
+
+if [ "$CONFIG_SMP_CAPABLE" = "y" ]; then
+   bool '  Multi-Processing support' CONFIG_SMP
+fi
+ 
+if [ "$CONFIG_CPU_MIPS32" = "y" -o "$CONFIG_CPU_MIPS64" = "y" ]; then
+   define_bool CONFIG_CPU_HAS_PREFETCH y
+   bool '  Support for Virtual Tagged I-cache' CONFIG_VTAG_ICACHE
+fi
+
+if [ "$CONFIG_CPU_RM7000" = "y" ]; then
+   define_bool CONFIG_BOARD_SCACHE y
+   define_bool CONFIG_CPU_HAS_PREFETCH y
+   define_bool CONFIG_RM7000_CPU_SCACHE y
+fi
+if [ "$CONFIG_CPU_RM9000" = "y" ]; then
+   define_bool CONFIG_BOARD_SCACHE y
+   define_bool CONFIG_CPU_HAS_PREFETCH y
+   define_bool CONFIG_RM7000_CPU_SCACHE y
+fi
+
+if [ "$CONFIG_CPU_SB1" = "y" ]; then
+   bool '  Use DMA to clear/copy pages' CONFIG_SIBYTE_DMA_PAGEOPS
+   # SB1 Pass-specific options
+   if [ "$CONFIG_CPU_SB1_PASS_1" = "y" ]; then
+      define_bool CONFIG_SB1_PASS_1_WORKAROUNDS y
+   fi
+   if [ "$CONFIG_CPU_SB1_PASS_2" = "y" ]; then
+      define_bool CONFIG_SB1_PASS_2_WORKAROUNDS y
+      define_bool CONFIG_SB1_PASS_2_1_WORKAROUNDS y
+   else
+      # Avoid prefetches on Pass 2 (before 2.2)
+      bool '  Enable prefetches' CONFIG_CPU_HAS_PREFETCH
+   fi
+   if [ "$CONFIG_CPU_SB1_PASS_2_2" = "y" ]; then
+      # XXXKW for now, let 2.2 use same WORKAROUNDS flag as pre-2.2
+      define_bool CONFIG_SB1_PASS_2_WORKAROUNDS y
+   fi
+
+   define_bool CONFIG_VTAG_ICACHE y
+fi
+
+if [ "$CONFIG_CPU_R4X00"  = "y" -o \
+     "$CONFIG_CPU_R5000"  = "y" -o \
+     "$CONFIG_CPU_RM7000" = "y" -o \
+     "$CONFIG_CPU_RM9000" = "y" -o \
+     "$CONFIG_CPU_R10000" = "y" -o \
+     "$CONFIG_CPU_SB1"    = "y" -o \
+     "$CONFIG_CPU_MIPS32" = "y" -o \
+     "$CONFIG_CPU_MIPS64" = "y" ]; then
+   dep_bool '  Support for 64-bit physical address space' CONFIG_64BIT_PHYS_ADDR $CONFIG_MIPS32
+fi
+
+dep_bool 'Override CPU Options' CONFIG_CPU_ADVANCED $CONFIG_MIPS32
+if [ "$CONFIG_CPU_ADVANCED" = "y" ]; then
+   bool '  ll/sc Instructions available' CONFIG_CPU_HAS_LLSC
+   bool '  lld/scd Instructions available' CONFIG_CPU_HAS_LLDSCD
+   bool '  Writeback Buffer available' CONFIG_CPU_HAS_WB
+else
+   if [ "$CONFIG_CPU_R3000"  = "y" -o \
+        "$CONFIG_CPU_VR41XX" = "y" -o \
+        "$CONFIG_CPU_TX39XX" = "y" ]; then
+      if [ "$CONFIG_DECSTATION" = "y" ]; then
+	 define_bool CONFIG_CPU_HAS_LLSC n
+	 define_bool CONFIG_CPU_HAS_LLDSCD n
+	 define_bool CONFIG_CPU_HAS_WB y
+      else
+	 define_bool CONFIG_CPU_HAS_LLSC n
+	 define_bool CONFIG_CPU_HAS_LLDSCD n
+	 define_bool CONFIG_CPU_HAS_WB n
+      fi
+   else
+      if [ "$CONFIG_CPU_MIPS32" = "y" ]; then
+	 define_bool CONFIG_CPU_HAS_LLSC y
+	 define_bool CONFIG_CPU_HAS_LLDSCD n
+	 define_bool CONFIG_CPU_HAS_WB n
+      else
+	 define_bool CONFIG_CPU_HAS_LLSC y
+	 define_bool CONFIG_CPU_HAS_LLDSCD y
+	 define_bool CONFIG_CPU_HAS_WB n
+      fi
+   fi
+fi
+if [ "$CONFIG_CPU_R3000" = "y" ]; then
+   define_bool CONFIG_CPU_HAS_SYNC n
+else
+   define_bool CONFIG_CPU_HAS_SYNC y
+fi
+endmenu
+
+#
+# Choose endianess of code to generate.  It's a frequent trap for users so the
+# config file tries it's best to choose the right endianess for those systems
+# where we know about their endianess.  We only ask the user for systems
+# known to be bi-endian; for those systems the defconfig file should defaults
+# to the common endianess used for that system.
+#
+mainmenu_option next_comment
+comment 'General setup'
+if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_CASIO_E55" = "y" -o \
+     "$CONFIG_DDB5074" = "y" -o \
+     "$CONFIG_DDB5476" = "y" -o \
+     "$CONFIG_DDB5477" = "y" -o \
+     "$CONFIG_DECSTATION" = "y" -o \
+     "$CONFIG_HP_LASERJET" = "y" -o \
+     "$CONFIG_IBM_WORKPAD" = "y" -o \
+     "$CONFIG_LASAT" = "y" -o \
+     "$CONFIG_MIPS_COBALT" = "y" -o \
+     "$CONFIG_MIPS_ITE8172" = "y" -o \
+     "$CONFIG_MIPS_IVR" = "y" -o \
+     "$CONFIG_MIPS_PB1000" = "y" -o \
+     "$CONFIG_MIPS_PB1100" = "y" -o \
+     "$CONFIG_MIPS_PB1500" = "y" -o \
+     "$CONFIG_MIPS_PB1550" = "y" -o \
+     "$CONFIG_MIPS_PB1200" = "y" -o \
+     "$CONFIG_MIPS_DB1000" = "y" -o \
+     "$CONFIG_MIPS_DB1100" = "y" -o \
+     "$CONFIG_MIPS_DB1500" = "y" -o \
+     "$CONFIG_MIPS_DB1550" = "y" -o \
+     "$CONFIG_MIPS_DB1200" = "y" -o \
+     "$CONFIG_NEC_OSPREY" = "y" -o \
+     "$CONFIG_NEC_EAGLE" = "y" -o \
+     "$CONFIG_NINO" = "y" -o \
+     "$CONFIG_OLIVETTI_M700" = "y" -o \
+     "$CONFIG_SNI_RM200_PCI" = "y" -o \
+     "$CONFIG_VICTOR_MPC30X" = "y" -o \
+     "$CONFIG_ZAO_CAPCELLA" = "y" ]; then
+   define_bool CONFIG_CPU_LITTLE_ENDIAN y
+else
+   if [ "$CONFIG_BAGET_MIPS" = "y" -o \
+	"$CONFIG_MIPS_EV64120" = "y" -o \
+	"$CONFIG_MIPS_EV96100" = "y" -o \
+	"$CONFIG_MOMENCO_OCELOT" = "y" -o \
+	"$CONFIG_MOMENCO_OCELOT_G" = "y" -o \
+	"$CONFIG_SGI_IP22" = "y" -o \
+	"$CONFIG_SGI_IP27" = "y" -o \
+	"$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
+      define_bool CONFIG_CPU_LITTLE_ENDIAN n
+   else
+      bool 'Generate little endian code' CONFIG_CPU_LITTLE_ENDIAN
+   fi
+fi
+
+dep_bool 'Use 64-bit ELF format for building' CONFIG_BUILD_ELF64 $CONFIG_MIPS64
+
+if [ "$CONFIG_CPU_LITTLE_ENDIAN" = "n" ]; then
+   bool 'Include IRIX binary compatibility' CONFIG_BINFMT_IRIX
+fi
+
+if [ "$CONFIG_CPU_R10000" = "y" ]; then
+   dep_bool 'Support for large 64-bit configurations' CONFIG_MIPS_INSANE_LARGE $CONFIG_MIPS64
+fi
+
+if [ "$CONFIG_ARC32" = "y" ]; then
+   bool 'ARC console support' CONFIG_ARC_CONSOLE
+fi
+
+bool 'Networking support' CONFIG_NET
+
+if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_CASIO_E55" = "y" -o \
+     "$CONFIG_DECSTATION" = "y" -o \
+     "$CONFIG_IBM_WORKPAD" = "y" -o \
+     "$CONFIG_MIPS_MAGNUM_4000" = "y" -o \
+     "$CONFIG_MIPS_SEAD" = "y" -o \
+     "$CONFIG_NINO" = "y" -o \
+     "$CONFIG_OLIVETTI_M700" = "y" -o \
+     "$CONFIG_SGI_IP22" = "y" ]; then
+   define_bool CONFIG_PCI n
+else
+   bool 'PCI bus support' CONFIG_PCI
+   dep_bool '    New PCI bus code' CONFIG_PCI_NEW $CONFIG_PCI
+   if [ "$CONFIG_HP_LASERJET" = "y" -o \
+        "$CONFIG_LASAT" = "y" -o \
+        "$CONFIG_MIPS_ATLAS" = "y" -o \
+        "$CONFIG_MIPS_COBALT" = "y" -o \
+        "$CONFIG_MIPS_DB1000" = "y" -o \
+        "$CONFIG_MIPS_DB1100" = "y" -o \
+        "$CONFIG_MIPS_EV64120" = "y" -o \
+        "$CONFIG_MIPS_HYDROGEN3" = "y" -o \
+        "$CONFIG_MIPS_MALTA" = "y" -o \
+        "$CONFIG_MIPS_PB1100" = "y" -o \
+        "$CONFIG_MOMENCO_OCELOT" = "y" -o \
+        "$CONFIG_NEC_OSPREY" = "y" -o \
+        "$CONFIG_PMC_YOSEMITE" = "y" -o \
+        "$CONFIG_SIBYTE_SWARM" = "y" -o \
+	"$CONFIG_SNI_RM200_PCI" = "y" ]; then
+      define_bool CONFIG_PCI_AUTO n
+   else
+      define_bool CONFIG_PCI_AUTO y
+   fi
+fi
+if [ "$CONFIG_SIBYTE_SB1250" = "y" -o \
+     "$CONFIG_SIBYTE_BCM1125H" = "y" ]; then
+   if [ "$CONFIG_PCI" = "y" ]; then
+      define_bool CONFIG_SIBYTE_HAS_LDT y
+   fi
+fi
+
+if [ "$CONFIG_SGI_IP22" = "y" -o "$CONFIG_MIPS_MAGNUM_4000" = "y" -o \
+     "$CONFIG_OLIVETTI_M700" = "y" -o "$CONFIG_SNI_RM200_PCI" = "y" ]; then
+   bool 'EISA bus support' CONFIG_EISA
+fi
+
+source drivers/pci/Config.in
+
+if [ "$CONFIG_EISA" = "y" -a "$CONFIG_ISA" != "y" ]; then
+   define_bool CONFIG_ISA y
+fi
+if [ "$CONFIG_ISA" != "y" ]; then
+   define_bool CONFIG_ISA n
+fi
+
+dep_bool 'TURBOchannel support' CONFIG_TC $CONFIG_DECSTATION
+#dep_bool 'Access.Bus support' CONFIG_ACCESSBUS $CONFIG_TC
+
+define_bool CONFIG_MCA n
+define_bool CONFIG_SBUS n
+
+bool 'Support for hot-pluggable devices' CONFIG_HOTPLUG
+
+if [ "$CONFIG_HOTPLUG" = "y" ] ; then
+   source drivers/pcmcia/Config.in
+   source drivers/hotplug/Config.in
+else
+   define_bool CONFIG_PCMCIA n
+   define_bool CONFIG_HOTPLUG_PCI n
+fi
+
+bool 'System V IPC' CONFIG_SYSVIPC
+bool 'BSD Process Accounting' CONFIG_BSD_PROCESS_ACCT
+bool 'Sysctl support' CONFIG_SYSCTL
+define_bool CONFIG_KCORE_ELF y
+define_bool CONFIG_KCORE_AOUT n
+define_bool CONFIG_BINFMT_AOUT n
+bool 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
+if [ "$CONFIG_BINFMT_ELF" != "n" ]; then
+   bool '  ELF binaries with a.out format interpreters or a.out libraries' CONFIG_BINFMT_ELF_AOUT
+fi
+dep_bool 'Kernel support for Linux/MIPS 32-bit binary compatibility' CONFIG_MIPS32_COMPAT $CONFIG_MIPS64
+dep_bool 'Kernel support for o32 binaries' CONFIG_MIPS32_O32 $CONFIG_MIPS32_COMPAT
+dep_bool 'Kernel support for n32 binaries' CONFIG_MIPS32_N32 $CONFIG_MIPS32_COMPAT
+if [ "$CONFIG_MIPS32_O32" = "y" -o \
+     "$CONFIG_MIPS32_N32" = "y" ]; then
+   define_bool CONFIG_BINFMT_ELF32 y
+else
+   define_bool CONFIG_BINFMT_ELF32 n
+fi
+
+tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
+bool 'Select task to kill on out of memory condition' CONFIG_OOM_KILLER
+
+bool 'Default bootloader kernel arguments' CONFIG_CMDLINE_BOOL
+if [ "$CONFIG_CMDLINE_BOOL" = "y" ] ; then
+  string 'Initial kernel command string' CONFIG_CMDLINE ""
+fi
+
+if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
+   bool 'Power Management support' CONFIG_PM
+fi
+endmenu
+
+source drivers/mtd/Config.in
+
+source drivers/parport/Config.in
+
+source drivers/pnp/Config.in
+
+source drivers/block/Config.in
+if [ "$CONFIG_BLK_DEV_INITRD" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'MIPS initrd options'
+   bool '  Embed root filesystem ramdisk into the kernel' CONFIG_EMBEDDED_RAMDISK
+   if [ "$CONFIG_EMBEDDED_RAMDISK" = "y" ]; then
+      string '    Filename of gziped ramdisk image' CONFIG_EMBEDDED_RAMDISK_IMAGE ramdisk.gz
+   fi
+   endmenu
+fi
+
+source drivers/md/Config.in
+
+if [ "$CONFIG_NET" = "y" ]; then
+   source net/Config.in
+fi
+
+source drivers/telephony/Config.in
+
+mainmenu_option next_comment
+comment 'ATA/IDE/MFM/RLL support'
+
+tristate 'ATA/IDE/MFM/RLL support' CONFIG_IDE
+
+if [ "$CONFIG_IDE" != "n" ]; then
+   source drivers/ide/Config.in
+else
+   define_bool CONFIG_BLK_DEV_HD n
+fi
+endmenu
+
+mainmenu_option next_comment
+comment 'SCSI support'
+
+tristate 'SCSI support' CONFIG_SCSI
+
+if [ "$CONFIG_SCSI" != "n" ]; then
+   source drivers/scsi/Config.in
+fi
+endmenu
+
+source drivers/message/fusion/Config.in
+
+source drivers/ieee1394/Config.in
+
+if [ "$CONFIG_PCI" = "y" -a "$CONFIG_MIPS32" = "y" ]; then
+   source drivers/message/i2o/Config.in
+fi
+
+if [ "$CONFIG_NET" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Network device support'
+
+   bool 'Network device support' CONFIG_NETDEVICES
+   if [ "$CONFIG_NETDEVICES" = "y" ]; then
+      source drivers/net/Config.in
+      if [ "$CONFIG_ATM" = "y" -o "$CONFIG_ATM" = "m" ]; then
+	 source drivers/atm/Config.in
+      fi
+   fi
+   endmenu
+fi
+
+source net/ax25/Config.in
+
+source net/irda/Config.in
+
+if [ "$CONFIG_NET" != "n" ]; then
+   mainmenu_option next_comment
+   comment 'ISDN subsystem'
+
+   tristate 'ISDN support' CONFIG_ISDN
+   if [ "$CONFIG_ISDN" != "n" ]; then
+      source drivers/isdn/Config.in
+   fi
+   endmenu
+fi
+
+if [ "$CONFIG_ISA" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Old CD-ROM drivers (not SCSI, not IDE)'
+
+   bool 'Support non-SCSI/IDE/ATAPI CDROM drives' CONFIG_CD_NO_IDESCSI
+   if [ "$CONFIG_CD_NO_IDESCSI" != "n" ]; then
+      source drivers/cdrom/Config.in
+   fi
+   endmenu
+fi
+
+#
+# input before char - char/joystick depends on it. As does USB.
+#
+source drivers/input/Config.in
+source drivers/char/Config.in
+
+#source drivers/misc/Config.in
+
+source fs/Config.in
+
+source drivers/media/Config.in
+
+if [ "$CONFIG_VT" = "y" ]; then
+   mainmenu_option next_comment
+   comment 'Console drivers'
+   bool 'VGA text console' CONFIG_VGA_CONSOLE
+   if [ "$CONFIG_SGI_IP22" = "y" ]; then
+      tristate 'SGI Newport Console support' CONFIG_SGI_NEWPORT_CONSOLE
+      if [ "$CONFIG_SGI_NEWPORT_CONSOLE" = "y" ]; then
+         define_bool CONFIG_FONT_8x16 y
+      fi
+      define_bool CONFIG_DUMMY_CONSOLE y
+   fi
+   if [ "$CONFIG_EXPERIMENTAL" = "y" ]; then
+      tristate 'MDA text console (dual-headed) (EXPERIMENTAL)' CONFIG_MDA_CONSOLE
+      source drivers/video/Config.in
+   fi
+   endmenu
+fi
+
+mainmenu_option next_comment
+comment 'Sound'
+
+tristate 'Sound card support' CONFIG_SOUND
+if [ "$CONFIG_SOUND" != "n" ]; then
+   source drivers/sound/Config.in
+fi
+endmenu
+
+source drivers/usb/Config.in
+
+source net/bluetooth/Config.in
+
+mainmenu_option next_comment
+comment 'Kernel hacking'
+
+bool 'Are you using a crosscompiler' CONFIG_CROSSCOMPILE
+bool 'Enable run-time debugging' CONFIG_RUNTIME_DEBUG
+bool 'Remote GDB kernel debugging' CONFIG_KGDB
+dep_bool '  Console output to GDB' CONFIG_GDB_CONSOLE $CONFIG_KGDB
+if [ "$CONFIG_KGDB" = "y" ]; then
+   define_bool CONFIG_DEBUG_INFO y
+else
+   bool 'Debugging symbols' CONFIG_DEBUG_INFO
+fi
+if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
+   dep_bool 'Compile for Corelis Debugger' CONFIG_SB1XXX_CORELIS $CONFIG_DEBUG_INFO
+fi
+bool 'Magic SysRq key' CONFIG_MAGIC_SYSRQ
+if [ "$CONFIG_SMP" != "y" ]; then
+   bool 'Run uncached' CONFIG_MIPS_UNCACHED
+else
+   if [ "$CONFIG_MIPS32" = "y" ]; then
+      int  'Maximum number of CPUs (2-32)' CONFIG_NR_CPUS 32
+   else
+      if [ "$CONFIG_MIPS64" = "y" ]; then
+	 int  'Maximum number of CPUs (2-64)' CONFIG_NR_CPUS 64
+      fi
+   fi
+fi
+
+int 'Kernel messages buffer length shift (0 = default)' CONFIG_LOG_BUF_SHIFT 0
+
+endmenu
+
+source crypto/Config.in
+source lib/Config.in
diff -urN linux-2.4.32/arch/mips/kernel/head.S linux-2.4.32-adm5120/arch/mips/kernel/head.S
--- linux-2.4.32/arch/mips/kernel/head.S	2005-12-20 12:42:57.000000000 +0200
+++ linux-2.4.32-adm5120/arch/mips/kernel/head.S	2005-12-20 12:35:06.000000000 +0200
@@ -27,6 +27,7 @@
 #include <asm/cachectl.h>
 #include <asm/mipsregs.h>
 #include <asm/stackframe.h>
+		__INIT
 
 		.text
 		/*
@@ -39,7 +40,6 @@
 		EXPORT(stext)
 		EXPORT(_stext)
 
-		__INIT
 
 		/* Cache Error */
 		LEAF(except_vec2_generic)
@@ -96,7 +96,7 @@
 		.set	pop
 		END(except_vec_ejtag_debug)
 
-		__FINIT
+//		__FINIT
 
 		/*
 		 * EJTAG debug exception handler.
@@ -129,7 +129,7 @@
 		.set	pop
 		END(ejtag_debug_handler)
 
-		__INIT
+//		__INIT
 
 		/*
 		* NMI debug exception handler for MIPS reference boards.
@@ -142,25 +142,10 @@
 		.set	noreorder
 		j       nmi_handler
 		 nop
+ 		.fill	0xd4 
 		.set	pop
 		END(except_vec_nmi)
 
-		__FINIT
-
-		NESTED(nmi_handler, PT_SIZE, sp)
-		.set	push
-		.set    noat
-		.set    noreorder
-		.set    mips3
-		SAVE_ALL
-		jal     nmi_exception_handler
-		 move   a0, sp
-		RESTORE_ALL
-		eret
-		.set	pop
-		END(nmi_handler)
-
-		__INIT
 
 		/*
 		 * Kernel entry point
@@ -208,6 +193,24 @@
 		END(kernel_entry)
 
 
+//		__FINIT
+
+		NESTED(nmi_handler, PT_SIZE, sp)
+		.set    noat
+		.set    noreorder
+		.set    mips3
+		SAVE_ALL
+		jal     nmi_exception_handler
+		 move   a0, sp
+		RESTORE_ALL
+		eret
+		.set    at
+		.set    mips0
+		END(nmi_handler)
+
+//		__INIT
+
+
 #ifdef CONFIG_SMP
 
 /*
diff -urN linux-2.4.32/arch/mips/kernel/setup.c linux-2.4.32-adm5120/arch/mips/kernel/setup.c
--- linux-2.4.32/arch/mips/kernel/setup.c	2005-12-20 12:42:57.000000000 +0200
+++ linux-2.4.32-adm5120/arch/mips/kernel/setup.c	2005-12-20 12:22:41.000000000 +0200
@@ -494,6 +494,7 @@
 	void hp_setup(void);
 	void au1x00_setup(void);
 	void frame_info_init(void);
+	void am5120_setup(void);
 
 	frame_info_init();
 #if defined(CONFIG_BLK_DEV_FD) || defined(CONFIG_BLK_DEV_FD_MODULE)
@@ -691,6 +692,11 @@
                 pmc_yosemite_setup();
                 break;
 #endif
+#ifdef	CONFIG_MIPS_AM5120
+	case MACH_GROUP_ADM_GW:
+		am5120_setup();
+		break;
+#endif
 	default:
 		panic("Unsupported architecture");
 	}
diff -urN linux-2.4.32/arch/mips/Makefile linux-2.4.32-adm5120/arch/mips/Makefile
--- linux-2.4.32/arch/mips/Makefile	2005-12-20 12:43:19.000000000 +0200
+++ linux-2.4.32-adm5120/arch/mips/Makefile	2005-12-20 12:22:41.000000000 +0200
@@ -198,6 +198,11 @@
 #
 # Board-dependent options and extra files
 #
+ifdef CONFIG_MIPS_AM5120
+LIBS		+= arch/mips/am5120/am5120.o
+SUBDIRS		+= arch/mips/am5120
+LOADADDR	+= 0x80002000
+endif
 
 #
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
diff -urN linux-2.4.32/arch/mips/pci/pci.c linux-2.4.32-adm5120/arch/mips/pci/pci.c
--- linux-2.4.32/arch/mips/pci/pci.c	2005-01-19 16:09:29.000000000 +0200
+++ linux-2.4.32-adm5120/arch/mips/pci/pci.c	2005-12-20 12:22:41.000000000 +0200
@@ -192,13 +192,16 @@
 };
 
 extern int pciauto_assign_resources(int busno, struct pci_channel * hose);
-
+extern int am5120_pci_module;
 void __init pcibios_init(void)
 {
 	struct pci_channel *p;
 	struct pci_bus *bus;
 	int busno;
-
+    
+	if (!am5120_pci_module)
+		return;
+	    
 #ifdef CONFIG_PCI_AUTO
 	/* assign resources */
 	busno=0;
diff -urN linux-2.4.32/Documentation/Configure.help linux-2.4.32-adm5120/Documentation/Configure.help
--- linux-2.4.32/Documentation/Configure.help	2005-12-20 12:43:17.000000000 +0200
+++ linux-2.4.32-adm5120/Documentation/Configure.help	2005-12-20 12:22:41.000000000 +0200
@@ -490,6 +490,40 @@
   "real" root file system, etc. See <file:Documentation/initrd.txt>
   for details.
 
+Gzip compressed RAM disk image support
+CONFIG_BLK_DEV_RAM_GZ
+  This option enables support for gzip compressed ramdisk images.
+  An image can be loaded as initrd (see above) or as a normal
+  ramdisk at boot time.
+  Enabling this option is good for people who use an initrd or
+  a normal ramdisk and who are low on available disk space.
+  The decompression process at boot time needs about 2 MB additional
+  RAM to the space the unpacked ramdisk needs.
+  
+  Due to the fact that this feature is normally included in the
+  original ramdisk, you should say Y to this option.
+  
+Bzip2 compressed RAM disk image support
+CONFIG_BLK_DEV_RAM_BZ
+  This option enables support for bzip2 compressed ramdisk images.
+  An image can be loaded as initrd (see above) or as a normal
+  ramdisk at boot time.
+  Enabling this option is good for people who use an initrd or
+  a normal ramdisk and who are very low on available disk space.
+  This option was implemented, because bzip2 has better compression
+  than gzip. If you want to use this feature and disk space is a
+  matter, say N to gzip support and compress your ramdisk using
+  bzip2.
+  The decompression process at boot time needs about 8 MB additional
+  RAM to the space the unpacked ramdisk needs. So the default ramdisk
+  size should be set to 16384 KB.
+ 
+  For problems and comments mail to Christian Ludwig (cl81@gmx.net).
+  
+  This is an optional feature. Only enable this option if you need
+  bzip2 support for your ramdisk (e.g. for boot+root floppyes). So
+  if you are unsure say N.
+
 Embed root filesystem ramdisk into the kernel
 CONFIG_EMBEDDED_RAMDISK
   Select this option if you want to build the ramdisk image into the
diff -urN linux-2.4.32/drivers/block/Config.in linux-2.4.32-adm5120/drivers/block/Config.in
--- linux-2.4.32/drivers/block/Config.in	2004-08-08 02:26:04.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/block/Config.in	2005-12-20 12:22:41.000000000 +0200
@@ -49,6 +49,8 @@
    int '  Default RAM disk size' CONFIG_BLK_DEV_RAM_SIZE 4096
 fi
 dep_bool '  Initial RAM disk (initrd) support' CONFIG_BLK_DEV_INITRD $CONFIG_BLK_DEV_RAM
+dep_bool '  Gzip compressed RAM disk image support' CONFIG_BLK_DEV_RAM_GZ $CONFIG_BLK_DEV_RAM
+dep_bool '  Bzip2 compressed RAM disk image support' CONFIG_BLK_DEV_RAM_BZ $CONFIG_BLK_DEV_RAM
 
 bool 'Per partition statistics in /proc/partitions' CONFIG_BLK_STATS
 
diff -urN linux-2.4.32/drivers/char/Config.in linux-2.4.32-adm5120/drivers/char/Config.in
--- linux-2.4.32/drivers/char/Config.in	2005-12-20 12:42:57.000000000 +0200
+++ linux-2.4.32-adm5120/drivers/char/Config.in	2005-12-20 12:22:41.000000000 +0200
@@ -35,6 +35,7 @@
 fi
 bool 'Non-standard serial port support' CONFIG_SERIAL_NONSTANDARD
 if [ "$CONFIG_SERIAL_NONSTANDARD" = "y" ]; then
+   bool '  ADM5120 serial port support' CONFIG_SERIAL_5120
    tristate '  Computone IntelliPort Plus serial support' CONFIG_COMPUTONE
    tristate '  Comtrol Rocketport support' CONFIG_ROCKETPORT
    tristate '  Cyclades async mux support' CONFIG_CYCLADES
diff -urN linux-2.4.32/drivers/char/tty_io.c linux-2.4.32-adm5120/drivers/char/tty_io.c
--- linux-2.4.32/drivers/char/tty_io.c	2005-01-19 16:09:53.000000000 +0200
+++ linux-2.4.32-adm5120/drivers/char/tty_io.c	2005-12-20 12:22:42.000000000 +0200
@@ -164,6 +164,8 @@
 extern void sb1250_serial_console_init(void);
 extern void arc_console_init(void);
 extern int hvc_console_init(void);
+extern void serial5120_init(void);
+
 
 #ifndef MIN
 #define MIN(a,b)	((a) < (b) ? (a) : (b))
@@ -2879,4 +2881,7 @@
 #ifdef CONFIG_A2232
 	a2232board_init();
 #endif
+#ifdef CONFIG_SERIAL_5120
+	serial5120_init();
+#endif
 }
diff -urN linux-2.4.32/drivers/mtd/maps/Config.in linux-2.4.32-adm5120/drivers/mtd/maps/Config.in
--- linux-2.4.32/drivers/mtd/maps/Config.in	2005-12-20 12:42:57.000000000 +0200
+++ linux-2.4.32-adm5120/drivers/mtd/maps/Config.in	2005-12-20 12:22:42.000000000 +0200
@@ -111,6 +111,10 @@
    dep_tristate '  Generic uClinux RAM/ROM filesystem support' CONFIG_MTD_UCLINUX $CONFIG_MTD_PARTITIONS
 fi
 
+if [ "$CONFIG_MIPS_AM5120" = "y" ]; then
+   dep_tristate '  MX29LV320B flash device mapped on ADM5120 board' CONFIG_MTD_MX29LV320B $CONFIG_MRD_CFI
+fi   
+
 # This needs CFI or JEDEC, depending on the cards found.
 dep_tristate '  PCI MTD driver' CONFIG_MTD_PCI $CONFIG_MTD $CONFIG_PCI
 dep_tristate '  PCMCIA MTD driver' CONFIG_MTD_PCMCIA $CONFIG_MTD $CONFIG_PCMCIA
diff -urN linux-2.4.32/drivers/mtd/maps/Makefile linux-2.4.32-adm5120/drivers/mtd/maps/Makefile
--- linux-2.4.32/drivers/mtd/maps/Makefile	2005-12-20 12:42:57.000000000 +0200
+++ linux-2.4.32-adm5120/drivers/mtd/maps/Makefile	2005-12-20 12:39:26.000000000 +0200
@@ -68,5 +68,6 @@
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
 obj-$(CONFIG_MTD_MIRAGE)        += mirage-flash.o
+obj-$(CONFIG_MTD_MX29LV320B)	+= mx29lv320b.o
 
 include $(TOPDIR)/Rules.make
diff -urN linux-2.4.32/drivers/mtd/maps/mx29lv320b.c linux-2.4.32-adm5120/drivers/mtd/maps/mx29lv320b.c
--- linux-2.4.32/drivers/mtd/maps/mx29lv320b.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/mtd/maps/mx29lv320b.c	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,139 @@
+/*
+ *  Copyright  2001 Flaga hf. Medical Devices, Kri Davsson <kd@flaga.is>
+ *
+ *  $Id: mx29lv320b.c,v 1.1.1.1 2004/01/05 03:08:58 lance Exp $
+ *  
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * 
+ *
+ *  V1.1  Modified to work in kernel 2.4.31 by Joco (rjoco77@kezdionline.ro)
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/am5120/mx29lv320b.h>
+
+static struct mtd_info *mymtd;
+
+
+__u8 mx29lv320b_read8( struct map_info *map, unsigned long ofs)
+{
+	return __raw_readb(map->map_priv_1 + ofs);
+}
+
+__u16 mx29lv320b_read16( struct map_info *map, unsigned long ofs)
+{
+	return __raw_readw(map->map_priv_1 + ofs);
+}
+
+__u32 mx29lv320b_read32( struct map_info *map, unsigned long ofs)
+{
+	return __raw_readl(map->map_priv_1 + ofs);
+}
+//_raw_readll -> if 64
+
+void mx29lv320b_write8( struct map_info *map, __u8 d, unsigned long adr)
+{
+	__raw_writeb(d, map->map_priv_1 + adr);
+}
+
+void mx29lv320b_write16( struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+}
+
+void mx29lv320b_write32( struct map_info *map, __u32 d, unsigned long adr)
+{
+	__raw_writel(d, map->map_priv_1 + adr);
+}
+
+void mx29lv320b_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+void mx29lv320b_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+struct map_info mx29lv320b_map = {
+		.name =		"MX29LV320B flash device",
+		.size =		FLASH_SIZE,
+		.buswidth = 	2,
+		read8:		mx29lv320b_read8,
+		read16:		mx29lv320b_read16,
+		read32:		mx29lv320b_read32,
+		copy_from:	mx29lv320b_copy_from,
+		write8:		mx29lv320b_write8,
+		write16:	mx29lv320b_write16,
+		write32:	mx29lv320b_write32,
+		copy_to:	mx29lv320b_copy_to
+};
+
+
+int __init init_mx29lv320b(void)
+{	
+	printk(KERN_NOTICE "MX29LV320B flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+	
+	mx29lv320b_map.map_priv_1 = (unsigned long)ioremap_nocache(FLASH_PHYS_ADDR,
+					FLASH_SIZE);
+
+	if (!mx29lv320b_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+
+	mymtd = do_map_probe("cfi_probe", &mx29lv320b_map);
+	if (mymtd) {
+		mymtd->module = THIS_MODULE;
+		add_mtd_partitions(mymtd, mx29lv320b_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "MX29LV320B flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)mx29lv320b_map.map_priv_1);
+	return -ENXIO;
+}
+
+static void __exit cleanup_mx29lv320b(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (mx29lv320b_map.map_priv_1) {
+		iounmap((void *)mx29lv320b_map.map_priv_1);
+		mx29lv320b_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_mx29lv320b);
+module_exit(cleanup_mx29lv320b);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jeanson Hung <jeansonh@admtek.com.tw>");
+MODULE_DESCRIPTION("MTD map driver for MX29Lv320B");
diff -urN linux-2.4.32/drivers/net/adm5120sw.c linux-2.4.32-adm5120/drivers/net/adm5120sw.c
--- linux-2.4.32/drivers/net/adm5120sw.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/adm5120sw.c	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,836 @@
+/*
+ *	ADM5120 ethernet switch driver
+ *	
+ *	Based on original ADMTEK 2.4.18 driver, copyright ADMtek Inc.
+ *	daniel@admtek.com.tw
+ *	
+ *	Port to 2.4.31 kernel and modified to able to load as module
+ *	by Joco, rjoco77@kezdionline.ro
+ *	
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2, or (at your option)
+ *	any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ 
+	
+	V1.0 Successful compile on 2.4.31 as module
+	V1.1 Modify promisc mode to work on bridge mode
+	V1.2 Added module param (vlan_mx) for modify vlan struct and ethernet
+	     interfaces.
+	     ex: vlan_mx="0x41,0x42,0x44,0x48,0x50,0x60"     -> 5 eth
+	         vlan_mx="0x5E,0x41,0,0,0,0"		     -> 2 eth Edimax layout
+	V1.3 Read MAC from Edimax type config partition
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h> 	
+#include <linux/slab.h>		
+#include <linux/errno.h>	
+#include <linux/types.h>
+#include <linux/interrupt.h>
+
+#include <linux/in.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/in6.h>
+
+#include <asm/checksum.h>
+#include "adm5120sw.h"
+
+#define NUM_TX_H_DESC		16	/* Number of the Transmitting descriptors of high priority */
+#define NUM_TX_L_DESC		128	/* Number of the Transmitting descriptors of low priority */
+#define NUM_RX_H_DESC		16	/* Number of the Receiving descriptors of high priority */
+#define NUM_RX_L_DESC		64	/* Number of the Receiving descriptors of low priority */
+
+#define SW_IRQ			9
+
+int adm5120sw_init(struct net_device *dev);
+
+static int unit = 0;
+static int irqEn = 0;
+static int timeout = 5;
+
+PSW_CONTEXT_T sw_context;
+
+static int vlan_mx[] = {0x7F,0,0,0,0,0};
+
+MODULE_PARM(vlan_mx,"6i");
+MODULE_PARM_DESC(vlan_mx, "vlan_mx n,n,.. 6n");
+MODULE_DESCRIPTION("ADM5120 switch ethernet driver");
+MODULE_AUTHOR("Joco (rjoco77@kezdionline.ro)");
+MODULE_LICENSE("GPL");
+
+
+struct net_device adm5120sw_devs[MAX_VLAN_GROUP] = {
+    { name: "eth0", init:adm5120sw_init },
+    { name: "eth1", init:adm5120sw_init },
+    { name: "eth2", init:adm5120sw_init },
+    { name: "eth3", init:adm5120sw_init },
+    { name: "eth4", init:adm5120sw_init },
+    { name: "eth5", init:adm5120sw_init }
+};
+
+int adm5120_get_nrif (char * vlan_matrix)
+{
+    int i,nr = 0;
+    for ( i = 0; i < MAX_VLAN_GROUP; i++)
+	    if (vlan_matrix[i] & 0x40) nr++;
+    return nr;
+}
+
+/* InitTxDesc */
+static void InitTxDesc(PTX_ENG_T pTxEng)
+{
+	int num = pTxEng->numDesc;
+	
+	pTxEng->hwDesc[--num].buf1cntl |= END_OF_RING;
+	pTxEng->idxHead = pTxEng->idxTail = 0;
+}
+
+/* InitRxDesc */
+static void InitRxDesc(PRX_ENG_T pRxEng)
+{
+	PRX_DRV_DESC_T drvDesc = pRxEng->drvDesc;
+	int i;
+	
+	for (i = 0; i < pRxEng->numDesc; i++, drvDesc++)
+	{
+		drvDesc->skb = dev_alloc_skb(DEF_RX_BUF_SIZE+16);
+		if (!drvDesc->skb)
+		{
+			printk("Init rx skb : low on mem\n");
+			return;
+		}
+		skb_reserve(drvDesc->skb, 2); /* align IP on 16B boundary */
+	}
+	
+	drvDesc = pRxEng->drvDesc;
+	
+	for (i = 0; i < pRxEng->numDesc; i++)
+	{
+		pRxEng->hwDesc[i].buf2cntl = pRxEng->hwDesc[i].status = 0;
+		pRxEng->hwDesc[i].buf1len = DEF_RX_BUF_SIZE;
+		pRxEng->hwDesc[i].buf1cntl =
+			((unsigned long)pRxEng->drvDesc[i].skb->data &
+			BUF_ADDR_MASK) | OWN_BIT;
+	}
+	
+	pRxEng->hwDesc[--i].buf1cntl |= END_OF_RING;
+	pRxEng->idx = 0;
+		
+}
+/************** Switch driver init **********************/
+int adm5120swdrv_init (void)
+{
+	int i;
+	char *rxBufPool;
+	
+	/* Allocate the switch driver context */
+	if ((sw_context = (PSW_CONTEXT_T)kmalloc(sizeof(SW_CONTEXT_T), GFP_KERNEL)) == NULL)
+		return (-1);
+	
+	memset((char *)sw_context, 0, sizeof(SW_CONTEXT_T));
+	
+	/* Allocate the Tx/Rx hardware descriptor pool */
+	i = HWDESC_ALIGN + sizeof(RXDESC_T) * (NUM_RX_H_DESC + NUM_RX_L_DESC)
+		+ sizeof(TXDESC_T) * (NUM_TX_H_DESC + NUM_TX_L_DESC);
+	
+	if ((sw_context->hwDescPool = (char *)kmalloc(i, GFP_KERNEL)) == NULL)
+		goto ErrRes;
+		
+	memset(sw_context->hwDescPool, 0, i);
+	
+	/* Allocate the tx driver descriptor */
+	i = sizeof(TX_DRV_DESC_T) * (NUM_TX_H_DESC + NUM_TX_L_DESC);
+	
+	if ((sw_context->txDrvDescPool = (char *)kmalloc(i, GFP_KERNEL)) == NULL)
+		goto ErrRes;
+		
+	memset(sw_context->txDrvDescPool, 0, i);
+	
+	/* Allocate the rx driver descriptor */
+	i = sizeof(RX_DRV_DESC_T) * (NUM_RX_H_DESC + NUM_RX_L_DESC);
+	
+	if ((sw_context->rxDrvDescPool = (char *)kmalloc(i, GFP_KERNEL)) == NULL)
+		goto ErrRes;
+		
+	memset(sw_context->rxDrvDescPool, 0, i);
+	
+	/*
+	 *!! Note: The Hardware Tx/Rx descriptors should be allocated at non-
+		   cached memory and aligned 16 bytes boundry!!!!!
+	 */
+	 
+	/* assign hardware descriptor to txH pool */
+	if (((unsigned long)sw_context->hwDescPool) & (HWDESC_ALIGN - 1))
+	{
+		sw_context->txH.hwDesc = (PTXDESC_T)MIPS_KSEG1A((unsigned long)(sw_context->hwDescPool
+				+ HWDESC_ALIGN - 1) & ~(HWDESC_ALIGN - 1));
+	}
+	else
+		sw_context->txH.hwDesc = (PTXDESC_T)MIPS_KSEG1A(sw_context->hwDescPool);
+	
+	sw_context->txH.numDesc = NUM_TX_H_DESC;
+	sw_context->txH.txTrig = SEND_TRIG_HIGH;
+	InitTxDesc(&sw_context->txH);
+	sw_context->txH.drvDesc = (PTX_DRV_DESC_T)sw_context->txDrvDescPool;
+	
+	/* assign hardware descriptor to txL pool */
+	sw_context->txL.hwDesc = &sw_context->txH.hwDesc[NUM_TX_H_DESC];
+	sw_context->txL.numDesc = NUM_TX_L_DESC;
+	sw_context->txL.txTrig = SEND_TRIG_LOW;
+	InitTxDesc(&sw_context->txL);
+	sw_context->txL.drvDesc = (PTX_DRV_DESC_T)(sw_context->txDrvDescPool +
+		(sizeof(TX_DRV_DESC_T) * NUM_TX_H_DESC));
+		
+	/* assign hardware descriptor to rxH pool */
+	sw_context->rxH.hwDesc = (PRXDESC_T)&sw_context->txL.hwDesc[NUM_TX_L_DESC];
+	sw_context->rxH.numDesc = NUM_RX_H_DESC;
+	sw_context->rxH.drvDesc = (PRX_DRV_DESC_T)sw_context->rxDrvDescPool;
+	InitRxDesc(&sw_context->rxH);
+
+	/* assign hardware descriptor to rxL pool */
+	sw_context->rxL.hwDesc = &sw_context->rxH.hwDesc[NUM_RX_H_DESC];
+	sw_context->rxL.numDesc = NUM_RX_L_DESC;
+	rxBufPool += NUM_RX_H_DESC * RX_BUF_SIZE;
+	sw_context->rxL.drvDesc = (PRX_DRV_DESC_T)(sw_context->rxDrvDescPool +
+				(sizeof(RX_DRV_DESC_T) * NUM_RX_H_DESC));
+	InitRxDesc(&sw_context->rxL);
+	
+	for (i = 0; i < MAX_VLAN_GROUP; i++)
+		sw_context->vlanGrp[i] = vlan_mx[i] & 0x7F;
+	
+	/* disable cpu port, CRC padding from cpu and no send unknown packet
+	   from port0 to port5 to cpu */
+	ADM5120_SW_REG(CPUp_conf_REG) = DEF_CPUPORT_CFG ;
+	
+	/* Disable all port, enable BP & MC */
+	ADM5120_SW_REG(Port_conf0_REG) = DEF_PORTS_CFG;
+	
+	/* Wait until switch enter idle state */
+	for (i = 0 ; i < 500000; i++);
+	
+	/* Put Phys to normal mode */
+	ADM5120_SW_REG(PHY_cntl2_REG) |= SW_PHY_AN_MASK | SW_PHY_NORMAL_MASK;
+	
+	ADM5120_SW_REG(PHY_cntl3_REG) |= 0x400;
+	
+	/* Disable Switch Interrupts */
+	ADM5120_SW_REG(SW_Int_mask_REG) = SWITCH_INT_MASK;
+	
+	/* Clear the Interrupt status */
+	ADM5120_SW_REG(SW_Int_st_REG) = SWITCH_INT_MASK;
+	
+	/* Initialize the adm5120 Desc */
+	ADM5120_SW_REG(Send_HBaddr_REG) = (unsigned long)sw_context->txH.hwDesc;
+	ADM5120_SW_REG(Send_LBaddr_REG) = (unsigned long)sw_context->txL.hwDesc;
+	ADM5120_SW_REG(Recv_HBaddr_REG) = (unsigned long)sw_context->rxH.hwDesc;
+	ADM5120_SW_REG(Recv_LBaddr_REG) = (unsigned long)sw_context->rxL.hwDesc;
+	
+	/* Clear all vlan setting */
+	ADM5120_SW_REG(VLAN_G1_REG) = 0;
+	ADM5120_SW_REG(VLAN_G2_REG) = 0;
+	
+	/* Update link status */
+	sw_context->linkStatus = 0;
+	
+	sw_context->intMask = RX_H_INT | RX_L_INT | TX_H_INT | TX_L_INT;
+	
+	ADM5120_SW_REG(CPUp_conf_REG) &= ~SW_CPU_PORT_DISABLE;
+	
+	spin_lock_init(&sw_context->lock);
+	
+	return (0);
+	
+ErrRes:
+	/* Free all resources */
+	if (sw_context->hwDescPool != NULL)
+		kfree(sw_context->hwDescPool);
+	
+	if (sw_context->txDrvDescPool != NULL)
+		kfree(sw_context->txDrvDescPool);
+		
+	if (sw_context->rxDrvDescPool != NULL);
+		kfree(sw_context->rxDrvDescPool);
+		
+	kfree(sw_context);
+	
+	return (-1);	
+}
+
+/*
+ * ProcessRxInt
+ */
+void ProcessRxInt(PRX_ENG_T rxEng)
+{
+	struct net_device *rdev;
+	PSW_PRIV_T priv = 0;
+	PRXDESC_T rxDesc = 0;
+	PRX_DRV_DESC_T drvDesc = 0;
+	int unit;
+	int srcPort;
+	int idx;
+	int len;
+
+	idx = rxEng->idx;
+	rxDesc = &rxEng->hwDesc[idx];
+	while (!(rxDesc->buf1cntl & OWN_BIT))
+	{ 
+		drvDesc = &rxEng->drvDesc[idx];
+		if (drvDesc->skb == 0)
+			goto get_desc;
+
+		srcPort = (rxDesc->status & RX_SRC_PORT_MASK) >> RX_SRC_PORT_SHIFT;
+    		unit = sw_context->port[srcPort].ifUnit;
+		rdev = &adm5120sw_devs[unit];
+		priv = (PSW_PRIV_T)rdev->priv;
+
+		len = ((rxDesc->status & PKT_LEN_MASK) >> PKT_LEN_SHIFT) - ETH_CRC_LEN;
+		if (len <= 0 || (rxDesc->status & RX_PKT_IPSUM_ERR))
+		{
+			priv->stats.rx_errors++;
+			priv->stats.rx_length_errors++;
+			goto next;
+		}
+		
+		skb_put(drvDesc->skb, len);
+			
+		/* Write metadata, and then pass to the receive level */
+		drvDesc->skb->dev = rdev;
+		drvDesc->skb->protocol = eth_type_trans(drvDesc->skb, rdev);
+		drvDesc->skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
+
+		if (netif_rx(drvDesc->skb) == NET_RX_DROP)
+		{
+			priv->stats.rx_dropped++;
+		}
+		else
+		{
+			rdev->last_rx = jiffies;
+			priv->stats.rx_packets++;
+			priv->stats.rx_bytes += drvDesc->skb->len;
+		}
+
+get_desc:
+
+		drvDesc->skb = dev_alloc_skb(DEF_RX_BUF_SIZE+16);
+
+		if (drvDesc->skb) 
+		{
+			skb_reserve(drvDesc->skb, 2); /* align IP on 16B boundary */
+next:
+			rxDesc->buf2cntl = rxDesc->status = 0;
+			rxDesc->buf1len = DEF_RX_BUF_SIZE;
+			rxDesc->buf1cntl = (rxDesc->buf1cntl & END_OF_RING) | OWN_BIT
+							| (((unsigned long)drvDesc->skb->data)& BUF_ADDR_MASK);
+		}
+		else
+			printk("Init rx skb : low on mem\n");
+			
+		if (++idx == rxEng->numDesc)
+			idx = 0;
+		
+		rxDesc = &rxEng->hwDesc[idx];
+	}
+
+	rxEng->idx = idx;
+
+    return;
+}
+
+
+/*
+ * ProcessTxInt
+ */
+void ProcessTxInt(PTX_ENG_T txEng)
+{
+	PTX_DRV_DESC_T drvDesc;
+	int idx;
+
+	idx = txEng->idxTail;
+
+	while (!(txEng->hwDesc[idx].buf1cntl & OWN_BIT) && (idx != txEng->idxHead))
+	{
+		drvDesc = &txEng->drvDesc[idx];
+		dev_kfree_skb_irq(drvDesc->skb);
+
+		drvDesc->skb = 0;
+
+		if (++idx == txEng->numDesc)
+			idx = 0;
+	}
+
+	txEng->idxTail = idx;
+}
+
+void swdrv_ProcessInt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long intReg;
+	
+	spin_lock(&sw_context->lock);
+	
+	
+	/* disable switch interrupt */
+	ADM5120_SW_REG(SW_Int_mask_REG) |= sw_context->intMask;
+	
+	/* recording the current interrupts in the context. */
+	intReg = ADM5120_SW_REG(SW_Int_st_REG);
+	
+	/* acknowledge  all interrupts */
+	ADM5120_SW_REG(SW_Int_st_REG ) = intReg;
+	
+	/* receive one high priority packet to cpu */
+	if (intReg & RX_H_INT)
+		ProcessRxInt(&sw_context->rxH);
+	
+	/* receive one normal priority packet to cpu */
+	if (intReg & RX_L_INT)
+		ProcessRxInt(&sw_context->rxL);
+	
+	/* transmit one high priority packet to cpu */
+	if (intReg & TX_H_INT)
+		ProcessTxInt(&sw_context->txH);
+		
+	/* transmit one normal priority packet from cpu */
+	if (intReg & TX_L_INT)
+		ProcessTxInt(&sw_context->txL);
+		
+	ADM5120_SW_REG(SW_Int_mask_REG) &= ~sw_context->intMask;
+	
+	spin_unlock(&sw_context->lock);		
+}
+
+static int SetupVLAN(int unit, unsigned long portmask)
+{
+	unsigned long reg, shiftcnt;
+	
+	if (unit < 0 || unit > 6)
+		return -1;
+	
+	if (unit <= 3)
+	{
+		shiftcnt = 8 * unit;
+		reg = ADM5120_SW_REG(VLAN_G1_REG) & ~(VLAN_PORT_MASK << shiftcnt);
+		reg |= (portmask & VLAN_PORT_MASK) << shiftcnt;
+		ADM5120_SW_REG(VLAN_G1_REG) = reg;
+	}
+	else
+	{
+		shiftcnt = 8 * (unit - 4);
+		reg = ADM5120_SW_REG(VLAN_G2_REG) & ~(VLAN_PORT_MASK << shiftcnt);
+		reg |= (portmask & VLAN_PORT_MASK) << shiftcnt;
+		ADM5120_SW_REG(VLAN_G2_REG) = reg;	
+	}
+	
+	return 0;
+}
+
+int ProgramVlanMac(int vlan, char *Mac, int clear)
+{
+	unsigned long Reg0, Reg1;
+	
+	if (vlan < 0 || vlan >= MAX_VLAN_GROUP)
+		return -1;
+		
+	Reg0 = (((unsigned char)Mac[1] << 24) | ((unsigned char)Mac[0] << 16)) | (vlan << SW_MAC_VLANID_SHIFT)
+			| SW_MAC_WRITE | SW_MAC_VLANID_EN;
+	
+	if (!clear)
+		Reg0 |= SW_MAC_AGE_VALID;
+	
+	Reg1 = ((unsigned char)Mac[5] << 24) | ((unsigned char)Mac[4] << 16) |
+		((unsigned char)Mac[3] << 8) | (unsigned char)Mac[2];
+		
+	ADM5120_SW_REG(MAC_wt1_REG) = Reg1;
+	ADM5120_SW_REG(MAC_wt0_REG) = Reg0;
+	
+	while (!(ADM5120_SW_REG(MAC_wt0_REG) & SW_MAC_WRITE_DONE));
+	
+	return 0;
+}
+
+void EnableVlanGroup(int unit, unsigned long vlanGrp)
+{
+	int i;
+	int vlanId = 0x01 << unit;
+	
+	vlanGrp &= SW_DISABLE_PORT_MASK;
+	ADM5120_SW_REG(Port_conf0_REG) &= ~vlanGrp;
+	
+	/* Mark the enabled ports */
+	for (i = 0; i < NUM_IF5120_PORTS; i++)
+	{
+		if (vlanGrp & (0x01 << i))
+		{
+			sw_context->port[i].status = PORT_ENABLED;
+			sw_context->port[i].vlanId = vlanId;
+			sw_context->port[i].ifUnit = unit;
+		}
+	}
+}	
+
+void DisableVlanGroup(int unit, unsigned long vlanGrp)
+{
+	int i;
+	unsigned long reg;
+	
+	vlanGrp &= SW_DISABLE_PORT_MASK;
+	
+	reg = ADM5120_SW_REG(Port_conf0_REG) | vlanGrp;
+	ADM5120_SW_REG(Port_conf0_REG) = reg;
+	
+	/* Mark the disabled ports */
+	for (i = 0; i < NUM_IF5120_PORTS; i++)
+		if (vlanGrp & (0x01<<i))
+			sw_context->port[i].status = PORT_DISABLED;
+}
+
+
+int adm5120sw_open(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	int retval;
+	int unit = priv->unit;
+		
+	/* enable switch irq routine */
+	if (!irqEn)
+	{
+		retval = request_irq(SW_IRQ, swdrv_ProcessInt, SA_SHIRQ,dev->name,dev);
+		
+		if (retval)
+			return -ENODEV;
+			
+		irqEn = 1;
+	}
+		
+	spin_lock(&sw_context->lock);
+	
+	/* setup vlan reg */
+	SetupVLAN(unit, sw_context->vlanGrp[unit]);
+	
+	/* program vlan mac */
+	ProgramVlanMac(unit, dev->dev_addr, SW_MAC_AGE_VALID);
+	
+	/* Enable vlan Group */
+	EnableVlanGroup(unit, (unsigned long)sw_context->vlanGrp[unit]);
+	
+	priv->vlanId = 1 << unit;
+	
+	if (sw_context->actIfCnt == 0)
+	{
+		/* Enable interrupt */
+		ADM5120_SW_REG(SW_Int_mask_REG) = ~sw_context->intMask;
+	}
+	sw_context->actIfCnt++;
+	
+	spin_unlock(&sw_context->lock);
+	
+	dev->irq = SW_IRQ;
+	netif_start_queue(dev);
+	
+	return 0;
+}
+
+
+int adm5120sw_release(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	int unit = priv->unit;
+	
+	netif_stop_queue(dev); /* can't transmit any more */
+	
+	spin_lock(&sw_context->lock);
+	
+	/* Enable vlan Group */
+	DisableVlanGroup(unit, (unsigned long)sw_context->vlanGrp[unit]);
+	
+	if (--sw_context->actIfCnt <= 0)
+	{
+		ADM5120_SW_REG(SW_Int_mask_REG) = SWITCH_INT_MASK;
+	}
+	
+	spin_unlock(&sw_context->lock);
+	
+	return 0;
+}
+
+int adm5120sw_config(struct net_device *dev, struct ifmap *map)
+{
+	/* can't act on a running  interface */
+	if (dev->flags & IFF_UP)
+	return -EBUSY;
+	
+	/* ignore other fields */
+	return 0;
+}
+
+void adm5120sw_set_rx_mode(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	int port = sw_context->vlanGrp[priv->unit] & 0x3F;
+	
+	/* Note do not reorder, GCC is clever about common statements. */
+	if (dev->flags & IFF_PROMISC)
+	{
+//		printk (KERN_NOTICE "%s: Promiscous mode enabled.\n", dev->name);
+/*		If set promisc(Bridge mode) we need to disable te SA so all 
+		data on same vlan will be resend (hub mode)
+		The best way in bridge mode is to set 5 ethernet and put on
+		bridge, disavantage all data will be processed by the bridge.
+		No good, if not set blocking state can't see the bridge mac-s
+*/
+		priv->iflags = IF_PROMISC_MODE;
+		ADM5120_SW_REG(CPUp_conf_REG) &= ~(port  << 9);
+		ADM5120_SW_REG(Port_conf1_REG) |= (port) | (port << 6);//disable sa_learn & blocking state (for bridge)
+	}
+	else
+	{
+//		printk (KERN_NOTICE "%s: Promiscous mode disabled.\n", dev->name);
+		priv->iflags &= ~IF_PROMISC_MODE;
+		ADM5120_SW_REG(CPUp_conf_REG) |= (port  << 9);
+		ADM5120_SW_REG(Port_conf1_REG) &= ~(port ) | ~(port << 6);
+	}
+	
+}
+
+int adm5120sw_set_mac(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = (struct sockaddr *)p;
+	unsigned long flags;
+	spinlock_t *lock = &((PSW_PRIV_T)dev->priv)->lock;
+	
+	spin_lock_irqsave(lock, flags);
+	
+	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
+	
+	spin_unlock_irqrestore(lock, flags);
+	
+	return 0;
+}
+
+
+int adm5120sw_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	unsigned long eflags;
+	PTX_ENG_T txEng;
+	PTXDESC_T hdesc;
+	PTX_DRV_DESC_T drvDesc;
+	unsigned long csum = 0;
+	int len;
+	
+	if (skb == NULL) return 0;
+	
+	spin_lock_irqsave(&priv->lock, eflags);
+	
+	dev->trans_start = jiffies; /* save the timestamp */
+	
+	/* get tx engine */
+	if (priv->priority == IF_TX_PRIORITY_H)
+		txEng = &sw_context->txH;
+	else
+		txEng = &sw_context->txL;
+	
+	/* get check sum flag */
+	if (priv->csum_flags)
+		csum = TX_ADD_IPSUM;
+
+	/* get hardware descriptor */
+	hdesc = &txEng->hwDesc[txEng->idxHead];
+	if (hdesc->buf1cntl & OWN_BIT)
+	{
+		dev_kfree_skb(skb);
+		priv->stats.tx_dropped++;
+		return 0;
+	}
+
+	drvDesc = &txEng->drvDesc[txEng->idxHead];
+	drvDesc->skb = skb;
+	
+	hdesc->buf1cntl = (hdesc->buf1cntl & END_OF_RING) | 
+			(((unsigned long)skb->data & BUF_ADDR_MASK) | OWN_BIT);
+		
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	hdesc->pktcntl = (len << PKT_LEN_SHIFT) | priv->vlanId | csum;
+	hdesc->buf1len = len;
+
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += len;
+
+	if (++txEng->idxHead >= txEng->numDesc)
+		txEng->idxHead = 0;
+
+	ADM5120_SW_REG(Send_trig_REG) = txEng->txTrig;
+	
+	spin_unlock_irqrestore(&priv->lock, eflags);
+	
+	return 0;
+}
+
+int adm5120sw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	return 0;
+}
+
+void adm5120sw_tx_timeout (struct net_device *dev)
+{
+	return;
+}
+
+struct net_device_stats *adm5120sw_stats(struct net_device *dev)
+{
+	PSW_PRIV_T priv = (PSW_PRIV_T)dev->priv;
+	return &priv->stats;
+}
+
+int adm5120sw_change_mtu(struct net_device *dev, int new_mtu)
+{
+	unsigned long flags;
+	spinlock_t *lock = &((PSW_PRIV_T)dev->priv)->lock;
+	
+	/* check ranges */
+	if ((new_mtu < 68) || (new_mtu > 1500))
+		return -EINVAL;
+	
+	spin_lock_irqsave(lock, flags);
+	dev->mtu = new_mtu;
+	spin_unlock_irqrestore(lock, flags);
+	return 0;
+}
+
+int adm5120sw_rebuild_header(struct sk_buff *skb){return 0;}
+
+int adm5120sw_header(struct sk_buff *skb, struct net_device *dev,
+		unsigned short type, void *daddr, void *saddr,
+		unsigned int len)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);
+	
+	eth->h_proto = htons(type);
+	memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest,   daddr ? daddr : dev->dev_addr, dev->addr_len);
+	return (dev->hard_header_len);
+}
+	
+int adm5120sw_init(struct net_device *dev)
+{
+	PSW_PRIV_T priv;
+	
+	/* assign some of the fields */
+	ether_setup(dev);
+	
+	dev->open		= adm5120sw_open;
+	dev->stop		= adm5120sw_release;
+	dev->set_config		= adm5120sw_config;
+	dev->set_multicast_list = adm5120sw_set_rx_mode;
+	dev->set_mac_address	= adm5120sw_set_mac;
+	dev->hard_start_xmit	= adm5120sw_tx;
+	dev->do_ioctl		= adm5120sw_ioctl;
+	dev->get_stats		= adm5120sw_stats;
+	dev->change_mtu		= adm5120sw_change_mtu;
+	dev->rebuild_header	= adm5120sw_rebuild_header;
+	dev->hard_header	= adm5120sw_header;
+	dev->tx_timeout		= adm5120sw_tx_timeout;
+	dev->watchdog_timeo	= timeout;
+	
+	set_bit(__LINK_STATE_PRESENT, &dev->state);
+	
+	/*
+	 * Then, allocate the priv field. This encloses the statistics
+	 * and few private fields.
+	 */
+	dev->priv = kmalloc(sizeof(SW_PRIV_T), GFP_KERNEL);
+	if (dev->priv == NULL)
+		return (-ENOMEM);
+		
+	memset(dev->priv, 0, sizeof(SW_PRIV_T));
+	
+	priv = (PSW_PRIV_T)dev->priv;
+	priv->unit = unit++;
+	
+	spin_lock_init(&priv->lock);
+	
+	return 0;
+}
+
+static int __init adm5120switch_init (void)
+{
+	int result, i, device_present = 0;
+	BOARD_CFG_T boardCfg = {0};
+	
+	printk("ADM5120 Switch Module Init V1.3\n");
+	if (adm5120swdrv_init() != 0)
+		return (-ENODEV);
+		
+	sw_context->nr_if = adm5120_get_nrif(sw_context->vlanGrp);
+
+	memcpy((char *)&boardCfg, (char *)PA2VA(ADM5120SW_BOARD_CFG_ADDR), sizeof (boardCfg));
+	if (boardCfg.macmagic != MAC_MAGIC)
+	{
+	    printk("ADM5120 Config partition invalid, using default,");
+	    memmove(&boardCfg.mac[0][0], ADM5120SW_DEFAULT_MAC , 6);
+	}
+	printk("ADM5120 MAC: %02X:%02X:%02X:%02X:%02X:%02X\n",
+		    boardCfg.mac[0][0],boardCfg.mac[0][1],
+		    boardCfg.mac[0][2],boardCfg.mac[0][3],
+		    boardCfg.mac[0][4],boardCfg.mac[0][5]);
+	
+	for (i = 0; i < sw_context->nr_if; i++) {
+	    memcpy( adm5120sw_devs[i].dev_addr, &boardCfg.mac[0][0], 6);
+	    adm5120sw_devs[i].dev_addr[5] += i;
+	    
+	    if ((result = register_netdev(adm5120sw_devs + i ))) {
+		printk("am5120sw: error %i registering device \"%s\"\n",
+		    result, adm5120sw_devs[i].name);
+	    } else
+		device_present++;
+	}
+	
+	if (device_present != sw_context->nr_if)
+	    return (-ENODEV);
+	    
+	return 0;
+		
+}
+
+static void __exit adm5120switch_cleanup(void)
+{
+	int i;
+	
+	for ( i = 0; i < sw_context->nr_if; i++)
+	{
+	    kfree(adm5120sw_devs[i].priv);
+	    unregister_netdev(adm5120sw_devs + i);
+	}
+}
+
+module_init(adm5120switch_init);
+module_exit(adm5120switch_cleanup);
+
+/*
+  Compile:
+  mipsel-linux-gcc -D__KERNEL__ -I/devel/sc/edilinux/linux-2.4.31/include \
+  -Wall -Wstrict-prototypes -Wno-trigraphs -O2 -fno-strict-aliasing -fno-common \
+  -fomit-frame-pointer -I /devel/sc/edilinux/linux-2.4.31/include/asm/gcc -G 0 \
+  -mno-abicalls -fno-pic -pipe  -finline-limit=100000 -march=r4600 -mips2 \
+  -Wa,-32 -Wa,-march=r4600 -Wa,-mips3 -Wa,--trap -DMODULE -mlong-calls  \
+  -nostdinc -iwithprefix include -DKBUILD_BASENAME=adm5120sw  -DEXPORT_SYMTAB \
+  -c adm5120sw.c
+*/
+
diff -urN linux-2.4.32/drivers/net/adm5120sw.h linux-2.4.32-adm5120/drivers/net/adm5120sw.h
--- linux-2.4.32/drivers/net/adm5120sw.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/adm5120sw.h	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,285 @@
+/*
+ *	ADM5120 ethernet switch driver
+ *	
+ *	Based on original ADMTEK 2.4.18 driver, copyright ADMtek Inc.
+ *	daniel@admtek.com.tw
+ *	
+ *	Port to 2.4.31 kernel and modified to able to load as module
+ *	by Joco, rjoco77@kezdionline.ro
+ *	
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2, or (at your option)
+ *	any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	
+ */
+
+#ifndef __ADM5120SW_H__
+#define __ADM5120SW_H__
+
+#include <asm/am5120/adm5120.h>
+
+/********************* MII Phy Reg Access ********************/
+#define PHY_ADDR_MASK			0x0000000F
+#define PHY_REG_MASK			0x00001F00
+#define PHY_WRITE_CMD			0x00002000
+#define PHY_READ_CMD			0x00004000
+
+#define PHY_REG_SHIFT			8
+
+#define PHY_WRITE_OK			0x00000001
+#define PHY_READ_OK			0x00000002
+#define PHY_DATA_MASK			0xFFFF0000
+#define PHY_DATA_SHIFT			16
+
+#define MII_PHY_CTRL_REG		0
+#define MII_PHY_STATUS_REG		1
+#define MII_PHY_ID0_REG			2
+#define MII_PHY_ID1_REG			3
+#define MII_PHY_ANAR_REG		4
+#define MII_PHY_ANLPAR_REG		5
+#define MII_PHY_LINK_REG		0x10
+
+#define MII_PHY_FORCE_LINK		0x03
+
+/*************** VLAN *****************/
+#define MAX_VLAN_GROUP			6
+#define VLAN_PORT_MASK			0x7f
+
+// Vlan status
+#define VLAN_NOT_DEFINED		0
+#define VLAN_DISABLED			1
+#define VLAN_ENABLED			2
+
+#define VLAN_NONE			0x00
+#define VLAN0_ID			0x01
+#define VLAN1_ID			0x02
+#define VLAN2_ID			0x04
+#define VLAN3_ID			0x08
+
+/***************** Tx/Rx Desc **********************/
+#define HWDESC_ALIGN			16
+
+//Common
+#define OWN_BIT				0x80000000
+#define END_OF_RING			0x10000000
+#define BUF_ADDR_MASK			0x00FFFFFF
+#define BUF2_EN				0x80000000
+
+#define BUF1_LEN_MASK			0x000007FF
+#define PKT_LEN_MASK			0x07FF0000
+#define PKT_LEN_SHIFT			16
+
+// RxDesc Only
+#define RX_SRC_PORT_MASK		0x00007000
+#define RX_SRC_PORT_SHIFT		12
+
+#define RX_FRAME_TYPE_MASK		0x00000030
+#define RX_FRAME_UC			0
+#define RX_FRAME_MC			0x00000010
+#define RX_FRAME_BC			0x00000020
+
+#define RX_PKT_IPSUM_ERR		0x00000008
+#define RX_PKT_VLAN_TAG			0x00000004
+
+#define RX_PKT_TYPE_MASK		0x00000003
+#define RX_PKT_IP			0x00000000
+#define RX_PKT_PPPOE			0x00000001
+
+#define RX_PKT_FLAG_MASK		0x0000007F
+
+// TxDesc Only
+#define TX_ADD_IPSUM			0x80000000
+#define TX_DEST_VLAN_MASK		0x0000003F
+#define TX_DEST_PORT_MASK		0x00003F00
+/******************* Interrupts *********************/
+#define RX_H_INT			(RX_H_DONE_INT | RX_H_DESC_FULL_INT)
+#define RX_L_INT			(RX_L_DONE_INT | RX_L_DESC_FULL_INT)
+#define TX_H_INT			SEND_H_DONE_INT
+#define TX_L_INT			SEND_L_DONE_INT
+#define LINK_INT			PORT_STATUS_CHANGE_INT
+
+#define PORT_INT			PORT_STATUS_CHANGE_INT
+#define WATCHDOG0_INT			WATCHDOG0_EXPR_INT
+#define WATCHDOG1_INT			WATCHDOG1_EXPR_INT
+
+/******************* Switch ports *****************/
+#define CPU_PORT			6
+#define CPU_PORT_MASK			(0x1 << CPU_PORT)
+#define GMII_PORT			5
+#define IF5120_LAST_PORT		GMII_PORT
+#define NUM_IF5120_PORTS		(IF5120_LAST_PORT+1)  //Excluding the cpu port
+#define IF5120_PORT_MASK		0x3f
+#define PORT_VLAN_MASK			0x3f
+#define IF5120_PORT_NUM			7
+
+/* Port status */
+#define PORT_DISABLED			0
+#define PORT_ENABLED			1
+
+/************************ Switch config ***************************/
+#define DEF_CPUPORT_CFG			(SW_CPU_PORT_DISABLE | SW_PADING_CRC | SW_DIS_UN_MASK)
+#define DEF_PORTS_CFG			(SW_EN_BP_MASK | SW_EN_MC_MASK | SW_DISABLE_PORT_MASK)
+
+/***********************************************************/
+#define ETH_MAC_LEN			6
+#define ETH_VLANTAG_LEN			4
+#define ETH_CRC_LEN			4		// Ethernet CRC Length
+
+#define TX_SMALL_BUF_SIZE		256
+#define TX_LARGE_BUF_SIZE		1536
+#define TX_BUF_SIZE			1536
+
+#define RX_BUF_SIZE			1680
+#define RX_BUF_REV_SIZE			130
+#define DEF_RX_BUF_SIZE			(RX_BUF_SIZE - RX_BUF_REV_SIZE)
+
+#define SMALL_PKT_LEN			TX_SMALL_BUF_SIZE
+#define MAX_PKT_LEN			1514
+
+#define MIN_ETH_FRAME_LEN		60
+
+/****************** PSEUDO-NIC Control Flags ********************/
+#define IF_TX_PRIORITY_H		0x0001
+#define IF_PROMISC_MODE			0x0002
+#define IF_ATTACH_BRIDGE		0x0010
+#define IF_BRIDGE_HOSTIF		0x0020
+#define IF_CTRL_FLAG_MASK		0x0033
+#define IF_MAC_ALIAS			0x0100
+
+/**************************************************************/
+#define MEM_KSEG0_BASE			0x80000000
+#define MEM_KSEG1_BASE			0xA0000000
+#define MEM_SEG_MASK			0xE0000000
+#define KVA2PA(_addr)			((unsigned long)(_addr) & ~MEM_SEG_MASK)
+
+#define MIPS_KSEG0A(_addr)		(KVA2PA(_addr) | MEM_KSEG0_BASE)
+#define MIPS_KSEG1A(_addr)		(KVA2PA(_addr) | MEM_KSEG1_BASE)
+
+#define PA2VA(_addr)			(KVA2PA(_addr) | MEM_KSEG1_BASE)
+#define PA2CACHEVA(_addr)		(KVA2PA(_addr) | MEM_KSEG0_BASE)
+
+#define ADM5120SW_BOARD_CFG_ADDR	0x1FC08000
+#define ADM5120SW_DEFAULT_MAC		"\x00\x11\x22\x33\x44\x55"
+
+/* tx driver descriptor */
+typedef struct adm5120sw_tx_drv_desc_s
+{
+	struct sk_buff *skb;
+} TX_DRV_DESC_T, *PTX_DRV_DESC_T;
+
+/* rx driver descriptor */
+typedef struct adm5120sw_rx_drv_desc_s
+{
+	struct sk_buff *skb;
+} RX_DRV_DESC_T, *PRX_DRV_DESC_T;
+
+/* tx descriptor */
+typedef struct adm5120sw_tx_desc_s
+{
+	unsigned long buf1cntl;
+	unsigned long buf2cntl;
+	unsigned long buf1len;
+	unsigned long pktcntl;
+} TXDESC_T, *PTXDESC_T;
+
+/* rx descriptor */
+typedef struct adm5120sw_rx_desc_s
+{
+	unsigned long buf1cntl;
+	unsigned long buf2cntl;
+	unsigned long buf1len;
+	unsigned long status;
+} RXDESC_T, *PRXDESC_T;
+
+/* Rx engine */
+typedef struct adm5120sw_rx_eng_s
+{
+	PRXDESC_T hwDesc;
+	PRX_DRV_DESC_T drvDesc;
+	int numDesc;
+	int idx;
+} RX_ENG_T, *PRX_ENG_T;
+
+/* Tx engine */
+typedef struct adm5120sw_tx_eng_s
+{
+	PTXDESC_T hwDesc;
+	PTX_DRV_DESC_T drvDesc;
+	int numDesc;
+	int idxHead;
+	int idxTail;
+	unsigned long txTrig;
+} TX_ENG_T, *PTX_ENG_T;
+
+/* port status */
+typedef struct port_status_s
+{
+	unsigned long status;
+	unsigned long vlanId;
+	unsigned long ifUnit;
+} PORT_CFG_T, *PPORT_CFG_T;
+
+typedef struct adm5120sw_context_s {
+	TX_ENG_T txH, txL;
+	RX_ENG_T rxH, rxL;
+	
+	PORT_CFG_T port[NUM_IF5120_PORTS];
+	
+	/* Vlan group of IF unit */
+//	unsigned long vlanGrp[MAX_VLAN_GROUP];
+	unsigned char vlanGrp[MAX_VLAN_GROUP];
+	unsigned char nr_if;
+	
+	unsigned long intMask;
+	unsigned long intStatus;
+	unsigned long linkStatus;
+	
+	int ifCnt;
+	int actIfCnt;
+	
+	/* tx drv descriptor pool */
+	unsigned char *txDrvDescPool;
+	
+	/* rx drv descriptor pool */
+	unsigned char *rxDrvDescPool;
+	
+	/* Hardware descriptor pool */
+	unsigned char *hwDescPool;
+	
+	spinlock_t lock;
+
+} SW_CONTEXT_T, *PSW_CONTEXT_T;
+
+/* net device private data */
+typedef struct adm5120sw_priv_s
+{
+	struct net_device_stats stats;
+	
+	spinlock_t lock;
+	
+	/* interface unit */
+	int unit;
+	
+	int status;
+	int priority;
+	int csum_flags;
+	
+	/* interface flags */
+	int iflags;
+	
+	/* for fill tx descriptor */
+	unsigned long vlanId;
+	
+} SW_PRIV_T, *PSW_PRIV_T;
+
+#endif
+
diff -urN linux-2.4.32/drivers/net/Config.in linux-2.4.32-adm5120/drivers/net/Config.in
--- linux-2.4.32/drivers/net/Config.in	2005-12-20 12:43:17.000000000 +0200
+++ linux-2.4.32-adm5120/drivers/net/Config.in	2005-12-20 12:22:42.000000000 +0200
@@ -77,6 +77,9 @@
          bool '   Broadcom 5222 Dual Phy Support' CONFIG_BCM5222_DUAL_PHY
       fi
    fi
+   if [ "$CONFIG_MIPS_AM5120" = "y" ]; then
+      tristate '  MIPS ADM5120 Switch support' CONFIG_MIPS_ADM5120_SW
+   fi
    if [ "$CONFIG_SGI_IP27" = "y" ]; then
       bool '  SGI IOC3 Ethernet' CONFIG_SGI_IOC3_ETH
    fi
  linux-2.4.32/drivers/net/hamradio/soundmodem/gentbl  linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/gentbl 
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk1200.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk1200.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk1200.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk1200.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * small cosine table in U8 format
+ */
+#define OFFSCOSTABBITS 6
+#define OFFSCOSTABSIZE (1<<OFFSCOSTABBITS)
+
+static unsigned char offscostab[OFFSCOSTABSIZE] = {
+	 255, 254, 252, 249, 245, 240, 233, 226,
+	 217, 208, 198, 187, 176, 164, 152, 140,
+	 128, 115, 103,  91,  79,  68,  57,  47,
+	  38,  29,  22,  15,  10,   6,   3,   1,
+	   1,   1,   3,   6,  10,  15,  22,  29,
+	  38,  47,  57,  68,  79,  91, 103, 115,
+	 127, 140, 152, 164, 176, 187, 198, 208,
+	 217, 226, 233, 240, 245, 249, 252, 254
+};
+
+#define OFFSCOS(x) offscostab[((x)>>10)&0x3f]
+
+
+/*
+ * more accurate cosine table
+ */
+
+static const short costab[64] = {
+	 32767,  32609,  32137,  31356,  30272,  28897,  27244,  25329, 
+	 23169,  20787,  18204,  15446,  12539,   9511,   6392,   3211, 
+	     0,  -3211,  -6392,  -9511, -12539, -15446, -18204, -20787, 
+	-23169, -25329, -27244, -28897, -30272, -31356, -32137, -32609, 
+	-32767, -32609, -32137, -31356, -30272, -28897, -27244, -25329, 
+	-23169, -20787, -18204, -15446, -12539,  -9511,  -6392,  -3211, 
+	     0,   3211,   6392,   9511,  12539,  15446,  18204,  20787, 
+	 23169,  25329,  27244,  28897,  30272,  31356,  32137,  32609
+};
+
+#define COS(x) costab[((x)>>10)&0x3f]
+#define SIN(x) COS((x)+0xc000)
+
+
+/*
+ * afsk1200 specific tables
+ */
+#define AFSK12_SAMPLE_RATE 9600
+#define AFSK12_TX_FREQ_LO 1200
+#define AFSK12_TX_FREQ_HI 2200
+#define AFSK12_CORRLEN 8
+
+static const int afsk12_tx_lo_i[] = {
+	  127,   89,    0,  -89, -127,  -89,    0,   89 
+};
+#define SUM_AFSK12_TX_LO_I 0
+
+static const int afsk12_tx_lo_q[] = {
+	    0,   89,  127,   89,    0,  -89, -127,  -89 
+};
+#define SUM_AFSK12_TX_LO_Q 0
+
+static const int afsk12_tx_hi_i[] = {
+	  127,   16, -122,  -48,  109,   77,  -89, -100 
+};
+#define SUM_AFSK12_TX_HI_I -30
+
+static const int afsk12_tx_hi_q[] = {
+	    0,  125,   32, -117,  -63,  100,   89,  -77 
+};
+#define SUM_AFSK12_TX_HI_Q 89
+
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_7.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_7.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_7.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_7.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * small cosine table in U8 format
+ */
+#define OFFSCOSTABBITS 6
+#define OFFSCOSTABSIZE (1<<OFFSCOSTABBITS)
+
+static unsigned char offscostab[OFFSCOSTABSIZE] = {
+	 255, 254, 252, 249, 245, 240, 233, 226,
+	 217, 208, 198, 187, 176, 164, 152, 140,
+	 128, 115, 103,  91,  79,  68,  57,  47,
+	  38,  29,  22,  15,  10,   6,   3,   1,
+	   1,   1,   3,   6,  10,  15,  22,  29,
+	  38,  47,  57,  68,  79,  91, 103, 115,
+	 127, 140, 152, 164, 176, 187, 198, 208,
+	 217, 226, 233, 240, 245, 249, 252, 254
+};
+
+#define OFFSCOS(x) offscostab[((x)>>10)&0x3f]
+
+
+/*
+ * more accurate cosine table
+ */
+
+static const short costab[64] = {
+	 32767,  32609,  32137,  31356,  30272,  28897,  27244,  25329, 
+	 23169,  20787,  18204,  15446,  12539,   9511,   6392,   3211, 
+	     0,  -3211,  -6392,  -9511, -12539, -15446, -18204, -20787, 
+	-23169, -25329, -27244, -28897, -30272, -31356, -32137, -32609, 
+	-32767, -32609, -32137, -31356, -30272, -28897, -27244, -25329, 
+	-23169, -20787, -18204, -15446, -12539,  -9511,  -6392,  -3211, 
+	     0,   3211,   6392,   9511,  12539,  15446,  18204,  20787, 
+	 23169,  25329,  27244,  28897,  30272,  31356,  32137,  32609
+};
+
+#define COS(x) costab[((x)>>10)&0x3f]
+#define SIN(x) COS((x)+0xc000)
+
+
+/*
+ * afsk2400 specific tables (tcm3105 clk 7372800.000000Hz)
+ */
+#define AFSK24_TX_FREQ_LO 1995
+#define AFSK24_TX_FREQ_HI 3658
+#define AFSK24_BITPLL_INC 9830
+#define AFSK24_SAMPLERATE 16000
+
+static const int afsk24_tx_lo_i[] = {
+	   10,   11,    0,  -43,  -89,  -80,   -1,   87,  112,   64,    0,  -24,  -16,   -7 
+};
+#define SUM_AFSK24_TX_LO_I 24
+
+static const int afsk24_tx_lo_q[] = {
+	    0,   11,   35,   43,    0,  -78, -125,  -89,   -1,   62,   61,   25,    0,   -7 
+};
+#define SUM_AFSK24_TX_LO_Q -63
+
+static const int afsk24_tx_hi_i[] = {
+	   10,    2,  -34,  -24,   76,   69,  -86, -101,   53,   83,  -14,  -35,    0,   10 
+};
+#define SUM_AFSK24_TX_HI_I 9
+
+static const int afsk24_tx_hi_q[] = {
+	    0,   16,    9,  -56,  -45,   88,   90,  -74,  -98,   31,   59,   -3,  -16,   -1 
+};
+#define SUM_AFSK24_TX_HI_Q 0
+
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_8.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_8.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_8.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk2400_8.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * small cosine table in U8 format
+ */
+#define OFFSCOSTABBITS 6
+#define OFFSCOSTABSIZE (1<<OFFSCOSTABBITS)
+
+static unsigned char offscostab[OFFSCOSTABSIZE] = {
+	 255, 254, 252, 249, 245, 240, 233, 226,
+	 217, 208, 198, 187, 176, 164, 152, 140,
+	 128, 115, 103,  91,  79,  68,  57,  47,
+	  38,  29,  22,  15,  10,   6,   3,   1,
+	   1,   1,   3,   6,  10,  15,  22,  29,
+	  38,  47,  57,  68,  79,  91, 103, 115,
+	 127, 140, 152, 164, 176, 187, 198, 208,
+	 217, 226, 233, 240, 245, 249, 252, 254
+};
+
+#define OFFSCOS(x) offscostab[((x)>>10)&0x3f]
+
+
+/*
+ * more accurate cosine table
+ */
+
+static const short costab[64] = {
+	 32767,  32609,  32137,  31356,  30272,  28897,  27244,  25329, 
+	 23169,  20787,  18204,  15446,  12539,   9511,   6392,   3211, 
+	     0,  -3211,  -6392,  -9511, -12539, -15446, -18204, -20787, 
+	-23169, -25329, -27244, -28897, -30272, -31356, -32137, -32609, 
+	-32767, -32609, -32137, -31356, -30272, -28897, -27244, -25329, 
+	-23169, -20787, -18204, -15446, -12539,  -9511,  -6392,  -3211, 
+	     0,   3211,   6392,   9511,  12539,  15446,  18204,  20787, 
+	 23169,  25329,  27244,  28897,  30272,  31356,  32137,  32609
+};
+
+#define COS(x) costab[((x)>>10)&0x3f]
+#define SIN(x) COS((x)+0xc000)
+
+
+/*
+ * afsk2400 specific tables (tcm3105 clk 8000000.000000Hz)
+ */
+#define AFSK24_TX_FREQ_LO 2165
+#define AFSK24_TX_FREQ_HI 3970
+#define AFSK24_BITPLL_INC 9830
+#define AFSK24_SAMPLERATE 16000
+
+static const int afsk24_tx_lo_i[] = {
+	   10,   11,   -4,  -51,  -86,  -49,   47,  118,   97,   17,  -37,  -35,  -11,    0 
+};
+#define SUM_AFSK24_TX_LO_I 27
+
+static const int afsk24_tx_lo_q[] = {
+	    0,   12,   35,   34,  -22, -100, -115,  -40,   55,   87,   48,    2,  -11,  -10 
+};
+#define SUM_AFSK24_TX_LO_Q -25
+
+static const int afsk24_tx_hi_i[] = {
+	   10,    0,  -35,   -2,   89,    6, -124,  -10,  111,    9,  -61,   -4,   16,    1 
+};
+#define SUM_AFSK24_TX_HI_I 6
+
+static const int afsk24_tx_hi_q[] = {
+	    0,   16,    0,  -61,   -4,  112,    8, -124,  -10,   88,    7,  -35,   -2,   10 
+};
+#define SUM_AFSK24_TX_HI_Q 5
+
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk2666.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk2666.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_afsk2666.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_afsk2666.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * small cosine table in U8 format
+ */
+#define OFFSCOSTABBITS 6
+#define OFFSCOSTABSIZE (1<<OFFSCOSTABBITS)
+
+static unsigned char offscostab[OFFSCOSTABSIZE] = {
+	 255, 254, 252, 249, 245, 240, 233, 226,
+	 217, 208, 198, 187, 176, 164, 152, 140,
+	 128, 115, 103,  91,  79,  68,  57,  47,
+	  38,  29,  22,  15,  10,   6,   3,   1,
+	   1,   1,   3,   6,  10,  15,  22,  29,
+	  38,  47,  57,  68,  79,  91, 103, 115,
+	 127, 140, 152, 164, 176, 187, 198, 208,
+	 217, 226, 233, 240, 245, 249, 252, 254
+};
+
+#define OFFSCOS(x) offscostab[((x)>>10)&0x3f]
+
+
+/*
+ * more accurate cosine table
+ */
+
+static const short costab[64] = {
+	 32767,  32609,  32137,  31356,  30272,  28897,  27244,  25329, 
+	 23169,  20787,  18204,  15446,  12539,   9511,   6392,   3211, 
+	     0,  -3211,  -6392,  -9511, -12539, -15446, -18204, -20787, 
+	-23169, -25329, -27244, -28897, -30272, -31356, -32137, -32609, 
+	-32767, -32609, -32137, -31356, -30272, -28897, -27244, -25329, 
+	-23169, -20787, -18204, -15446, -12539,  -9511,  -6392,  -3211, 
+	     0,   3211,   6392,   9511,  12539,  15446,  18204,  20787, 
+	 23169,  25329,  27244,  28897,  30272,  31356,  32137,  32609
+};
+
+#define COS(x) costab[((x)>>10)&0x3f]
+#define SIN(x) COS((x)+0xc000)
+
+
+/*
+ * afsk2666 specific tables
+ */
+#define AFSK26_DEMCORRLEN 12
+#define AFSK26_SAMPLERATE 16000
+
+static const unsigned int afsk26_carfreq[2] = { 0x2000, 0x3555 };
+
+
+static const struct {
+	int i[12];
+	int q[12];
+} afsk26_dem_tables[2][2] = {
+	{
+		{{      1,      7,    -18,    -73,   -100,    -47,     47,    100,     73,     18,     -7,     -1 }, {      0,     17,     43,     30,    -41,   -115,   -115,    -41,     30,     43,     17,      0 }},
+#define AFSK26_DEM_SUM_I_0_0 0
+#define AFSK26_DEM_SUM_Q_0_0 -132
+		{{      1,     -7,    -46,    -10,    100,     76,    -75,   -100,     10,     46,      7,     -1 }, {      1,     17,     -6,    -79,    -41,     99,     99,    -41,    -79,     -6,     17,      1 }}
+#define AFSK26_DEM_SUM_I_0_1 1
+#define AFSK26_DEM_SUM_Q_0_1 -18
+	},
+	{
+		{{      8,     22,      0,    -67,   -118,    -89,      0,     67,     63,     22,      0,      0 }, {      0,     22,     63,     67,      0,    -89,   -118,    -67,      0,     22,      8,      0 }},
+#define AFSK26_DEM_SUM_I_1_0 -92
+#define AFSK26_DEM_SUM_Q_1_0 -92
+		{{      8,      8,    -54,    -67,     59,    122,      0,    -91,    -31,     22,      7,      0 }, {      0,     30,     31,    -67,   -102,     32,    118,     24,    -54,    -22,      4,      0 }}
+#define AFSK26_DEM_SUM_I_1_1 -17
+#define AFSK26_DEM_SUM_Q_1_1 -6
+	}
+};
+
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_fsk9600.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_fsk9600.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_fsk9600.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_fsk9600.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,302 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * fsk9600 specific tables
+ */
+static unsigned char fsk96_txfilt_4[] = {
+	  37,  37,  35,  36,  39,  40,  38,  38,
+	  53,  53,  51,  52,  55,  56,  54,  54,
+	 210, 210, 208, 209, 212, 213, 211, 211,
+	 226, 226, 224, 225, 228, 229, 227, 227,
+	  23,  23,  22,  22,  26,  26,  24,  24,
+	  39,  39,  38,  38,  42,  42,  40,  40,
+	 196, 196, 195, 195, 199, 199, 197, 197,
+	 212, 212, 211, 211, 215, 215, 213, 213,
+	  43,  43,  42,  42,  46,  46,  44,  44,
+	  59,  59,  58,  58,  62,  62,  60,  60,
+	 216, 216, 215, 215, 219, 219, 217, 217,
+	 232, 232, 231, 231, 235, 235, 233, 233,
+	  29,  29,  28,  28,  32,  32,  30,  30,
+	  45,  45,  44,  44,  48,  48,  46,  46,
+	 202, 202, 201, 201, 205, 205, 203, 203,
+	 218, 218, 217, 217, 221, 221, 219, 219,
+	  36,  36,  34,  34,  38,  38,  37,  37,
+	  52,  52,  50,  50,  54,  54,  53,  53,
+	 209, 209, 207, 207, 211, 211, 210, 210,
+	 225, 225, 223, 223, 227, 227, 226, 226,
+	  22,  22,  20,  20,  24,  24,  23,  23,
+	  38,  38,  36,  36,  40,  40,  39,  39,
+	 195, 195, 193, 193, 197, 197, 196, 196,
+	 211, 211, 209, 209, 213, 213, 212, 212,
+	  42,  42,  40,  40,  44,  44,  43,  43,
+	  58,  58,  56,  56,  60,  60,  59,  59,
+	 215, 215, 213, 213, 217, 217, 216, 216,
+	 231, 231, 229, 229, 233, 233, 232, 232,
+	  28,  28,  26,  27,  30,  31,  29,  29,
+	  44,  44,  42,  43,  46,  47,  45,  45,
+	 201, 201, 199, 200, 203, 204, 202, 202,
+	 217, 217, 215, 216, 219, 220, 218, 218,
+	  37,  37,  37,  37,  29,  29,  29,  30,
+	 108, 108, 108, 108, 100, 100, 100, 100,
+	 169, 169, 169, 170, 161, 161, 162, 162,
+	 240, 240, 240, 240, 232, 232, 232, 232,
+	  19,  19,  19,  20,  11,  11,  12,  12,
+	  90,  90,  90,  90,  82,  82,  82,  82,
+	 151, 151, 152, 152, 143, 143, 144, 144,
+	 222, 222, 222, 222, 214, 214, 215, 215,
+	  41,  41,  41,  41,  33,  33,  33,  34,
+	 112, 112, 112, 112, 104, 104, 104, 104,
+	 173, 173, 173, 174, 165, 165, 166, 166,
+	 244, 244, 244, 244, 236, 236, 236, 236,
+	  23,  23,  23,  24,  15,  15,  16,  16,
+	  94,  94,  94,  94,  86,  86,  86,  86,
+	 155, 155, 156, 156, 147, 147, 148, 148,
+	 226, 226, 226, 226, 218, 218, 219, 219,
+	  36,  36,  37,  37,  29,  29,  29,  29,
+	 107, 107, 108, 108,  99,  99, 100, 100,
+	 169, 169, 169, 169, 161, 161, 161, 161,
+	 239, 239, 240, 240, 231, 232, 232, 232,
+	  19,  19,  19,  19,  11,  11,  11,  11,
+	  89,  89,  90,  90,  81,  82,  82,  82,
+	 151, 151, 151, 151, 143, 143, 143, 143,
+	 221, 222, 222, 222, 214, 214, 214, 214,
+	  40,  40,  41,  41,  33,  33,  33,  33,
+	 111, 111, 112, 112, 103, 103, 104, 104,
+	 173, 173, 173, 173, 165, 165, 165, 165,
+	 243, 243, 244, 244, 235, 236, 236, 236,
+	  23,  23,  23,  23,  15,  15,  15,  15,
+	  93,  93,  94,  94,  85,  86,  86,  86,
+	 155, 155, 155, 155, 147, 147, 147, 147,
+	 225, 226, 226, 226, 218, 218, 218, 218,
+	  37,  36,  41,  40,  19,  19,  23,  23,
+	 169, 169, 173, 173, 151, 151, 155, 155,
+	 108, 107, 112, 111,  90,  89,  94,  93,
+	 240, 239, 244, 243, 222, 221, 226, 225,
+	  29,  29,  33,  33,  11,  11,  15,  15,
+	 161, 161, 165, 165, 143, 143, 147, 147,
+	 100,  99, 104, 103,  82,  81,  86,  85,
+	 232, 231, 236, 235, 214, 214, 218, 218,
+	  37,  37,  41,  41,  19,  19,  23,  23,
+	 169, 169, 173, 173, 152, 151, 156, 155,
+	 108, 108, 112, 112,  90,  90,  94,  94,
+	 240, 240, 244, 244, 222, 222, 226, 226,
+	  29,  29,  33,  33,  12,  11,  16,  15,
+	 162, 161, 166, 165, 144, 143, 148, 147,
+	 100, 100, 104, 104,  82,  82,  86,  86,
+	 232, 232, 236, 236, 215, 214, 219, 218,
+	  37,  36,  41,  40,  19,  19,  23,  23,
+	 169, 169, 173, 173, 151, 151, 155, 155,
+	 108, 107, 112, 111,  90,  89,  94,  93,
+	 240, 239, 244, 243, 222, 222, 226, 226,
+	  29,  29,  33,  33,  11,  11,  15,  15,
+	 161, 161, 165, 165, 143, 143, 147, 147,
+	 100,  99, 104, 103,  82,  82,  86,  86,
+	 232, 232, 236, 236, 214, 214, 218, 218,
+	  37,  37,  41,  41,  20,  19,  24,  23,
+	 170, 169, 174, 173, 152, 151, 156, 155,
+	 108, 108, 112, 112,  90,  90,  94,  94,
+	 240, 240, 244, 244, 222, 222, 226, 226,
+	  30,  29,  34,  33,  12,  11,  16,  15,
+	 162, 161, 166, 165, 144, 143, 148, 147,
+	 100, 100, 104, 104,  82,  82,  86,  86,
+	 232, 232, 236, 236, 215, 214, 219, 218,
+	  37,  36,  43,  42,  23,  22,  29,  28,
+	 210, 209, 216, 215, 196, 195, 202, 201,
+	  53,  52,  59,  58,  39,  38,  45,  44,
+	 226, 225, 232, 231, 212, 211, 218, 217,
+	  39,  38,  46,  44,  26,  24,  32,  30,
+	 212, 211, 219, 217, 199, 197, 205, 203,
+	  55,  54,  62,  60,  42,  40,  48,  46,
+	 228, 227, 235, 233, 215, 213, 221, 219,
+	  35,  34,  42,  40,  22,  20,  28,  26,
+	 208, 207, 215, 213, 195, 193, 201, 199,
+	  51,  50,  58,  56,  38,  36,  44,  42,
+	 224, 223, 231, 229, 211, 209, 217, 215,
+	  38,  37,  44,  43,  24,  23,  30,  29,
+	 211, 210, 217, 216, 197, 196, 203, 202,
+	  54,  53,  60,  59,  40,  39,  46,  45,
+	 227, 226, 233, 232, 213, 212, 219, 218,
+	  37,  36,  43,  42,  23,  22,  29,  28,
+	 210, 209, 216, 215, 196, 195, 202, 201,
+	  53,  52,  59,  58,  39,  38,  45,  44,
+	 226, 225, 232, 231, 212, 211, 218, 217,
+	  40,  38,  46,  44,  26,  24,  32,  31,
+	 213, 211, 219, 217, 199, 197, 205, 204,
+	  56,  54,  62,  60,  42,  40,  48,  47,
+	 229, 227, 235, 233, 215, 213, 221, 220,
+	  36,  34,  42,  40,  22,  20,  28,  27,
+	 209, 207, 215, 213, 195, 193, 201, 200,
+	  52,  50,  58,  56,  38,  36,  44,  43,
+	 225, 223, 231, 229, 211, 209, 217, 216,
+	  38,  37,  44,  43,  24,  23,  30,  29,
+	 211, 210, 217, 216, 197, 196, 203, 202,
+	  54,  53,  60,  59,  40,  39,  46,  45,
+	 227, 226, 233, 232, 213, 212, 219, 218
+};
+
+static unsigned char fsk96_txfilt_5[] = {
+	  39,  40,  38,  38,  42,  43,  41,  41,
+	  51,  51,  50,  50,  54,  54,  53,  53,
+	 209, 209, 207, 208, 212, 212, 210, 211,
+	 221, 221, 219, 219, 224, 224, 222, 222,
+	  28,  28,  27,  27,  31,  31,  30,  30,
+	  40,  40,  38,  39,  43,  43,  41,  42,
+	 198, 198, 196, 196, 201, 201, 199, 199,
+	 209, 210, 208, 208, 212, 213, 211, 211,
+	  45,  45,  44,  44,  48,  48,  47,  47,
+	  57,  57,  56,  56,  60,  60,  59,  59,
+	 215, 215, 213, 213, 218, 218, 216, 216,
+	 227, 227, 225, 225, 230, 230, 228, 228,
+	  34,  34,  32,  33,  37,  37,  35,  36,
+	  46,  46,  44,  44,  49,  49,  47,  47,
+	 203, 204, 202, 202, 206, 207, 205, 205,
+	 215, 215, 214, 214, 218, 218, 217, 217,
+	  38,  38,  37,  37,  41,  41,  40,  40,
+	  50,  50,  48,  49,  53,  53,  51,  52,
+	 208, 208, 206, 206, 211, 211, 209, 209,
+	 219, 220, 218, 218, 222, 223, 221, 221,
+	  27,  27,  25,  25,  30,  30,  28,  28,
+	  39,  39,  37,  37,  42,  42,  40,  40,
+	 196, 196, 195, 195, 199, 199, 198, 198,
+	 208, 208, 207, 207, 211, 211, 210, 210,
+	  44,  44,  42,  43,  47,  47,  45,  46,
+	  56,  56,  54,  54,  59,  59,  57,  57,
+	 213, 214, 212, 212, 216, 217, 215, 215,
+	 225, 225, 224, 224, 228, 228, 227, 227,
+	  33,  33,  31,  31,  36,  36,  34,  34,
+	  44,  45,  43,  43,  47,  48,  46,  46,
+	 202, 202, 201, 201, 205, 205, 204, 204,
+	 214, 214, 212, 213, 217, 217, 215, 216,
+	  39,  40,  39,  39,  35,  35,  35,  35,
+	  91,  91,  90,  90,  86,  87,  86,  86,
+	 183, 183, 182, 182, 178, 179, 178, 178,
+	 234, 234, 234, 234, 230, 230, 229, 230,
+	  21,  22,  21,  21,  17,  17,  17,  17,
+	  73,  73,  72,  72,  68,  69,  68,  68,
+	 165, 165, 164, 164, 161, 161, 160, 160,
+	 216, 216, 216, 216, 212, 212, 211, 212,
+	  44,  44,  44,  44,  40,  40,  40,  40,
+	  95,  96,  95,  95,  91,  91,  91,  91,
+	 187, 188, 187, 187, 183, 183, 183, 183,
+	 239, 239, 238, 239, 235, 235, 234, 234,
+	  26,  26,  26,  26,  22,  22,  22,  22,
+	  77,  78,  77,  77,  73,  73,  73,  73,
+	 170, 170, 169, 169, 165, 165, 165, 165,
+	 221, 221, 220, 221, 217, 217, 216, 216,
+	  39,  39,  38,  38,  34,  35,  34,  34,
+	  90,  90,  90,  90,  86,  86,  85,  85,
+	 182, 182, 182, 182, 178, 178, 177, 178,
+	 233, 233, 233, 233, 229, 229, 229, 229,
+	  21,  21,  20,  20,  16,  17,  16,  16,
+	  72,  72,  72,  72,  68,  68,  67,  68,
+	 164, 164, 164, 164, 160, 160, 159, 160,
+	 215, 215, 215, 215, 211, 211, 211, 211,
+	  43,  44,  43,  43,  39,  39,  39,  39,
+	  95,  95,  94,  94,  91,  91,  90,  90,
+	 187, 187, 186, 187, 183, 183, 182, 182,
+	 238, 238, 238, 238, 234, 234, 233, 234,
+	  25,  26,  25,  25,  21,  21,  21,  21,
+	  77,  77,  76,  77,  73,  73,  72,  72,
+	 169, 169, 168, 169, 165, 165, 164, 164,
+	 220, 220, 220, 220, 216, 216, 215, 216,
+	  39,  39,  41,  41,  26,  26,  28,  28,
+	 139, 139, 141, 141, 126, 125, 128, 128,
+	 139, 139, 141, 141, 126, 125, 128, 127,
+	 238, 238, 240, 240, 225, 225, 227, 227,
+	  26,  26,  28,  28,  13,  13,  15,  15,
+	 126, 125, 128, 128, 112, 112, 115, 114,
+	 126, 125, 128, 127, 112, 112, 115, 114,
+	 225, 225, 227, 227, 212, 212, 214, 214,
+	  41,  41,  44,  43,  28,  28,  30,  30,
+	 141, 141, 143, 143, 128, 128, 130, 130,
+	 141, 141, 143, 143, 128, 127, 130, 130,
+	 240, 240, 242, 242, 227, 227, 229, 229,
+	  28,  28,  30,  30,  15,  15,  17,  17,
+	 128, 128, 130, 130, 115, 114, 117, 116,
+	 128, 127, 130, 130, 115, 114, 117, 116,
+	 227, 227, 229, 229, 214, 214, 216, 216,
+	  39,  39,  41,  41,  26,  26,  28,  28,
+	 139, 138, 141, 140, 125, 125, 128, 127,
+	 139, 138, 141, 140, 125, 125, 127, 127,
+	 238, 238, 240, 240, 225, 225, 227, 227,
+	  26,  26,  28,  28,  13,  13,  15,  15,
+	 125, 125, 128, 127, 112, 112, 114, 114,
+	 125, 125, 127, 127, 112, 112, 114, 114,
+	 225, 225, 227, 227, 212, 211, 214, 214,
+	  41,  41,  43,  43,  28,  28,  30,  30,
+	 141, 140, 143, 143, 128, 127, 130, 129,
+	 141, 140, 143, 143, 127, 127, 130, 129,
+	 240, 240, 242, 242, 227, 227, 229, 229,
+	  28,  28,  30,  30,  15,  15,  17,  17,
+	 128, 127, 130, 129, 114, 114, 116, 116,
+	 127, 127, 130, 129, 114, 114, 116, 116,
+	 227, 227, 229, 229, 214, 214, 216, 216,
+	  39,  39,  44,  43,  21,  21,  26,  25,
+	 183, 182, 187, 187, 165, 164, 170, 169,
+	  91,  90,  95,  95,  73,  72,  77,  77,
+	 234, 233, 239, 238, 216, 215, 221, 220,
+	  35,  34,  40,  39,  17,  16,  22,  21,
+	 178, 178, 183, 183, 161, 160, 165, 165,
+	  86,  86,  91,  91,  68,  68,  73,  73,
+	 230, 229, 235, 234, 212, 211, 217, 216,
+	  39,  38,  44,  43,  21,  20,  26,  25,
+	 182, 182, 187, 186, 164, 164, 169, 168,
+	  90,  90,  95,  94,  72,  72,  77,  76,
+	 234, 233, 238, 238, 216, 215, 220, 220,
+	  35,  34,  40,  39,  17,  16,  22,  21,
+	 178, 177, 183, 182, 160, 159, 165, 164,
+	  86,  85,  91,  90,  68,  67,  73,  72,
+	 229, 229, 234, 233, 211, 211, 216, 215,
+	  40,  39,  44,  44,  22,  21,  26,  26,
+	 183, 182, 188, 187, 165, 164, 170, 169,
+	  91,  90,  96,  95,  73,  72,  78,  77,
+	 234, 233, 239, 238, 216, 215, 221, 220,
+	  35,  35,  40,  39,  17,  17,  22,  21,
+	 179, 178, 183, 183, 161, 160, 165, 165,
+	  87,  86,  91,  91,  69,  68,  73,  73,
+	 230, 229, 235, 234, 212, 211, 217, 216,
+	  39,  38,  44,  43,  21,  20,  26,  25,
+	 182, 182, 187, 187, 164, 164, 169, 169,
+	  90,  90,  95,  94,  72,  72,  77,  77,
+	 234, 233, 239, 238, 216, 215, 221, 220,
+	  35,  34,  40,  39,  17,  16,  22,  21,
+	 178, 178, 183, 182, 160, 160, 165, 164,
+	  86,  85,  91,  90,  68,  68,  73,  72,
+	 230, 229, 234, 234, 212, 211, 216, 216,
+	  39,  38,  45,  44,  28,  27,  34,  33,
+	 209, 208, 215, 213, 198, 196, 203, 202,
+	  51,  50,  57,  56,  40,  39,  46,  44,
+	 221, 219, 227, 225, 209, 208, 215, 214,
+	  42,  41,  48,  47,  31,  30,  37,  36,
+	 212, 211, 218, 216, 201, 199, 206, 205,
+	  54,  53,  60,  59,  43,  42,  49,  47,
+	 224, 222, 230, 228, 212, 211, 218, 217,
+	  38,  37,  44,  42,  27,  25,  32,  31,
+	 207, 206, 213, 212, 196, 195, 202, 201,
+	  50,  48,  56,  54,  38,  37,  44,  43,
+	 219, 218, 225, 224, 208, 207, 214, 212,
+	  41,  40,  47,  45,  30,  28,  35,  34,
+	 210, 209, 216, 215, 199, 198, 205, 204,
+	  53,  51,  59,  57,  41,  40,  47,  46,
+	 222, 221, 228, 227, 211, 210, 217, 215,
+	  40,  38,  45,  44,  28,  27,  34,  33,
+	 209, 208, 215, 214, 198, 196, 204, 202,
+	  51,  50,  57,  56,  40,  39,  46,  45,
+	 221, 220, 227, 225, 210, 208, 215, 214,
+	  43,  41,  48,  47,  31,  30,  37,  36,
+	 212, 211, 218, 217, 201, 199, 207, 205,
+	  54,  53,  60,  59,  43,  42,  49,  48,
+	 224, 223, 230, 228, 213, 211, 218, 217,
+	  38,  37,  44,  43,  27,  25,  33,  31,
+	 208, 206, 213, 212, 196, 195, 202, 201,
+	  50,  49,  56,  54,  39,  37,  44,  43,
+	 219, 218, 225, 224, 208, 207, 214, 213,
+	  41,  40,  47,  46,  30,  28,  36,  34,
+	 211, 209, 216, 215, 199, 198, 205, 204,
+	  53,  52,  59,  57,  42,  40,  47,  46,
+	 222, 221, 228, 227, 211, 210, 217, 216
+};
+
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_hapn4800.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_hapn4800.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_hapn4800.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_hapn4800.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,93 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * hapn4800 specific tables
+ */
+
+static unsigned char hapn48_txfilt_8[] = {
+	 127, 127,  92,  91, 151, 150, 115, 114,
+	 141, 140, 105, 104, 164, 163, 128, 128,
+	 128, 128,  63,  63, 193, 194, 129, 129,
+	 126, 126,  61,  62, 192, 192, 127, 127,
+	 128, 129,  37,  38, 224, 226, 134, 135,
+	 120, 121,  29,  31, 217, 218, 126, 127,
+	 128, 132,  19,  24, 239, 243, 130, 135,
+	 120, 125,  12,  16, 231, 236, 123, 127,
+	 127, 135,  16,  24, 236, 243, 125, 132,
+	 123, 130,  12,  19, 231, 239, 120, 128,
+	 127, 135,  31,  38, 218, 226, 121, 129,
+	 126, 134,  29,  37, 217, 224, 120, 128,
+	 127, 129,  62,  63, 192, 194, 126, 128,
+	 127, 129,  61,  63, 192, 193, 126, 128,
+	 128, 114, 104,  91, 163, 150, 140, 127,
+	 128, 115, 105,  92, 164, 151, 141, 127
+};
+
+static unsigned char hapn48_txfilt_10[] = {
+	 127, 127,  94,  94, 146, 146, 113, 112,
+	 143, 142, 109, 109, 161, 161, 128, 128,
+	 128, 127,  72,  72, 182, 182, 126, 126,
+	 129, 129,  73,  73, 183, 183, 128, 127,
+	 127, 128,  49,  50, 211, 212, 133, 133,
+	 122, 122,  43,  44, 205, 206, 127, 128,
+	 127, 130,  30,  33, 231, 233, 133, 136,
+	 119, 122,  22,  24, 222, 225, 125, 128,
+	 127, 133,  18,  23, 240, 245, 130, 135,
+	 120, 125,  10,  15, 232, 237, 122, 128,
+	 128, 135,  15,  23, 237, 245, 125, 133,
+	 122, 130,  10,  18, 232, 240, 120, 127,
+	 128, 136,  24,  33, 225, 233, 122, 130,
+	 125, 133,  22,  30, 222, 231, 119, 127,
+	 128, 133,  44,  50, 206, 212, 122, 128,
+	 127, 133,  43,  49, 205, 211, 122, 127,
+	 127, 126,  73,  72, 183, 182, 129, 127,
+	 128, 126,  73,  72, 183, 182, 129, 128,
+	 128, 112, 109,  94, 161, 146, 142, 127,
+	 128, 113, 109,  94, 161, 146, 143, 127
+};
+
+static unsigned char hapn48_txfilt_pm8[] = {
+	  12,   6, 242, 237,  18,  12, 248, 243,
+	  12,   7, 243, 237,  18,  13, 249, 243,
+	  12,  18, 243, 248,   7,  12, 237, 243,
+	  12,  18, 243, 248,   7,  12, 237, 243,
+	  12,  39, 225, 252,   3,  30, 216, 243,
+	  12,  39, 225, 252,   3,  30, 216, 243,
+	  11,  70, 193, 252,   3,  62, 185, 244,
+	  11,  70, 193, 252,   3,  62, 185, 244,
+	  11, 109, 152, 250,   5, 103, 146, 244,
+	  11, 109, 152, 250,   5, 103, 146, 244,
+	   9, 150, 107, 248,   7, 148, 105, 246,
+	   9, 150, 107, 248,   7, 148, 105, 246,
+	   8, 189,  66, 248,   7, 189,  66, 247,
+	   8, 189,  66, 248,   7, 189,  66, 247,
+	   7, 221,  34, 248,   7, 221,  34, 248,
+	   7, 221,  34, 248,   7, 221,  34, 248
+};
+
+static unsigned char hapn48_txfilt_pm10[] = {
+	  12,  12,   8,   8, 243, 243, 238, 238,
+	  17,  17,  12,  12, 247, 247, 243, 243,
+	   8,   8,  12,  13, 238, 239, 243, 243,
+	  12,  12,  16,  17, 242, 243, 247, 247,
+	   8,   8,  28,  28, 227, 227, 247, 247,
+	   8,   8,  28,  28, 227, 227, 247, 247,
+	   9,   8,  50,  50, 207, 206, 248, 248,
+	   7,   7,  49,  48, 205, 205, 247, 246,
+	  10,   9,  79,  78, 179, 178, 249, 248,
+	   7,   6,  77,  76, 177, 176, 246, 245,
+	  11,   8, 113, 110, 147, 144, 249, 246,
+	   9,   6, 111, 108, 145, 142, 247, 244,
+	  12,   7, 148, 143, 114, 109, 250, 245,
+	  10,   5, 146, 141, 112, 107, 248, 243,
+	  12,   5, 181, 174,  82,  74, 251, 244,
+	  11,   4, 181, 173,  81,  74, 250, 243,
+	  12,   3, 210, 201,  54,  45, 252, 243,
+	  12,   3, 210, 201,  54,  45, 252, 243,
+	  12,   4, 231, 223,  32,  24, 251, 243,
+	  12,   4, 231, 223,  32,  24, 251, 243
+};
+
diff -urN linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_psk4800.h linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_psk4800.h
--- linux-2.4.32/drivers/net/hamradio/soundmodem/sm_tbl_psk4800.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/drivers/net/hamradio/soundmodem/sm_tbl_psk4800.h	2005-12-20 12:08:57.000000000 +0200
@@ -0,0 +1,373 @@
+/*
+ * THIS FILE IS GENERATED AUTOMATICALLY BY ./gentbl, DO NOT EDIT!
+ */
+
+
+/*
+ * psk4800 specific tables
+ */
+#define PSK48_TXF_OVERSAMPLING 5
+#define PSK48_TXF_NUMSAMPLES 16
+
+#define PSK48_SAMPLERATE  8000
+#define PSK48_CAR_FREQ    2000
+#define PSK48_PSK_LEN     5
+#define PSK48_RXF_LEN     64
+#define PSK48_PHASEINC    (0x10000*PSK48_CAR_FREQ/PSK48_SAMPLERATE)
+#define PSK48_SPHASEINC   (0x10000/(2*PSK48_PSK_LEN))
+
+static const short psk48_tx_table[PSK48_TXF_OVERSAMPLING*PSK48_TXF_NUMSAMPLES*8*2] = {
+	   -12,     -8,      0,      8,     12,      8,      0,     -8, 
+	     0,     -8,    -12,     -8,      0,      8,     12,      8, 
+	   -20,    -14,      0,     14,     20,     14,      0,    -14, 
+	     0,    -14,    -20,    -14,      0,     14,     20,     14, 
+	   -45,    -32,      0,     32,     45,     32,      0,    -32, 
+	     0,    -32,    -45,    -32,      0,     32,     45,     32, 
+	   -92,    -65,      0,     65,     92,     65,      0,    -65, 
+	     0,    -65,    -92,    -65,      0,     65,     92,     65, 
+	  -172,   -122,      0,    122,    172,    122,      0,   -122, 
+	     0,   -122,   -172,   -122,      0,    122,    172,    122, 
+	  -307,   -217,      0,    217,    307,    217,      0,   -217, 
+	     0,   -217,   -307,   -217,      0,    217,    307,    217, 
+	  -564,   -399,      0,    399,    564,    399,      0,   -399, 
+	     0,   -399,   -564,   -399,      0,    399,    564,    399, 
+	 -1322,   -935,      0,    935,   1322,    935,      0,   -935, 
+	     0,   -935,  -1322,   -935,      0,    935,   1322,    935, 
+	 12256,   8666,      0,  -8666, -12256,  -8666,      0,   8666, 
+	     0,   8666,  12256,   8666,      0,  -8666, -12256,  -8666, 
+	  1066,    754,      0,   -754,  -1066,   -754,      0,    754, 
+	     0,    754,   1066,    754,      0,   -754,  -1066,   -754, 
+	   495,    350,      0,   -350,   -495,   -350,      0,    350, 
+	     0,    350,    495,    350,      0,   -350,   -495,   -350, 
+	   273,    193,      0,   -193,   -273,   -193,      0,    193, 
+	     0,    193,    273,    193,      0,   -193,   -273,   -193, 
+	   153,    108,      0,   -108,   -153,   -108,      0,    108, 
+	     0,    108,    153,    108,      0,   -108,   -153,   -108, 
+	    81,     57,      0,    -57,    -81,    -57,      0,     57, 
+	     0,     57,     81,     57,      0,    -57,    -81,    -57, 
+	    38,     27,      0,    -27,    -38,    -27,      0,     27, 
+	     0,     27,     38,     27,      0,    -27,    -38,    -27, 
+	    17,     12,      0,    -12,    -17,    -12,      0,     12, 
+	     0,     12,     17,     12,      0,    -12,    -17,    -12, 
+	   -20,    -14,      0,     14,     20,     14,      0,    -14, 
+	     0,    -14,    -20,    -14,      0,     14,     20,     14, 
+	   -38,    -27,      0,     27,     38,     27,      0,    -27, 
+	     0,    -27,    -38,    -27,      0,     27,     38,     27, 
+	   -85,    -60,      0,     60,     85,     60,      0,    -60, 
+	     0,    -60,    -85,    -60,      0,     60,     85,     60, 
+	  -170,   -120,      0,    120,    170,    120,      0,   -120, 
+	     0,   -120,   -170,   -120,      0,    120,    170,    120, 
+	  -314,   -222,      0,    222,    314,    222,      0,   -222, 
+	     0,   -222,   -314,   -222,      0,    222,    314,    222, 
+	  -557,   -394,      0,    394,    557,    394,      0,   -394, 
+	     0,   -394,   -557,   -394,      0,    394,    557,    394, 
+	 -1048,   -741,      0,    741,   1048,    741,      0,   -741, 
+	     0,   -741,  -1048,   -741,      0,    741,   1048,    741, 
+	 -2783,  -1968,      0,   1968,   2783,   1968,      0,  -1968, 
+	     0,  -1968,  -2783,  -1968,      0,   1968,   2783,   1968, 
+	  6591,   4660,      0,  -4660,  -6591,  -4660,      0,   4660, 
+	     0,   4660,   6591,   4660,      0,  -4660,  -6591,  -4660, 
+	  1434,   1014,      0,  -1014,  -1434,  -1014,      0,   1014, 
+	     0,   1014,   1434,   1014,      0,  -1014,  -1434,  -1014, 
+	   707,    500,      0,   -500,   -707,   -500,      0,    500, 
+	     0,    500,    707,    500,      0,   -500,   -707,   -500, 
+	   395,    279,      0,   -279,   -395,   -279,      0,    279, 
+	     0,    279,    395,    279,      0,   -279,   -395,   -279, 
+	   219,    155,      0,   -155,   -219,   -155,      0,    155, 
+	     0,    155,    219,    155,      0,   -155,   -219,   -155, 
+	   114,     80,      0,    -80,   -114,    -80,      0,     80, 
+	     0,     80,    114,     80,      0,    -80,   -114,    -80, 
+	    53,     37,      0,    -37,    -53,    -37,      0,     37, 
+	     0,     37,     53,     37,      0,    -37,    -53,    -37, 
+	    25,     17,      0,    -17,    -25,    -17,      0,     17, 
+	     0,     17,     25,     17,      0,    -17,    -25,    -17, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	     0,      0,      0,      0,      0,      0,      0,      0, 
+	    25,     17,      0,    -17,    -25,    -17,      0,     17, 
+	     0,     17,     25,     17,      0,    -17,    -25,    -17, 
+	    53,     37,      0,    -37,    -53,    -37,      0,     37, 
+	     0,     37,     53,     37,      0,    -37,    -53,    -37, 
+	   114,     80,      0,    -80,   -114,    -80,      0,     80, 
+	     0,     80,    114,     80,      0,    -80,   -114,    -80, 
+	   219,    155,      0,   -155,   -219,   -155,      0,    155, 
+	     0,    155,    219,    155,      0,   -155,   -219,   -155, 
+	   395,    279,      0,   -279,   -395,   -279,      0,    279, 
+	     0,    279,    395,    279,      0,   -279,   -395,   -279, 
+	   707,    500,      0,   -500,   -707,   -500,      0,    500, 
+	     0,    500,    707,    500,      0,   -500,   -707,   -500, 
+	  1434,   1014,      0,  -1014,  -1434,  -1014,      0,   1014, 
+	     0,   1014,   1434,   1014,      0,  -1014,  -1434,  -1014, 
+	  6591,   4660,      0,  -4660,  -6591,  -4660,      0,   4660, 
+	     0,   4660,   6591,   4660,      0,  -4660,  -6591,  -4660, 
+	 -2783,  -1968,      0,   1968,   2783,   1968,      0,  -1968, 
+	     0,  -1968,  -2783,  -1968,      0,   1968,   2783,   1968, 
+	 -1048,   -741,      0,    741,   1048,    741,      0,   -741, 
+	     0,   -741,  -1048,   -741,      0,    741,   1048,    741, 
+	  -557,   -394,      0,    394,    557,    394,      0,   -394, 
+	     0,   -394,   -557,   -394,      0,    394,    557,    394, 
+	  -314,   -222,      0,    222,    314,    222,      0,   -222, 
+	     0,   -222,   -314,   -222,      0,    222,    314,    222, 
+	  -170,   -120,      0,    120,    170,    120,      0,   -120, 
+	     0,   -120,   -170,   -120,      0,    120,    170,    120, 
+	   -85,    -60,      0,     60,     85,     60,      0,    -60, 
+	     0,    -60,    -85,    -60,      0,     60,     85,     60, 
+	   -38,    -27,      0,     27,     38,     27,      0,    -27, 
+	     0,    -27,    -38,    -27,      0,     27,     38,     27, 
+	   -20,    -14,      0,     14,     20,     14,      0,    -14, 
+	     0,    -14,    -20,    -14,      0,     14,     20,     14, 
+	    17,     12,      0,    -12,    -17,    -12,      0,     12, 
+	     0,     12,     17,     12,      0,    -12,    -17,    -12, 
+	    38,     27,      0,    -27,    -38,    -27,      0,     27, 
+	     0,     27,     38,     27,      0,    -27,    -38,    -27, 
+	    81,     57,      0,    -57,    -81,    -57,      0,     57, 
+	     0,     57,     81,     57,      0,    -57,    -81,    -57, 
+	   153,    108,      0,   -108,   -153,   -108,      0,    108, 
+	     0,    108,    153,    108,      0,   -108,   -153,   -108, 
+	   273,    193,      0,   -193,   -273,   -193,      0,    193, 
+	     0,    193,    273,    193,      0,   -193,   -273,   -193, 
+	   495,    350,      0,   -350,   -495,   -350,      0,    350, 
+	     0,    350,    495,    350,      0,   -350,   -495,   -350, 
+	  1066,    754,      0,   -754,  -1066,   -754,      0,    754, 
+	     0,    754,   1066,    754,      0,   -754,  -1066,   -754, 
+	 12256,   8666,      0,  -8666, -12256,  -8666,      0,   8666, 
+	     0,   8666,  12256,   8666,      0,  -8666, -12256,  -8666, 
+	 -1322,   -935,      0,    935,   1322,    935,      0,   -935, 
+	     0,   -935,  -1322,   -935,      0,    935,   1322,    935, 
+	  -564,   -399,      0,    399,    564,    399,      0,   -399, 
+	     0,   -399,   -564,   -399,      0,    399,    564,    399, 
+	  -307,   -217,      0,    217,    307,    217,      0,   -217, 
+	     0,   -217,   -307,   -217,      0,    217,    307,    217, 
+	  -172,   -122,      0,    122,    172,    122,      0,   -122, 
+	     0,   -122,   -172,   -122,      0,    122,    172,    122, 
+	   -92,    -65,      0,     65,     92,     65,      0,    -65, 
+	     0,    -65,    -92,    -65,      0,     65,     92,     65, 
+	   -45,    -32,      0,     32,     45,     32,      0,    -32, 
+	     0,    -32,    -45,    -32,      0,     32,     45,     32, 
+	   -20,    -14,      0,     14,     20,     14,      0,    -14, 
+	     0,    -14,    -20,    -14,      0,     14,     20,     14, 
+	   -12,     -8,      0,      8,     12,      8,      0,     -8, 
+	     0,     -8,    -12,     -8,      0,      8,     12,      8
+};
+
+static const short psk48_rx_coeff[PSK48_RXF_LEN] = {
+	    -7,    11,    28,    35,    24,    -6,   -48,   -79,
+	   -76,   -22,    68,   157,   186,   114,   -53,  -250,
+	  -370,  -315,   -58,   318,   636,   694,   371,  -281,
+	 -1014, -1444, -1200,   -86,  1793,  4033,  6035,  7215,
+	  7215,  6035,  4033,  1793,   -86, -1200, -1444, -1014,
+	  -281,   371,   694,   636,   318,   -58,  -315,  -370,
+	  -250,   -53,   114,   186,   157,    68,   -22,   -76,
+	   -79,   -48,    -6,    24,    35,    28,    11,    -7
+};
+
+
+/*
+ * more accurate cosine table
+ */
+
+static const short costab[256] = {
+	 32767,  32757,  32727,  32678,  32609,  32520,  32412,  32284, 
+	 32137,  31970,  31785,  31580,  31356,  31113,  30851,  30571, 
+	 30272,  29955,  29621,  29268,  28897,  28510,  28105,  27683, 
+	 27244,  26789,  26318,  25831,  25329,  24811,  24278,  23731, 
+	 23169,  22594,  22004,  21402,  20787,  20159,  19519,  18867, 
+	 18204,  17530,  16845,  16150,  15446,  14732,  14009,  13278, 
+	 12539,  11792,  11038,  10278,   9511,   8739,   7961,   7179, 
+	  6392,   5601,   4807,   4011,   3211,   2410,   1607,    804, 
+	     0,   -804,  -1607,  -2410,  -3211,  -4011,  -4807,  -5601, 
+	 -6392,  -7179,  -7961,  -8739,  -9511, -10278, -11038, -11792, 
+	-12539, -13278, -14009, -14732, -15446, -16150, -16845, -17530, 
+	-18204, -18867, -19519, -20159, -20787, -21402, -22004, -22594, 
+	-23169, -23731, -24278, -24811, -25329, -25831, -26318, -26789, 
+	-27244, -27683, -28105, -28510, -28897, -29268, -29621, -29955, 
+	-30272, -30571, -30851, -31113, -31356, -31580, -31785, -31970, 
+	-32137, -32284, -32412, -32520, -32609, -32678, -32727, -32757, 
+	-32767, -32757, -32727, -32678, -32609, -32520, -32412, -32284, 
+	-32137, -31970, -31785, -31580, -31356, -31113, -30851, -30571, 
+	-30272, -29955, -29621, -29268, -28897, -28510, -28105, -27683, 
+	-27244, -26789, -26318, -25831, -25329, -24811, -24278, -23731, 
+	-23169, -22594, -22004, -21402, -20787, -20159, -19519, -18867, 
+	-18204, -17530, -16845, -16150, -15446, -14732, -14009, -13278, 
+	-12539, -11792, -11038, -10278,  -9511,  -8739,  -7961,  -7179, 
+	 -6392,  -5601,  -4807,  -4011,  -3211,  -2410,  -1607,   -804, 
+	     0,    804,   1607,   2410,   3211,   4011,   4807,   5601, 
+	  6392,   7179,   7961,   8739,   9511,  10278,  11038,  11792, 
+	 12539,  13278,  14009,  14732,  15446,  16150,  16845,  17530, 
+	 18204,  18867,  19519,  20159,  20787,  21402,  22004,  22594, 
+	 23169,  23731,  24278,  24811,  25329,  25831,  26318,  26789, 
+	 27244,  27683,  28105,  28510,  28897,  29268,  29621,  29955, 
+	 30272,  30571,  30851,  31113,  31356,  31580,  31785,  31970, 
+	 32137,  32284,  32412,  32520,  32609,  32678,  32727,  32757
+};
+
+#define COS(x) costab[((x)>>8)&0xff]
+#define SIN(x) COS((x)+0xc000)
+
+
+/*
+ * arctan table (indexed by i/q; should really be indexed by i/(i+q)
+ */
+#define ATAN_TABLEN 1024
+
+static const unsigned short atan_tab[ATAN_TABLEN+2] = {
+	     0,     10,     20,     30,     40,     50,     61,     71, 
+	    81,     91,    101,    112,    122,    132,    142,    152, 
+	   162,    173,    183,    193,    203,    213,    224,    234, 
+	   244,    254,    264,    274,    285,    295,    305,    315, 
+	   325,    336,    346,    356,    366,    376,    386,    397, 
+	   407,    417,    427,    437,    447,    458,    468,    478, 
+	   488,    498,    508,    519,    529,    539,    549,    559, 
+	   569,    579,    590,    600,    610,    620,    630,    640, 
+	   651,    661,    671,    681,    691,    701,    711,    722, 
+	   732,    742,    752,    762,    772,    782,    792,    803, 
+	   813,    823,    833,    843,    853,    863,    873,    884, 
+	   894,    904,    914,    924,    934,    944,    954,    964, 
+	   974,    985,    995,   1005,   1015,   1025,   1035,   1045, 
+	  1055,   1065,   1075,   1085,   1096,   1106,   1116,   1126, 
+	  1136,   1146,   1156,   1166,   1176,   1186,   1196,   1206, 
+	  1216,   1226,   1236,   1246,   1256,   1266,   1277,   1287, 
+	  1297,   1307,   1317,   1327,   1337,   1347,   1357,   1367, 
+	  1377,   1387,   1397,   1407,   1417,   1427,   1437,   1447, 
+	  1457,   1467,   1477,   1487,   1497,   1507,   1517,   1527, 
+	  1537,   1547,   1556,   1566,   1576,   1586,   1596,   1606, 
+	  1616,   1626,   1636,   1646,   1656,   1666,   1676,   1686, 
+	  1696,   1706,   1715,   1725,   1735,   1745,   1755,   1765, 
+	  1775,   1785,   1795,   1805,   1814,   1824,   1834,   1844, 
+	  1854,   1864,   1874,   1884,   1893,   1903,   1913,   1923, 
+	  1933,   1943,   1952,   1962,   1972,   1982,   1992,   2002, 
+	  2011,   2021,   2031,   2041,   2051,   2060,   2070,   2080, 
+	  2090,   2100,   2109,   2119,   2129,   2139,   2148,   2158, 
+	  2168,   2178,   2187,   2197,   2207,   2217,   2226,   2236, 
+	  2246,   2255,   2265,   2275,   2285,   2294,   2304,   2314, 
+	  2323,   2333,   2343,   2352,   2362,   2372,   2381,   2391, 
+	  2401,   2410,   2420,   2430,   2439,   2449,   2459,   2468, 
+	  2478,   2488,   2497,   2507,   2516,   2526,   2536,   2545, 
+	  2555,   2564,   2574,   2583,   2593,   2603,   2612,   2622, 
+	  2631,   2641,   2650,   2660,   2669,   2679,   2688,   2698, 
+	  2708,   2717,   2727,   2736,   2746,   2755,   2765,   2774, 
+	  2784,   2793,   2802,   2812,   2821,   2831,   2840,   2850, 
+	  2859,   2869,   2878,   2887,   2897,   2906,   2916,   2925, 
+	  2935,   2944,   2953,   2963,   2972,   2981,   2991,   3000, 
+	  3010,   3019,   3028,   3038,   3047,   3056,   3066,   3075, 
+	  3084,   3094,   3103,   3112,   3122,   3131,   3140,   3149, 
+	  3159,   3168,   3177,   3187,   3196,   3205,   3214,   3224, 
+	  3233,   3242,   3251,   3260,   3270,   3279,   3288,   3297, 
+	  3307,   3316,   3325,   3334,   3343,   3352,   3362,   3371, 
+	  3380,   3389,   3398,   3407,   3416,   3426,   3435,   3444, 
+	  3453,   3462,   3471,   3480,   3489,   3498,   3508,   3517, 
+	  3526,   3535,   3544,   3553,   3562,   3571,   3580,   3589, 
+	  3598,   3607,   3616,   3625,   3634,   3643,   3652,   3661, 
+	  3670,   3679,   3688,   3697,   3706,   3715,   3724,   3733, 
+	  3742,   3751,   3759,   3768,   3777,   3786,   3795,   3804, 
+	  3813,   3822,   3831,   3839,   3848,   3857,   3866,   3875, 
+	  3884,   3893,   3901,   3910,   3919,   3928,   3937,   3945, 
+	  3954,   3963,   3972,   3981,   3989,   3998,   4007,   4016, 
+	  4024,   4033,   4042,   4051,   4059,   4068,   4077,   4085, 
+	  4094,   4103,   4112,   4120,   4129,   4138,   4146,   4155, 
+	  4164,   4172,   4181,   4189,   4198,   4207,   4215,   4224, 
+	  4233,   4241,   4250,   4258,   4267,   4275,   4284,   4293, 
+	  4301,   4310,   4318,   4327,   4335,   4344,   4352,   4361, 
+	  4369,   4378,   4386,   4395,   4403,   4412,   4420,   4429, 
+	  4437,   4446,   4454,   4462,   4471,   4479,   4488,   4496, 
+	  4505,   4513,   4521,   4530,   4538,   4546,   4555,   4563, 
+	  4572,   4580,   4588,   4597,   4605,   4613,   4622,   4630, 
+	  4638,   4646,   4655,   4663,   4671,   4680,   4688,   4696, 
+	  4704,   4713,   4721,   4729,   4737,   4745,   4754,   4762, 
+	  4770,   4778,   4787,   4795,   4803,   4811,   4819,   4827, 
+	  4836,   4844,   4852,   4860,   4868,   4876,   4884,   4892, 
+	  4901,   4909,   4917,   4925,   4933,   4941,   4949,   4957, 
+	  4965,   4973,   4981,   4989,   4997,   5005,   5013,   5021, 
+	  5029,   5037,   5045,   5053,   5061,   5069,   5077,   5085, 
+	  5093,   5101,   5109,   5117,   5125,   5133,   5141,   5148, 
+	  5156,   5164,   5172,   5180,   5188,   5196,   5204,   5211, 
+	  5219,   5227,   5235,   5243,   5251,   5258,   5266,   5274, 
+	  5282,   5290,   5297,   5305,   5313,   5321,   5328,   5336, 
+	  5344,   5352,   5359,   5367,   5375,   5383,   5390,   5398, 
+	  5406,   5413,   5421,   5429,   5436,   5444,   5452,   5459, 
+	  5467,   5475,   5482,   5490,   5497,   5505,   5513,   5520, 
+	  5528,   5535,   5543,   5550,   5558,   5566,   5573,   5581, 
+	  5588,   5596,   5603,   5611,   5618,   5626,   5633,   5641, 
+	  5648,   5656,   5663,   5671,   5678,   5686,   5693,   5700, 
+	  5708,   5715,   5723,   5730,   5738,   5745,   5752,   5760, 
+	  5767,   5774,   5782,   5789,   5797,   5804,   5811,   5819, 
+	  5826,   5833,   5841,   5848,   5855,   5862,   5870,   5877, 
+	  5884,   5892,   5899,   5906,   5913,   5921,   5928,   5935, 
+	  5942,   5949,   5957,   5964,   5971,   5978,   5985,   5993, 
+	  6000,   6007,   6014,   6021,   6028,   6036,   6043,   6050, 
+	  6057,   6064,   6071,   6078,   6085,   6093,   6100,   6107, 
+	  6114,   6121,   6128,   6135,   6142,   6149,   6156,   6163, 
+	  6170,   6177,   6184,   6191,   6198,   6205,   6212,   6219, 
+	  6226,   6233,   6240,   6247,   6254,   6261,   6268,   6275, 
+	  6282,   6288,   6295,   6302,   6309,   6316,   6323,   6330, 
+	  6337,   6344,   6350,   6357,   6364,   6371,   6378,   6385, 
+	  6391,   6398,   6405,   6412,   6419,   6425,   6432,   6439, 
+	  6446,   6453,   6459,   6466,   6473,   6480,   6486,   6493, 
+	  6500,   6506,   6513,   6520,   6527,   6533,   6540,   6547, 
+	  6553,   6560,   6567,   6573,   6580,   6586,   6593,   6600, 
+	  6606,   6613,   6620,   6626,   6633,   6639,   6646,   6653, 
+	  6659,   6666,   6672,   6679,   6685,   6692,   6698,   6705, 
+	  6711,   6718,   6724,   6731,   6737,   6744,   6750,   6757, 
+	  6763,   6770,   6776,   6783,   6789,   6796,   6802,   6809, 
+	  6815,   6821,   6828,   6834,   6841,   6847,   6853,   6860, 
+	  6866,   6873,   6879,   6885,   6892,   6898,   6904,   6911, 
+	  6917,   6923,   6930,   6936,   6942,   6949,   6955,   6961, 
+	  6967,   6974,   6980,   6986,   6992,   6999,   7005,   7011, 
+	  7017,   7024,   7030,   7036,   7042,   7048,   7055,   7061, 
+	  7067,   7073,   7079,   7086,   7092,   7098,   7104,   7110, 
+	  7116,   7122,   7129,   7135,   7141,   7147,   7153,   7159, 
+	  7165,   7171,   7177,   7183,   7190,   7196,   7202,   7208, 
+	  7214,   7220,   7226,   7232,   7238,   7244,   7250,   7256, 
+	  7262,   7268,   7274,   7280,   7286,   7292,   7298,   7304, 
+	  7310,   7316,   7322,   7328,   7333,   7339,   7345,   7351, 
+	  7357,   7363,   7369,   7375,   7381,   7387,   7392,   7398, 
+	  7404,   7410,   7416,   7422,   7428,   7433,   7439,   7445, 
+	  7451,   7457,   7462,   7468,   7474,   7480,   7486,   7491, 
+	  7497,   7503,   7509,   7514,   7520,   7526,   7532,   7537, 
+	  7543,   7549,   7555,   7560,   7566,   7572,   7577,   7583, 
+	  7589,   7594,   7600,   7606,   7611,   7617,   7623,   7628, 
+	  7634,   7640,   7645,   7651,   7657,   7662,   7668,   7673, 
+	  7679,   7685,   7690,   7696,   7701,   7707,   7712,   7718, 
+	  7724,   7729,   7735,   7740,   7746,   7751,   7757,   7762, 
+	  7768,   7773,   7779,   7784,   7790,   7795,   7801,   7806, 
+	  7812,   7817,   7823,   7828,   7833,   7839,   7844,   7850, 
+	  7855,   7861,   7866,   7871,   7877,   7882,   7888,   7893, 
+	  7898,   7904,   7909,   7914,   7920,   7925,   7931,   7936, 
+	  7941,   7947,   7952,   7957,   7963,   7968,   7973,   7978, 
+	  7984,   7989,   7994,   8000,   8005,   8010,   8015,   8021, 
+	  8026,   8031,   8036,   8042,   8047,   8052,   8057,   8063, 
+	  8068,   8073,   8078,   8083,   8089,   8094,   8099,   8104, 
+	  8109,   8115,   8120,   8125,   8130,   8135,   8140,   8145, 
+	  8151,   8156,   8161,   8166,   8171,   8176,   8181,   8186, 
+	  8192,   8192
+};
+
diff -urN linux-2.4.32/drivers/net/Makefile linux-2.4.32-adm5120/drivers/net/Makefile
--- linux-2.4.32/drivers/net/Makefile	2005-12-20 12:43:17.000000000 +0200
+++ linux-2.4.32-adm5120/drivers/net/Makefile	2005-12-20 12:22:42.000000000 +0200
@@ -157,6 +157,7 @@
 obj-$(CONFIG_NET_SB1250_MAC) += sb1250-mac.o
 obj-$(CONFIG_B44) += b44.o
 obj-$(CONFIG_FORCEDETH) += forcedeth.o
+obj-$(CONFIG_MIPS_ADM5120_SW) += adm5120sw.o
 
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
diff -urN linux-2.4.32/include/asm-mips/am5120/adm5120.h linux-2.4.32-adm5120/include/asm-mips/am5120/adm5120.h
--- linux-2.4.32/include/asm-mips/am5120/adm5120.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/include/asm-mips/am5120/adm5120.h	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,1083 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : include/asm/am5120/adm5120.h
+;	 Date    : 2003.3.10
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __ADM5120_H__
+#define  __ADM5120_H__
+
+
+#include <asm/addrspace.h>
+
+
+/*=========================  Physical Memory Map  ============================*/
+#define SDRAM_BASE				0
+#define SMEM1_BASE				0x10000000
+
+#define EXTIO0_BASE				0x10C00000
+#define EXTIO1_BASE				0x10E00000
+#define MPMC_BASE				0x11000000
+#define USBHOST_BASE				0x11200000
+#define PCIMEM_BASE				0x11400000
+#define PCIIO_BASE				0x11500000
+#define PCICFG_BASE				0x115FFFF0
+#define MIPS_BASE				0x11A00000
+#define SWCTRL_BASE				0x12000000
+
+#define INTC_BASE				0x12200000
+#define SYSC_BASE				0x12400000
+
+#define UART0_BASE				0x12600000
+#define UART1_BASE				0x12800000
+
+#define SMEM0_BASE				0x1FC00000
+
+
+/*=======================  MIPS interrupt  ===================*/
+#define MIPSINT_SOFT0				0
+#define MIPSINT_SOFT1				1
+#define MIPSINT_IRQ				2
+#define MIPSINT_FIQ				3
+#define MIPSINT_REV0				4
+#define MIPSINT_REV1				5
+#define MIPSINT_REV2				6
+#define MIPSINT_TIMER				7
+
+
+
+/*====================  MultiPort Memory Controller (MPMC) ==================*/
+/* registers offset */
+#define MPMC_CONTROL_REG			0x0000
+#define MPMC_STATUS_REG				0x0004
+#define MPMC_CONFIG_REG				0x0008
+
+#define MPMC_DM_CONTROL_REG			0x0020
+#define MPMC_DM_REFRESH_REG			0x0024
+
+#define MPMC_DM_TRP_REG				0x0030
+#define MPMC_DM_TRAS_REG			0x0034
+#define MPMC_DM_TSREX_REG			0x0038
+#define MPMC_DM_TAPR_REG			0x003C
+#define MPMC_DM_TDAL_REG			0x0040
+#define MPMC_DM_TWR_REG				0x0044
+#define MPMC_DM_TRC_REG				0x0048
+#define MPMC_DM_TRFC_REG			0x004C
+#define MPMC_DM_TXSR_REG			0x0050
+#define MPMC_DM_TRRD_REG			0x0054
+#define MPMC_DM_TMRD_REG			0x0058
+
+#define MPMC_SM_EXTWAIT_REG			0x0080
+
+#define MPMC_DM_CONFIG0_REG			0x0100
+#define MPMC_DM_RASCAS0_REG			0x0104
+
+#define MPMC_DM_CONFIG1_REG			0x0120
+#define MPMC_DM_RASCAS1_REG			0x0124
+
+#define MPMC_SM_CONFIG0_REG			0x0200
+#define MPMC_SM_WAITWEN0_REG			0x0204
+#define MPMC_SM_WAITOEN0_REG			0x0208
+#define MPMC_SM_WAITRD0_REG			0x020C
+#define MPMC_SM_WAITPAGE0_REG			0x0210
+#define MPMC_SM_WAITWR0_REG			0x0214
+#define MPMC_SM_WAITTURN0_REG			0x0218
+
+#define MPMC_SM_CONFIG1_REG			0x0220
+#define MPMC_SM_WAITWEN1_REG			0x0224
+#define MPMC_SM_WAITOEN1_REG			0x0228
+#define MPMC_SM_WAITRD1_REG			0x022C
+#define MPMC_SM_WAITPAGE1_REG			0x0230
+#define MPMC_SM_WAITWR1_REG			0x0234
+#define MPMC_SM_WAITTURN1_REG			0x0238
+
+#define MPMC_SM_CONFIG2_REG			0x0240
+#define MPMC_SM_WAITWEN2_REG			0x0244
+#define MPMC_SM_WAITOEN2_REG			0x0248
+#define MPMC_SM_WAITRD2_REG			0x024C
+#define MPMC_SM_WAITPAGE2_REG			0x0250
+#define MPMC_SM_WAITWR2_REG			0x0254
+#define MPMC_SM_WAITTURN2_REG			0x0258
+
+#define MPMC_SM_CONFIG3_REG			0x0260
+#define MPMC_SM_WAITWEN3_REG			0x0264
+#define MPMC_SM_WAITOEN3_REG			0x0268
+#define MPMC_SM_WAITRD3_REG			0x026C
+#define MPMC_SM_WAITPAGE3_REG			0x0270
+#define MPMC_SM_WAITWR3_REG			0x0274
+#define MPMC_SM_WAITTURN3_REG			0x0278
+
+/* Macro for access MPMC register */
+#define MPMC_REG(_offset)				\
+		(*((volatile unsigned long *)(KSEG1ADDR(MPMC_BASE + (_offset)))))
+
+
+/* MPMC_CONTROL_REG (offset: 0x0000) */
+#define MPMC_DRAIN_W_BUF			0x00000008
+#define MPMC_LOW_POWER_MODE			0x00000004
+#define MPMC_ADDR_MIRROR			0x00000002
+#define MPMC_ENABLE				0x00000001
+#define MPMC_CONTROL_MASK			0x0000000f
+
+/* MPMC_STATUS_REG (offset: 0x0004) */
+#define MPMC_SREFACK				0x00000004
+#define MPMC_WBUF_DIRTY				0x00000002
+#define MPMC_BUSY				0x00000001
+#define MPMC_STATUS_MASK			0x00000007
+
+/* MPMC_CONFIG_REG (offset: 0x0008) */
+#define MPMC_CLK_RATIO_1_1			0x00000000
+#define MPMC_CLK_RATIO_1_2			0x00000100
+#define MPMC_LITTLE_ENDIAN			0x00000000
+#define MPMC_BIG_ENDIAN				0x00000001
+#define MPMC_CONFIG_MASK			0x00000101
+
+/* MPMC_DM_CONTROL_REG (offset: 0x0020) */
+#define DM_PVHHOUT_HI_VOLTAGE			0x00008000
+#define DM_RPOUT_HI_VOLTAGE			0x00004000
+#define DM_DEEP_SLEEP_MODE			0x00002000
+
+#define DM_SDRAM_NOP				0x00000180
+#define DM_SDRAM_PRECHARGE_ALL			0x00000100
+#define DM_SDRAM_MODE_SETTING			0x00000080
+#define DM_SDRAM_NORMAL_OP			0x00000000
+#define DM_SDRAM_OPMODE_MASK			0x00000180
+
+#define DM_SELF_REFRESH_MODE			0x00000004
+#define DM_CLKOUT_ALWAYS			0x00000002
+#define DM_CLKEN_ALWAYS				0x00000001
+
+#define MPMC_DM_CONTROL_MASK			0x0000e187
+
+
+/* MPMC_DM_REFRESH_REG (offset:0x0024) */
+#define MPMC_DM_REFRESH_MASK			0x00000300
+
+/* MPMC_DM_TRP_REG (offset: 0x0030) */
+#define MPMC_DM_TRP_MASK			0x0000000f
+
+/* MPMC_DM_TRAS_REG (offset: 0x0034) */
+#define MPMC_DM_TRAS_MASK			0x0000000f
+
+/* MPMC_DM_TSREX_REG (offset: 0x0038) */
+#define MPMC_DM_TSREX_MASK			0x0000000f
+
+/* MPMC_DM_TAPR_REG	(offset: 0x003C) */
+#define MPMC_DM_TAPR_MASK			0x0000000f
+
+/* MPMC_DM_TDAL_REG	(offset: 0x0040) */
+#define MPMC_DM_TDAL_MASK			0x0000000f
+
+/* MPMC_DM_TWR_REG (offset: 0x0044) */
+#define MPMC_DM_TWR_MASK			0x0000000f
+
+/* MPMC_DM_TRC_REG (offset: 0x0048) */
+#define MPMC_DM_TRC_MASK 			0x0000001f
+
+/* MPMC_DM_TRFC_REG (offset: 0x004C) */
+#define MPMC_DM_TRFC_MASK			0x0000001f
+
+/* MPMC_DM_TXSR_REG	(offset: 0x0050) */
+#define MPMC_DM_TXSR_MASK			0x0000001f
+
+/* MPMC_DM_TRRD_REG	(offset: 0x0054) */
+#define MPMC_DM_TRRD_MASK			0x0000000f
+
+/* MPMC_DM_TMRD_REG	(offset: 0x0058) */
+#define MPMC_DM_TMRD_MASK			0x0000000f
+
+/* MPMC_SM_EXTWAIT_REG (offset:	0x0080) */
+#define MPMC_SM_EXTWAIT_MASK			0x0000003f
+
+
+/* MPMC_DM_CONFIG0_REG (offset: 0x0100) */
+/* MPMC_DM_CONFIG1_REG (offset: 0x0120) */
+#define DM_CFG_ROW_WIDTH_13BIT			0x20000000
+#define DM_CFG_ROW_WIDTH_12BIT			0x10000000
+#define DM_CFG_ROW_WIDTH_11BIT			0x00000000
+#define DM_CFG_ROW_WIDTH_MASK			0x30000000
+#define DM_CFG_ROW_WIDTH_SHIFT			28
+
+#define DM_CFG_2BANK_DEV			0x00000000
+#define DM_CFG_4BANK_DEV			0x04000000
+#define DM_CFG_BANK_SHIFT			26
+
+#define DM_CFG_COL_WIDTH_11BIT			0x01400000
+#define DM_CFG_COL_WIDTH_10BIT			0x01000000
+#define DM_CFG_COL_WIDTH_9BIT			0x00c00000
+#define DM_CFG_COL_WIDTH_8BIT			0x00800000
+#define DM_CFG_COL_WIDTH_7BIT			0x00400000
+#define DM_CFG_COL_WIDTH_6BIT			0x00000000
+#define DM_CFG_COL_WIDTH_MASK			0x01c00000
+#define DM_CFG_COL_WIDTH_SHIFT			22
+
+#define DM_CFG_WRITE_PROTECT			0x00100000
+#define DM_CFG_BUFFER_EN			0x00080000
+
+#define DM_CFG_ADDR_MAPPING_MASK		0x00005F80
+
+#define DM_CFG_DEV_SYNC_FLASH			0x00000010
+#define DM_CFG_DEV_LOWPOWER_SDRAM		0x00000008
+#define DM_CFG_DEV_SDRAM			0x00000000
+#define DM_CFG_DEV_MASK				0x00000018
+
+
+/* MPMC_DM_RASCAS0_REG (offset: 0x0104) */
+/* MPMC_DM_RASCAS1_REG (offset: 0x0124) */
+
+#define DM_CAS_LATENCY_3			0x00000300
+#define DM_CAS_LATENCY_2			0x00000200
+#define DM_CAS_LATENCY_1			0x00000100
+
+#define DM_RAS_LATENCY_3			0x00000003
+#define DM_RAS_LATENCY_2			0x00000002
+#define DM_RAS_LATENCY_1			0x00000001
+
+
+/* MPMC_SM_CONFIG0_REG (offset: 0x0200) */
+/* MPMC_SM_CONFIG1_REG (offset: 0x0220) */
+/* MPMC_SM_CONFIG2_REG (offset: 0x0240) */
+/* MPMC_SM_CONFIG3_REG (offset: 0x0260) */
+
+#define SM_WRITE_PROTECT			0x00100000
+#define SM_WRITEBUF_ENABLE			0x00080000
+#define SM_EXTENDED_WAIT			0x00000100
+#define SM_PB					0x00000080
+#define SM_CS_HIGH				0x00000040
+#define SM_PAGE_MODE				0x00000008
+
+#define SM_MEM_WIDTH_32BIT			0x00000002
+#define SM_MEM_WIDTH_16BIT			0x00000001
+#define SM_MEM_WIDTH_8BIT			0x00000000
+
+#define MPMC_SM_CONFIG_MASK			0x001801cb
+
+
+/* MPMC_SM_WAITWEN0_REG	(offset: 0x0204) */
+/* MPMC_SM_WAITWEN1_REG	(offset: 0x0224) */
+/* MPMC_SM_WAITWEN2_REG	(offset: 0x0244) */
+/* MPMC_SM_WAITWEN3_REG	(offset: 0x0264) */
+#define MPMC_SM_WAITWEN_MASK			0x0000000f
+
+
+/* MPMC_SM_WAITOEN0_REG (offset: 0x0208) */
+/* MPMC_SM_WAITOEN1_REG (offset: 0x0228) */
+/* MPMC_SM_WAITOEN2_REG (offset: 0x0248) */
+/* MPMC_SM_WAITOEN3_REG (offset: 0x0268) */
+#define MPMC_SM_WAITOEN_MASK			0x0000000f
+
+/* MPMC_SM_WAITRD0_REG (offset: 0x020C) */
+/* MPMC_SM_WAITRD1_REG (offset: 0x022C) */
+/* MPMC_SM_WAITRD2_REG (offset: 0x024C) */
+/* MPMC_SM_WAITRD3_REG (offset: 0x026C) */
+#define MPMC_SM_WAITRD_MASK			0x0000001f
+
+/* MPMC_SM_WAITPAGE0_REG (offset: 0x0210) */
+/* MPMC_SM_WAITPAGE1_REG (offset: 0x0230) */
+/* MPMC_SM_WAITPAGE2_REG (offset: 0x0250) */
+/* MPMC_SM_WAITPAGE3_REG (offset: 0x0270) */
+#define MPMC_SM_WAITPAGE_MASK			0x0000001f
+
+
+/* MPMC_SM_WAITWR0_REG (offset: 0x0214) */
+/* MPMC_SM_WAITWR1_REG (offset: 0x0234) */
+/* MPMC_SM_WAITWR2_REG (offset: 0x0254) */
+/* MPMC_SM_WAITWR3_REG (offset: 0x0274) */
+#define MPMC_SM_WAITWR_MASK			0x0000001f
+
+
+/* MPMC_SM_WAITTURN0_REG (offset: 0x0218) */
+/* MPMC_SM_WAITTURN1_REG (offset: 0x0238) */
+/* MPMC_SM_WAITTURN2_REG (offset: 0x0258) */
+/* MPMC_SM_WAITTURN3_REG (offset: 0x0278) */
+#define MPMC_SM_WAITTURN_MASK			0x0000000f
+
+
+/* SDRAM mode register */
+/* ref: SDRAM data sheet. Ex: Micron MT48LC4M16A2 data sheet. */
+#define SDRAM_BTLEN_1				0x0000
+#define SDRAM_BTLEN_2				0x0001
+#define SDRAM_BTLEN_4				0x0002
+#define SDRAM_BTLEN_8				0x0003
+#define SDRAM_BTLEN_FULLPAGE			0x0007
+#define SDRAM_BTLEN_MASK			0x0007
+
+#define SDRAM_BT_SEQUENCIAL			0x0000
+#define SDRAM_BT_INTERLEVED			0x0008
+
+#define SDRAM_CAS_LATENCY_2			0x0020
+#define SDRAM_CAS_LATENCY_3			0x0030
+#define SDRAM_CAS_LATENCY_MASK			0x0030
+
+#define SDRAM_OPMODE_STANDARD			0x0000
+#define SDRAM_OPMODE_MASK			0x0180
+
+#define SDRAM_WBTMODE_ENABLE			0x0000
+#define SDRAM_WBTMODE_DISABLE			0x0200
+
+#define SDRAM_MODEREG_MASK			0x03FF
+
+
+
+/*==========================  Interrupt Controller  ==========================*/
+/* registers offset */
+#define IRQ_STATUS_REG				0x00	/* Read */
+#define IRQ_RAW_STATUS_REG			0x04	/* Read */
+#define IRQ_ENABLE_REG				0x08	/* Read/Write */
+#define IRQ_DISABLE_REG				0x0C	/* Write */
+#define IRQ_SOFT_REG				0x10	/* Write */
+
+#define IRQ_MODE_REG				0x14	/* Read/Write */
+#define FIQ_STATUS_REG				0x18	/* Read */
+
+/* test registers */
+#define IRQ_TESTSRC_REG				0x1c	/* Read/Write */
+#define IRQ_SRCSEL_REG				0x20	/* Read/Write */
+#define IRQ_LEVEL_REG				0x24	/* Read/Write */
+
+/*  Macro for accessing Interrupt controller register  */
+#define ADM5120_INTC_REG(_reg)		\
+	(*((volatile unsigned long *)(KSEG1ADDR(INTC_BASE + (_reg)))))
+
+/* interrupt levels */
+#define INT_LVL_TIMER				0	/* Timer */
+#define INT_LVL_UART0				1	/* Uart 0 */
+#define INT_LVL_UART1				2	/* Uart 1 */
+#define INT_LVL_USBHOST				3	/* USB Host */
+#define INT_LVL_EXTIO_0				4	/* External I/O 0 */
+#define INT_LVL_EXTIO_1				5	/* External I/O 1 */
+#define INT_LVL_PCI_0				6	/* PCI 0 */
+#define INT_LVL_PCI_1				7	/* PCI 1 */
+#define INT_LVL_PCI_2				8	/* PCI 2 */
+#define INT_LVL_SWITCH				9	/* Switch */
+#define INT_LVL_MAX				INT_LVL_SWITCH	
+
+/* interrupts */
+#define IRQ_TIMER				(0x1 << INT_LVL_TIMER)
+#define IRQ_UART0				(0x1 << INT_LVL_UART0)
+#define IRQ_UART1				(0x1 << INT_LVL_UART1)
+#define IRQ_USBHOST				(0x1 << INT_LVL_USBHOST)
+#define IRQ_EXTIO_0				(0x1 << INT_LVL_EXTIO_0)
+#define IRQ_EXTIO_1				(0x1 << INT_LVL_EXTIO_1)
+#define IRQ_PCI_INT0				(0x1 << INT_LVL_PCI_0)
+#define IRQ_PCI_INT1				(0x1 << INT_LVL_PCI_1)
+#define IRQ_PCI_INT2				(0x1 << INT_LVL_PCI_2)
+#define IRQ_SWITCH				(0x1 << INT_LVL_SWITCH)
+
+#define IRQ_MASK				0x3ff
+
+
+/* IRQ LEVEL reg */
+#define IRQ_EXTIO0_ACT_LOW			IRQ_EXTIO_0
+#define IRQ_EXTIO1_ACT_LOW			IRQ_EXTIO_1
+#define IRQ_PCIINT0_ACT_LOW			IRQ_PCI_INT0
+#define IRQ_PCIINT1_ACT_LOW			IRQ_PCI_INT1
+#define IRQ_PCIINT2_ACT_LOW			IRQ_PCI_INT2
+
+#define IRQ_LEVEL_MASK				0x01F0
+
+/*=========================  Switch Control Register  ========================*/
+/* Control Register */
+#define CODE_REG				0x0000
+#define SftRest_REG				0x0004
+#define Boot_done_REG				0x0008
+#define SWReset_REG				0x000C
+#define Global_St_REG				0x0010
+#define PHY_st_REG				0x0014
+#define Port_st_REG				0x0018
+#define Mem_control_REG				0x001C
+#define SW_conf_REG				0x0020
+#define CPUp_conf_REG				0x0024
+#define Port_conf0_REG				0x0028
+#define Port_conf1_REG				0x002C
+#define Port_conf2_REG				0x0030
+
+#define VLAN_G1_REG				0x0040
+#define VLAN_G2_REG				0x0044
+#define Send_trig_REG				0x0048
+#define Srch_cmd_REG				0x004C
+#define ADDR_st0_REG				0x0050
+#define ADDR_st1_REG				0x0054
+#define MAC_wt0_REG				0x0058
+#define MAC_wt1_REG				0x005C
+#define BW_cntl0_REG				0x0060
+#define BW_cntl1_REG				0x0064
+#define PHY_cntl0_REG				0x0068
+#define PHY_cntl1_REG				0x006C
+#define FC_th_REG				0x0070
+#define Adj_port_th_REG				0x0074
+#define Port_th_REG				0x0078
+#define PHY_cntl2_REG				0x007C
+#define PHY_cntl3_REG				0x0080
+#define Pri_cntl_REG				0x0084
+#define VLAN_pri_REG				0x0088
+#define TOS_en_REG				0x008C
+#define TOS_map0_REG				0x0090
+#define TOS_map1_REG				0x0094
+#define Custom_pri1_REG				0x0098
+#define Custom_pri2_REG				0x009C
+
+#define Empty_cnt_REG				0x00A4
+#define Port_cnt_sel_REG			0x00A8
+#define Port_cnt_REG				0x00AC
+#define SW_Int_st_REG				0x00B0
+#define SW_Int_mask_REG				0x00B4
+
+// GPIO config
+#define GPIO_conf0_REG				0x00B8
+#define GPIO_conf2_REG				0x00BC
+
+// Watch dog
+#define Watchdog0_REG				0x00C0
+#define Watchdog1_REG				0x00C4
+
+#define Swap_in_REG				0x00C8
+#define Swap_out_REG				0x00CC
+
+// Tx/Rx Descriptors
+#define Send_HBaddr_REG				0x00D0
+#define Send_LBaddr_REG				0x00D4
+#define Recv_HBaddr_REG				0x00D8
+#define Recv_LBaddr_REG				0x00DC
+#define Send_HWaddr_REG				0x00E0
+#define Send_LWaddr_REG				0x00E4
+#define Recv_HWaddr_REG				0x00E8
+#define Recv_LWaddr_REG				0x00EC
+
+// Timer Control 
+#define Timer_int_REG				0x00F0
+#define Timer_REG				0x00F4
+
+// LED control
+#define Port0_LED_REG				0x0100
+#define Port1_LED_REG				0x0104
+#define Port2_LED_REG				0x0108
+#define Port3_LED_REG				0x010c
+#define Port4_LED_REG				0x0110
+
+
+/* Macros for accessing Switch control register */
+#define ADM5120_SW_REG(_reg)		\
+	(*((volatile unsigned long *)(KSEG1ADDR(SWCTRL_BASE + (_reg)))))
+
+
+
+/* CODE_REG */
+#define CODE_ID_MASK				0x00FFFF
+#define CODE_ADM5120_ID				0x5120
+
+#define CODE_REV_MASK				0x0F0000
+#define CODE_REV_SHIFT				16
+#define CODE_REV_ADM5120_0			0x8
+
+#define CODE_CLK_MASK				0x300000
+#define CODE_CLK_SHIFT				20
+
+#define CPU_CLK_175MHZ				0x0
+#define CPU_CLK_200MHZ				0x1
+#define CPU_CLK_225MHZ				0x2
+#define CPU_CLK_250MHZ				0x3
+
+#define CPU_SPEED_175M				(175000000/2)
+#define CPU_SPEED_200M				(200000000/2)
+#define CPU_SPEED_225M				(225000000/2)
+#define CPU_SPEED_250M				(250000000/2)
+
+#define CPU_NAND_BOOT				0x01000000
+#define CPU_DCACHE_2K_WAY			(0x1 << 25)
+#define CPU_DCACHE_2WAY				(0x1 << 26)
+#define CPU_ICACHE_2K_WAY			(0x1 << 27)
+#define CPU_ICACHE_2WAY				(0x1 << 28)
+
+#define CPU_GMII_SUPPORT			0x20000000
+
+#define CPU_PQFP_MODE				(0x1 << 29)
+
+#define CPU_CACHE_LINE_SIZE			16
+
+/* SftRest_REG	*/
+#define SOFTWARE_RESET				0x1
+
+/* Boot_done_REG */
+#define BOOT_DONE				0x1
+
+/* SWReset_REG */
+#define SWITCH_RESET				0x1
+
+/* Global_St_REG */
+#define DATA_BUF_BIST_FAILED			(0x1 << 0)
+#define LINK_TAB_BIST_FAILED			(0x1 << 1)
+#define MC_TAB_BIST_FAILED			(0x1 << 2)
+#define ADDR_TAB_BIST_FAILED			(0x1 << 3)
+#define DCACHE_D_FAILED				(0x3 << 4)
+#define DCACHE_T_FAILED				(0x1 << 6)
+#define ICACHE_D_FAILED				(0x3 << 7)
+#define ICACHE_T_FAILED				(0x1 << 9)
+#define BIST_FAILED_MASK			0x03FF
+
+#define ALLMEM_TEST_DONE			(0x1 << 10)
+
+#define SKIP_BLK_CNT_MASK			0x1FF000
+#define SKIP_BLK_CNT_SHIFT			12
+
+
+/* PHY_st_REG */
+#define PORT_LINK_MASK				0x0000001F
+#define PORT_MII_LINKFAIL			0x00000020
+#define PORT_SPEED_MASK				0x00001F00
+
+#define PORT_GMII_SPD_MASK			0x00006000
+#define PORT_GMII_SPD_10M			0
+#define PORT_GMII_SPD_100M			0x00002000
+#define PORT_GMII_SPD_1000M			0x00004000
+
+#define PORT_DUPLEX_MASK			0x003F0000
+#define PORT_FLOWCTRL_MASK			0x1F000000
+
+#define PORT_GMII_FLOWCTRL_MASK			0x60000000
+#define PORT_GMII_FC_ON				0x20000000
+#define PORT_GMII_RXFC_ON			0x20000000
+#define PORT_GMII_TXFC_ON			0x40000000
+
+/* Port_st_REG */
+#define PORT_SECURE_ST_MASK			0x001F
+#define MII_PORT_TXC_ERR			0x0080
+
+/* Mem_control_REG */
+#define SDRAM_SIZE_4MBYTES			0x0001
+#define SDRAM_SIZE_8MBYTES			0x0002
+#define SDRAM_SIZE_16MBYTES			0x0003
+#define SDRAM_SIZE_64MBYTES			0x0004
+#define SDRAM_SIZE_128MBYTES			0x0005
+#define SDRAM_SIZE_MASK				0x0007
+
+#define MEMCNTL_SDRAM1_EN			(0x1 << 5)
+
+#define ROM_SIZE_DISABLE			0x0000
+#define ROM_SIZE_512KBYTES			0x0001
+#define ROM_SIZE_1MBYTES			0x0002
+#define	ROM_SIZE_2MBYTES			0x0003
+#define ROM_SIZE_4MBYTES			0x0004
+#define ROM_SIZE_8MBYTES			0x0005
+#define ROM_SIZE_MASK				0x0007
+
+#define ROM0_SIZE_SHIFT				8
+#define ROM1_SIZE_SHIFT				16
+
+
+/* SW_conf_REG */
+#define SW_AGE_TIMER_MASK			0x000000F0
+#define SW_AGE_TIMER_DISABLE			0x0
+#define SW_AGE_TIMER_FAST			0x00000080
+#define SW_AGE_TIMER_300SEC			0x00000010
+#define SW_AGE_TIMER_600SEC			0x00000020
+#define SW_AGE_TIMER_1200SEC			0x00000030
+#define SW_AGE_TIMER_2400SEC			0x00000040
+#define SW_AGE_TIMER_4800SEC			0x00000050
+#define SW_AGE_TIMER_9600SEC			0x00000060
+#define SW_AGE_TIMER_19200SEC			0x00000070
+//#define SW_AGE_TIMER_38400SEC			0x00000070
+
+#define SW_BC_PREV_MASK				0x00000300
+#define SW_BC_PREV_DISABLE			0
+#define SW_BC_PREV_64BC				0x00000100
+#define SW_BC_PREV_48BC				0x00000200
+#define SW_BC_PREV_32BC				0x00000300
+
+#define SW_MAX_LEN_MASK				0x00000C00
+#define SW_MAX_LEN_1536				0
+#define SW_MAX_LEN_1522				0x00000800
+#define SW_MAX_LEN_1518				0x00000400
+
+#define SW_DIS_COLABT				0x00001000
+
+#define SW_HASH_ALG_MASK			0x00006000
+#define SW_HASH_ALG_DIRECT			0
+#define SW_HASH_ALG_XOR48			0x00002000
+#define SW_HASH_ALG_XOR32			0x00004000
+
+#define SW_DISABLE_BACKOFF_TIMER		0x00008000
+
+#define SW_BP_NUM_MASK				0x000F0000
+#define SW_BP_NUM_SHIFT				16
+#define SW_BP_MODE_MASK				0x00300000
+#define SW_BP_MODE_DISABLE			0
+#define SW_BP_MODE_JAM				0x00100000
+#define SW_BP_MODE_JAMALL			0x00200000
+#define SW_BP_MODE_CARRIER			0x00300000
+#define SW_RESRV_MC_FILTER			0x00400000
+#define SW_BISR_DISABLE				0x00800000
+
+#define SW_DIS_MII_WAS_TX			0x01000000
+#define SW_BISS_EN				0x02000000
+#define SW_BISS_TH_MASK				0x0C000000
+#define SW_BISS_TH_SHIFT			26
+#define SW_REQ_LATENCY_MASK			0xF0000000
+#define SW_REQ_LATENCY_SHIFT			28
+
+
+/* CPUp_conf_REG */
+#define SW_CPU_PORT_DISABLE			0x00000001
+#define SW_PADING_CRC				0x00000002
+#define SW_BRIDGE_MODE				0x00000004
+
+#define SW_DIS_UN_SHIFT				9
+#define SW_DIS_UN_MASK				(0x3F << SW_DIS_UN_SHIFT)
+#define SW_DIS_MC_SHIFT				16
+#define SW_DIS_MC_MASK				(0x3F << SW_DIS_MC_SHIFT)
+#define SW_DIS_BC_SHIFT				24
+#define SW_DIS_BC_MASK				(0x3F << SW_DIS_BC_SHIFT)
+
+
+/* Port_conf0_REG */
+#define SW_DISABLE_PORT_MASK			0x0000003F
+#define SW_EN_MC_MASK				0x00003F00
+#define SW_EN_MC_SHIFT				8
+#define SW_EN_BP_MASK				0x003F0000
+#define SW_EN_BP_SHIFT				16
+#define SW_EN_FC_MASK				0x3F000000
+#define SW_EN_FC_SHIFT				24
+
+
+/* Port_conf1_REG */
+#define SW_DIS_SA_LEARN_MASK			0x0000003F
+#define SW_PORT_BLOCKING_MASK			0x00000FC0
+#define SW_PORT_BLOCKING_SHIFT			6
+#define SW_PORT_BLOCKING_ON			0x1
+
+#define SW_PORT_BLOCKING_MODE_MASK		0x0003F000
+#define SW_PORT_BLOCKING_MODE_SHIFT		12
+#define SW_PORT_BLOCKING_CTRLONLY		0x1
+
+#define SW_EN_PORT_AGE_MASK			0x03F00000
+#define SW_EN_PORT_AGE_SHIFT			20
+#define SW_EN_SA_SECURED_MASK			0xFC000000
+#define SW_EN_SA_SECURED_SHIFT			26
+
+
+/* Port_conf2_REG */
+#define SW_GMII_AN_EN				0x00000001
+#define SW_GMII_FORCE_SPD_MASK			0x00000006
+#define SW_GMII_FORCE_SPD_10M			0
+#define SW_GMII_FORCE_SPD_100M			0x2
+#define SW_GMII_FORCE_SPD_1000M			0x4
+
+#define SW_GMII_FORCE_FULL_DUPLEX		0x00000008
+
+#define SW_GMII_FORCE_RXFC			0x00000010
+#define SW_GMII_FORCE_TXFC			0x00000020
+
+#define SW_GMII_EN				0x00000040
+#define SW_GMII_REVERSE				0x00000080
+
+#define SW_GMII_TXC_CHECK_EN			0x00000100
+
+#define SW_LED_FLASH_TIME_MASK			0x00030000
+#define SW_LED_FLASH_TIME_30MS			0
+#define SW_LED_FLASH_TIME_60MS			0x00010000
+#define SW_LED_FLASH_TIME_240MS			0x00020000
+#define SW_LED_FLASH_TIME_480MS			0x00030000
+
+
+/* Send_trig_REG */
+#define SEND_TRIG_LOW				0x0001
+#define SEND_TRIG_HIGH				0x0002
+
+
+/* Srch_cmd_REG */
+#define SW_MAC_SEARCH_START			0x000001
+#define SW_MAX_SEARCH_AGAIN			0x000002
+
+/* MAC_wt0_REG */
+#define SW_MAC_WRITE				0x00000001
+#define SW_MAC_WRITE_DONE			0x00000002
+#define SW_MAC_FILTER_EN			0x00000004
+#define SW_MAC_VLANID_SHIFT			3
+#define SW_MAC_VLANID_MASK			0x00000038
+#define SW_MAC_VLANID_EN			0x00000040
+#define SW_MAC_PORTMAP_MASK			0x00001F80
+#define SW_MAC_PORTMAP_SHIFT			7
+#define SW_MAC_AGE_MASK				(0x7 << 13)
+#define SW_MAC_AGE_STATIC			(0x7 << 13)
+#define SW_MAC_AGE_VALID			(0x1 << 13)
+#define SW_MAC_AGE_EMPTY			0
+
+/* BW_cntl0_REG */
+#define SW_PORT_TX_NOLIMIT			0
+#define SW_PORT_TX_64K				1
+#define SW_PORT_TX_128K				2
+#define SW_PORT_TX_256K				3
+#define SW_PORT_TX_512K				4
+#define SW_PORT_TX_1M				5
+#define SW_PORT_TX_4M				6
+#define SW_PORT_TX_10MK				7
+
+/* BW_cntl1_REG */
+#define SW_TRAFFIC_SHAPE_IPG			(0x1 << 31)
+
+/* PHY_cntl0_REG */
+#define SW_PHY_ADDR_MASK			0x0000001F
+#define PHY_ADDR_MAX				0x1f
+#define SW_PHY_REG_ADDR_MASK			0x00001F00
+#define SW_PHY_REG_ADDR_SHIFT			8
+#define PHY_REG_ADDR_MAX			0x1f
+#define SW_PHY_WRITE				0x00002000
+#define SW_PHY_READ				0x00004000
+#define SW_PHY_WDATA_MASK			0xFFFF0000
+#define SW_PHY_WDATA_SHIFT			16
+
+
+/* PHY_cntl1_REG */
+#define SW_PHY_WRITE_DONE			0x00000001
+#define SW_PHY_READ_DONE			0x00000002
+#define SW_PHY_RDATA_MASK			0xFFFF0000
+#define SW_PHY_RDATA_SHIFT			16
+
+/* FC_th_REG */
+/* Adj_port_th_REG */
+/* Port_th_REG */
+
+/* PHY_cntl2_REG */
+#define SW_PHY_AN_MASK				0x0000001F
+#define SW_PHY_SPD_MASK				0x000003E0
+#define SW_PHY_SPD_SHIFT			5
+#define SW_PHY_DPX_MASK				0x00007C00
+#define SW_PHY_DPX_SHIFT			10
+#define SW_FORCE_FC_MASK			0x000F8000
+#define SW_FORCE_FC_SHIFT			15
+#define SW_PHY_NORMAL_MASK			0x01F00000
+#define SW_PHY_NORMAL_SHIFT			20
+#define SW_PHY_AUTOMDIX_MASK			0x3E000000
+#define SW_PHY_AUTOMDIX_SHIFT			25
+#define SW_PHY_REC_MCCAVERAGE			0x40000000
+
+
+/* PHY_cntl3_REG */
+/* Pri_cntl_REG */
+/* VLAN_pri_REG */
+/* TOS_en_REG */
+/* TOS_map0_REG */
+/* TOS_map1_REG */
+/* Custom_pri1_REG */
+/* Custom_pri2_REG */
+/* Empty_cnt_REG */
+/* Port_cnt_sel_REG */
+/* Port_cnt_REG */
+
+
+/* SW_Int_st_REG & SW_Int_mask_REG */
+#define SEND_H_DONE_INT				0x0000001
+#define SEND_L_DONE_INT				0x0000002
+#define RX_H_DONE_INT				0x0000004
+#define RX_L_DONE_INT				0x0000008
+#define RX_H_DESC_FULL_INT			0x0000010
+#define RX_L_DESC_FULL_INT			0x0000020
+#define PORT0_QUE_FULL_INT			0x0000040
+#define PORT1_QUE_FULL_INT			0x0000080
+#define PORT2_QUE_FULL_INT			0x0000100
+#define PORT3_QUE_FULL_INT			0x0000200
+#define PORT4_QUE_FULL_INT			0x0000400
+#define PORT5_QUE_FULL_INT			0x0000800
+
+#define CPU_QUE_FULL_INT			0x0002000
+#define GLOBAL_QUE_FULL_INT			0x0004000
+#define MUST_DROP_INT				0x0008000
+#define BC_STORM_INT				0x0010000
+
+#define PORT_STATUS_CHANGE_INT			0x0040000
+#define INTRUDER_INT				0x0080000
+#define	WATCHDOG0_EXPR_INT			0x0100000
+#define WATCHDOG1_EXPR_INT			0x0200000
+#define RX_DESC_ERR_INT				0x0400000
+#define SEND_DESC_ERR_INT			0x0800000
+#define CPU_HOLD_INT				0x1000000
+#define SWITCH_INT_MASK				0x1FDEFFF
+
+
+/* GPIO_conf0_REG */
+#define GPIO0_INPUT_MODE			0x00000001
+#define GPIO1_INPUT_MODE			0x00000002
+#define GPIO2_INPUT_MODE			0x00000004
+#define GPIO3_INPUT_MODE			0x00000008
+#define GPIO4_INPUT_MODE			0x00000010
+#define GPIO5_INPUT_MODE			0x00000020
+#define GPIO6_INPUT_MODE			0x00000040
+#define GPIO7_INPUT_MODE			0x00000080
+
+#define GPIO0_OUTPUT_MODE			0
+#define GPIO1_OUTPUT_MODE			0
+#define GPIO2_OUTPUT_MODE			0
+#define GPIO3_OUTPUT_MODE			0
+#define GPIO4_OUTPUT_MODE			0
+#define GPIO5_OUTPUT_MODE			0
+#define GPIO6_OUTPUT_MODE			0
+#define GPIO7_OUTPUT_MODE			0
+
+#define GPIO0_INPUT_MASK			0x00000100
+#define GPIO1_INPUT_MASK			0x00000200
+#define GPIO2_INPUT_MASK			0x00000400
+#define GPIO3_INPUT_MASK			0x00000800
+#define GPIO4_INPUT_MASK			0x00001000
+#define GPIO5_INPUT_MASK			0x00002000
+#define GPIO6_INPUT_MASK			0x00004000
+#define GPIO7_INPUT_MASK			0x00008000
+
+#define GPIO0_OUTPUT_EN				0x00010000
+#define GPIO1_OUTPUT_EN				0x00020000
+#define GPIO2_OUTPUT_EN				0x00040000
+#define GPIO3_OUTPUT_EN				0x00080000
+#define GPIO4_OUTPUT_EN				0x00100000
+#define GPIO5_OUTPUT_EN				0x00200000
+#define GPIO6_OUTPUT_EN				0x00400000
+#define GPIO7_OUTPUT_EN				0x00800000
+
+#define GPIO_CONF0_OUTEN_MASK			0x00ff0000
+
+#define GPIO0_OUTPUT_HI				0x01000000
+#define GPIO1_OUTPUT_HI				0x02000000
+#define GPIO2_OUTPUT_HI				0x04000000
+#define GPIO3_OUTPUT_HI				0x08000000
+#define GPIO4_OUTPUT_HI				0x10000000
+#define GPIO5_OUTPUT_HI				0x20000000
+#define GPIO6_OUTPUT_HI				0x40000000
+#define GPIO7_OUTPUT_HI				0x80000000
+
+#define GPIO0_OUTPUT_LOW			0
+#define GPIO1_OUTPUT_LOW			0
+#define GPIO2_OUTPUT_LOW			0
+#define GPIO3_OUTPUT_LOW			0
+#define GPIO4_OUTPUT_LOW			0
+#define GPIO5_OUTPUT_LOW			0
+#define GPIO6_OUTPUT_LOW			0
+#define GPIO7_OUTPUT_LOW			0
+
+
+/* GPIO_conf2_REG */
+#define EXTIO_WAIT_EN				(0x1 << 6)
+#define EXTIO_CS1_INT1_EN			(0x1 << 5)
+#define EXTIO_CS0_INT0_EN			(0x1 << 4)
+
+/* Watchdog0_REG, Watchdog1_REG */
+#define WATCHDOG0_RESET_EN			0x80000000
+#define WATCHDOG1_DROP_EN			0x80000000
+
+#define WATCHDOG_TIMER_SET_MASK			0x7FFF0000
+#define WATCHDOG_TIMER_SET_SHIFT		16
+#define WATCHDOG_TIMER_MASK			0x00007FFF
+
+
+/* Timer_int_REG */
+#define SW_TIMER_INT_DISABLE			0x10000
+#define SW_TIMER_INT				0x1
+
+/* Timer_REG */
+#define SW_TIMER_EN				0x10000
+#define SW_TIMER_MASK				0xffff
+#define SW_TIMER_10MS_TICKS			0x3D09
+#define SW_TIMER_1MS_TICKS			0x61A
+#define SW_TIMER_100US_TICKS			0x9D
+
+
+/* Port0_LED_REG, Port1_LED_REG, Port2_LED_REG, Port3_LED_REG, Port4_LED_REG*/
+#define GPIOL_INPUT_MODE			0x00
+#define GPIOL_OUTPUT_FLASH			0x01
+#define GPIOL_OUTPUT_LOW			0x02
+#define GPIOL_OUTPUT_HIGH			0x03
+#define GPIOL_LINK_LED				0x04
+#define GPIOL_SPEED_LED				0x05
+#define GPIOL_DUPLEX_LED			0x06
+#define GPIOL_ACT_LED				0x07
+#define GPIOL_COL_LED				0x08
+#define GPIOL_LINK_ACT_LED			0x09
+#define GPIOL_DUPLEX_COL_LED			0x0A
+#define GPIOL_10MLINK_ACT_LED			0x0B
+#define GPIOL_100MLINK_ACT_LED			0x0C
+#define GPIOL_CTRL_MASK				0x0F
+
+#define GPIOL_INPUT_MASK			0x7000
+#define GPIOL_INPUT_0_MASK			0x1000
+#define GPIOL_INPUT_1_MASK			0x2000
+#define GPIOL_INPUT_2_MASK			0x4000
+
+#define PORT_LED0_SHIFT				0
+#define PORT_LED1_SHIFT				4
+#define PORT_LED2_SHIFT				8
+
+
+/*===========================  UART Control Register  ========================*/
+#define UART_DR_REG				0x00
+#define UART_RSR_REG				0x04
+#define UART_ECR_REG				0x04
+#define UART_LCR_H_REG				0x08
+#define UART_LCR_M_REG				0x0c
+#define UART_LCR_L_REG				0x10
+#define UART_CR_REG				0x14
+#define UART_FR_REG				0x18
+#define UART_IIR_REG				0x1c
+#define UART_ICR_REG				0x1C
+#define UART_ILPR_REG				0x20
+
+/*  rsr/ecr reg  */
+#define UART_OVERRUN_ERR			0x08
+#define UART_BREAK_ERR				0x04
+#define UART_PARITY_ERR				0x02
+#define UART_FRAMING_ERR			0x01
+#define UART_RX_STATUS_MASK			0x0f
+#define UART_RX_ERROR				( UART_BREAK_ERR | UART_PARITY_ERR | UART_FRAMING_ERR)
+
+/*  lcr_h reg  */
+#define UART_SEND_BREAK				0x01
+#define UART_PARITY_EN				0x02
+#define UART_EVEN_PARITY			0x04
+#define UART_TWO_STOP_BITS			0x08
+#define UART_ENABLE_FIFO			0x10
+
+#define UART_WLEN_5BITS				0x00
+#define UART_WLEN_6BITS				0x20
+#define UART_WLEN_7BITS				0x40
+#define UART_WLEN_8BITS				0x60
+#define UART_WLEN_MASK				0x60
+
+/*  cr reg  */
+#define UART_PORT_EN				0x01
+#define UART_SIREN				0x02
+#define UART_SIRLP				0x04
+#define UART_MODEM_STATUS_INT_EN		0x08
+#define UART_RX_INT_EN				0x10
+#define UART_TX_INT_EN				0x20
+#define UART_RX_TIMEOUT_INT_EN			0x40
+#define UART_LOOPBACK_EN			0x80
+
+/*  fr reg  */
+#define UART_CTS				0x01
+#define UART_DSR				0x02
+#define UART_DCD				0x04
+#define UART_BUSY				0x08
+#define UART_RX_FIFO_EMPTY			0x10
+#define UART_TX_FIFO_FULL			0x20
+#define UART_RX_FIFO_FULL			0x40
+#define UART_TX_FIFO_EMPTY			0x80
+
+/*  iir/icr reg  */
+#define UART_MODEM_STATUS_INT			0x01
+#define UART_RX_INT				0x02
+#define UART_TX_INT				0x04
+#define UART_RX_TIMEOUT_INT			0x08
+
+#define UART_INT_MASK				0x0f
+
+#define ADM5120_UARTCLK_FREQ			62500000
+
+#define UART_BAUDDIV(_rate)			((unsigned long)(ADM5120_UARTCLK_FREQ/(16*(_rate)) - 1))
+
+/*  uart_baudrate  */
+#define UART_230400bps_DIVISOR			UART_BAUDDIV(230400)
+#define UART_115200bps_DIVISOR			UART_BAUDDIV(115200)
+#define UART_76800bps_DIVISOR			UART_BAUDDIV(76800)
+#define UART_57600bps_DIVISOR			UART_BAUDDIV(57600)
+#define UART_38400bps_DIVISOR			UART_BAUDDIV(38400)
+#define UART_19200bps_DIVISOR			UART_BAUDDIV(19200)
+#define UART_14400bps_DIVISOR			UART_BAUDDIV(14400)
+#define UART_9600bps_DIVISOR			UART_BAUDDIV(9600)
+#define UART_2400bps_DIVISOR			UART_BAUDDIV(2400)
+#define UART_1200bps_DIVISOR			UART_BAUDDIV(1200)
+
+
+/* Cache Controller */
+//#define ADM5120_CACHE_CTRL_BASE		0x70000000
+#define ADM5120_CACHE_LINE_SIZE			16
+//#define ADM5120_CACHE_CTRL_REGSIZE		4
+
+
+/********** GPIO macro *************/
+#define GPIO_MEASURE	0x000f00f0 //enable output status of pin 0, 1, 2, 3 
+
+#define GPIO_MEASURE_INIT() \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) = GPIO_MEASURE; \
+} while (0)
+
+
+#define GPIO_SET_HI(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) |= 1 << (24 + num); \
+} while (0)
+
+
+#define GPIO_SET_LOW(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) &= ~(1 << (24 + num)); \
+} while (0)
+
+
+#define GPIO_TOGGLE(num) \
+do { \
+	ADM5120_SW_REG(GPIO_conf0_REG) ^= (1 << (24 + num)); \
+} while (0)
+
+
+#define BOOT_LINE_SIZE		256
+#define BSP_STR_LEN		64
+
+/*
+ * System configuration
+ */
+/*typedef struct BOARD_CFG_S
+{
+	unsigned long blmagic;
+	unsigned char bootline[BOOT_LINE_SIZE+1];
+	
+	unsigned long macmagic;
+	unsigned char mac[4][8];
+
+	unsigned long idmagic;    
+	unsigned char serial[BSP_STR_LEN+1];
+
+	unsigned long vermagic;
+	unsigned char ver[BSP_STR_LEN+1];
+	
+} BOARD_CFG_T, *PBOARD_CFG_T;
+
+
+#define BL_MAGIC			0x6c62676d
+#define MAC_MAGIC			0x636d676d
+#define VER_MAGIC			0x7276676d
+#define ID_MAGIC			0x6469676d
+*/
+typedef struct BOARD_CFG_S
+{
+	unsigned long macmagic;
+	unsigned char sr[3];
+	unsigned char mac[3][6];
+	
+} BOARD_CFG_T, *PBOARD_CFG_T;
+
+
+#define MAC_MAGIC			0x31305348
+
+
+#endif /* __ADM5120_H__ */
diff -urN linux-2.4.32/include/asm-mips/am5120/mx29lv320b.h linux-2.4.32-adm5120/include/asm-mips/am5120/mx29lv320b.h
--- linux-2.4.32/include/asm-mips/am5120/mx29lv320b.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/include/asm-mips/am5120/mx29lv320b.h	2005-12-20 12:52:09.000000000 +0200
@@ -0,0 +1,75 @@
+/*****************************************************************************
+;
+;   (C) Unpublished Work of ADMtek Incorporated.  All Rights Reserved.
+;
+;       THIS WORK IS AN UNPUBLISHED WORK AND CONTAINS CONFIDENTIAL,
+;       PROPRIETARY AND TRADESECRET INFORMATION OF ADMTEK INCORPORATED.
+;       ACCESS TO THIS WORK IS RESTRICTED TO (I) ADMTEK EMPLOYEES WHO HAVE A
+;       NEED TO KNOW TO PERFORM TASKS WITHIN THE SCOPE OF THEIR ASSIGNMENTS
+;       AND (II) ENTITIES OTHER THAN ADMTEK WHO HAVE ENTERED INTO APPROPRIATE
+;       LICENSE AGREEMENTS.  NO PART OF THIS WORK MAY BE USED, PRACTICED,
+;       PERFORMED, COPIED, DISTRIBUTED, REVISED, MODIFIED, TRANSLATED,
+;       ABBRIDGED, CONDENSED, EXPANDED, COLLECTED, COMPILED, LINKED, RECAST,
+;       TRANSFORMED OR ADAPTED WITHOUT THE PRIOR WRITTEN CONSENT OF ADMTEK.
+;       ANY USE OR EXPLOITATION OF THIS WORK WITHOUT AUTHORIZATION COULD
+;       SUBJECT THE PERPERTRATOR TO CRIMINAL AND CIVIL LIABILITY.
+;
+;------------------------------------------------------------------------------
+;
+;    Project : ADM5120
+;    Creator : 
+;    File    : include/asm/am5120/mx29lv320b.h
+;    Date    : 2003.07.30
+;    Abstract: 
+;
+;Modification History:
+; 
+;
+;*****************************************************************************/
+
+
+#ifndef  __MX29LV320B_H__
+#define  __MX29LV320B_H__
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define FLASH_PHYS_ADDR 	0x1FC00000
+
+#include<asm/am5120/mx_parts.h>
+
+#define FLASH_PART_ROOT_ADDR (FLASH_PART_KERNEL_ADDR + FLASH_PART_KERNEL_SIZE)
+#define FLASH_PART_DATA_ADDR (FLASH_PART_ROOT_ADDR + FLASH_PART_ROOT_SIZE)
+#define FLASH_PART_DATA_SIZE (FLASH_SIZE - FLASH_PART_DATA_ADDR)
+
+
+struct mtd_partition mx29lv320b_parts[] = {
+	{
+		.name =		"Boot Partition",
+		.offset =	FLASH_PART_BOOT_ADDR,
+		.size =		FLASH_PART_BOOT_SIZE,
+		.mask_flags =   MTD_WRITEABLE
+	},
+	{
+		.name =		"Kernel",
+		.offset =	FLASH_PART_KERNEL_ADDR,
+		.size =		FLASH_PART_KERNEL_SIZE
+	},
+	{
+		.name =		"Root",
+		.offset =	FLASH_PART_ROOT_ADDR,
+		.size =		FLASH_PART_ROOT_SIZE
+	},
+	{
+		.name =		"Data",
+		.offset =	FLASH_PART_DATA_ADDR,
+		.size =		FLASH_PART_DATA_SIZE
+//		.mask_flags =   MTD_WRITEABLE
+	}
+};
+
+#define PARTITION_COUNT (sizeof(mx29lv320b_parts)/sizeof(struct mtd_partition))
+
+#endif /* __MX29LV320B_H__ */
+
diff -urN linux-2.4.32/include/asm-mips/am5120/prom.h linux-2.4.32-adm5120/include/asm-mips/am5120/prom.h
--- linux-2.4.32/include/asm-mips/am5120/prom.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/include/asm-mips/am5120/prom.h	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * MIPS boards bootprom interface for the Linux kernel.
+ *
+ */
+
+#ifndef _MIPS_PROM_H
+#define _MIPS_PROM_H
+
+extern char *prom_getcmdline(void);
+extern char *prom_getenv(char *name);
+extern void setup_prom_printf(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern void prom_init_cmdline(void);
+extern void prom_meminit(void);
+extern void prom_fixup_mem_map(unsigned long start_mem, unsigned long end_mem);
+extern void prom_free_prom_memory (void);
+extern void mips_display_message(const char *str);
+extern void mips_display_word(unsigned int num);
+extern int get_ethernet_addr(char *ethernet_addr);
+
+/* Memory descriptor management. */
+#define PROM_MAX_PMEMBLOCKS    32
+struct prom_pmemblock {
+        unsigned long base; /* Within KSEG0. */
+        unsigned int size;  /* In bytes. */
+        unsigned int type;  /* free or prom memory */
+};
+
+#endif /* !(_MIPS_PROM_H) */
diff -urN linux-2.4.32/include/asm-mips/bootinfo.h linux-2.4.32-adm5120/include/asm-mips/bootinfo.h
--- linux-2.4.32/include/asm-mips/bootinfo.h	2005-12-20 12:42:58.000000000 +0200
+++ linux-2.4.32-adm5120/include/asm-mips/bootinfo.h	2005-12-20 12:22:42.000000000 +0200
@@ -37,6 +37,7 @@
 #define MACH_GROUP_HP_LJ       20 /* Hewlett Packard LaserJet               */
 #define MACH_GROUP_LASAT       21
 #define MACH_GROUP_TITAN       22 /* PMC-Sierra Titan 			    */
+#define MACH_GROUP_ADM_GW      23
 
 /*
  * Valid machtype values for group unknown (low order halfword of mips_machtype)
@@ -197,6 +198,12 @@
 #define MACH_TANBAC_TB0229	7	/* TANBAC TB0229 (VR4131DIMM) */
 
 /*
+ * Valid machtype for group ADM_GW
+ */
+#define MACH_ADM_GW_5120	0
+
+
+/*
  * Valid machtype for group TITAN
  */
 #define	MACH_TITAN_YOSEMITE	1 	/* PMC-Sierra Yosemite */
diff -urN linux-2.4.32/include/asm-mips/gt64120.h linux-2.4.32-adm5120/include/asm-mips/gt64120.h
--- linux-2.4.32/include/asm-mips/gt64120.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/include/asm-mips/gt64120.h	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,399 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+#ifndef _ASM_GT64120_H
+#define _ASM_GT64120_H
+
+#define MSK(n)                    ((1 << (n)) - 1)
+
+/*
+ *  Register offset addresses
+ */
+#define GT_CPU_OFS		0x000
+
+/*
+ * Interrupt Registers
+ */
+#define GT_SCS10LD_OFS		0x008
+#define GT_SCS10HD_OFS		0x010
+#define GT_SCS32LD_OFS		0x018
+#define GT_SCS32HD_OFS		0x020
+#define GT_CS20LD_OFS		0x028
+#define GT_CS20HD_OFS		0x030
+#define GT_CS3BOOTLD_OFS	0x038
+#define GT_CS3BOOTHD_OFS	0x040
+#define GT_PCI0IOLD_OFS		0x048
+#define GT_PCI0IOHD_OFS		0x050
+#define GT_PCI0M0LD_OFS		0x058
+#define GT_PCI0M0HD_OFS		0x060
+#define GT_ISD_OFS		0x068
+#define GT_PCI0M1LD_OFS		0x080
+#define GT_PCI0M1HD_OFS		0x088
+#define GT_PCI1IOLD_OFS		0x090
+#define GT_PCI1IOHD_OFS		0x098
+#define GT_PCI1M0LD_OFS		0x0a0
+#define GT_PCI1M0HD_OFS		0x0a8
+#define GT_PCI1M1LD_OFS		0x0b0
+#define GT_PCI1M1HD_OFS		0x0b8
+
+/*
+ * GT64120A only
+ */
+#define GT_PCI0IOREMAP_OFS	0x0f0
+#define GT_PCI0M0REMAP_OFS	0x0f8
+#define GT_PCI0M1REMAP_OFS	0x100
+#define GT_PCI1IOREMAP_OFS	0x108
+#define GT_PCI1M0REMAP_OFS	0x110
+#define GT_PCI1M1REMAP_OFS	0x118
+
+#define GT_SCS0LD_OFS		0x400	
+#define GT_SCS0HD_OFS		0x404
+#define GT_SCS1LD_OFS		0x408
+#define GT_SCS1HD_OFS		0x40c
+#define GT_SCS2LD_OFS		0x410
+#define GT_SCS2HD_OFS		0x414
+#define GT_SCS3LD_OFS		0x418
+#define GT_SCS3HD_OFS		0x41c
+#define GT_CS0LD_OFS		0x420
+#define GT_CS0HD_OFS		0x424
+#define GT_CS1LD_OFS		0x428
+#define GT_CS1HD_OFS		0x42c
+#define GT_CS2LD_OFS		0x430
+#define GT_CS2HD_OFS		0x434
+#define GT_CS3LD_OFS		0x438
+#define GT_CS3HD_OFS		0x43c
+#define GT_BOOTLD_OFS		0x440
+#define GT_BOOTHD_OFS		0x444
+
+#define GT_SDRAM_B0_OFS	    	0x44c
+#define GT_SDRAM_CFG_OFS	0x448
+#define GT_SDRAM_B2_OFS		0x454
+#define GT_SDRAM_OPMODE_OFS	0x474
+#define GT_SDRAM_BM_OFS		0x478
+#define GT_SDRAM_ADDRDECODE_OFS	0x47c
+
+#define GT_PCI0_CMD_OFS		0xc00	/* GT64120A only */
+#define GT_PCI0_TOR_OFS		0xc04
+#define GT_PCI0_BS_SCS10_OFS    0xc08
+#define GT_PCI0_BS_SCS32_OFS    0xc0c
+#define GT_INTRCAUSE_OFS	0xc18
+#define GT_INTRMASK_OFS		0xc1c	/* GT64120A only */
+#define GT_PCI0_IACK_OFS	0xc34
+#define GT_PCI0_BARE_OFS	0xc3c
+#define GT_HINTRCAUSE_OFS	0xc98	/* GT64120A only */
+#define GT_HINTRMASK_OFS	0xc9c	/* GT64120A only */
+#define GT_PCI1_CFGADDR_OFS	0xcf0	/* GT64120A only */
+#define GT_PCI1_CFGDATA_OFS	0xcf4	/* GT64120A only */
+#define GT_PCI0_CFGADDR_OFS	0xcf8
+#define GT_PCI0_CFGDATA_OFS	0xcfc
+
+
+/*
+ * Timer/Counter.  GT64120A only.
+ */
+#define GT_TC0_OFS		0x850
+#define GT_TC1_OFS		0x854
+#define GT_TC2_OFS		0x858
+#define GT_TC3_OFS		0x85C
+#define GT_TC_CONTROL_OFS	0x864
+
+/*
+ * I2O Support Registers
+ */
+#define INBOUND_MESSAGE_REGISTER0_PCI_SIDE		0x010
+#define INBOUND_MESSAGE_REGISTER1_PCI_SIDE		0x014
+#define OUTBOUND_MESSAGE_REGISTER0_PCI_SIDE		0x018
+#define OUTBOUND_MESSAGE_REGISTER1_PCI_SIDE		0x01c
+#define INBOUND_DOORBELL_REGISTER_PCI_SIDE		0x020
+#define INBOUND_INTERRUPT_CAUSE_REGISTER_PCI_SIDE	0x024
+#define INBOUND_INTERRUPT_MASK_REGISTER_PCI_SIDE	0x028
+#define OUTBOUND_DOORBELL_REGISTER_PCI_SIDE		0x02c
+#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_PCI_SIDE	0x030
+#define OUTBOUND_INTERRUPT_MASK_REGISTER_PCI_SIDE	0x034
+#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI_SIDE	0x040
+#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI_SIDE	0x044
+#define QUEUE_CONTROL_REGISTER_PCI_SIDE			0x050
+#define QUEUE_BASE_ADDRESS_REGISTER_PCI_SIDE		0x054
+#define INBOUND_FREE_HEAD_POINTER_REGISTER_PCI_SIDE	0x060
+#define INBOUND_FREE_TAIL_POINTER_REGISTER_PCI_SIDE	0x064
+#define INBOUND_POST_HEAD_POINTER_REGISTER_PCI_SIDE	0x068
+#define INBOUND_POST_TAIL_POINTER_REGISTER_PCI_SIDE	0x06c
+#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_PCI_SIDE	0x070
+#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_PCI_SIDE	0x074
+#define OUTBOUND_POST_HEAD_POINTER_REGISTER_PCI_SIDE	0x078
+#define OUTBOUND_POST_TAIL_POINTER_REGISTER_PCI_SIDE	0x07c
+
+#define INBOUND_MESSAGE_REGISTER0_CPU_SIDE		0x1c10
+#define INBOUND_MESSAGE_REGISTER1_CPU_SIDE		0x1c14
+#define OUTBOUND_MESSAGE_REGISTER0_CPU_SIDE		0x1c18
+#define OUTBOUND_MESSAGE_REGISTER1_CPU_SIDE		0x1c1c
+#define INBOUND_DOORBELL_REGISTER_CPU_SIDE		0x1c20
+#define INBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE	0x1c24
+#define INBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE	0x1c28
+#define OUTBOUND_DOORBELL_REGISTER_CPU_SIDE		0x1c2c
+#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU_SIDE	0x1c30
+#define OUTBOUND_INTERRUPT_MASK_REGISTER_CPU_SIDE	0x1c34
+#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU_SIDE	0x1c40
+#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU_SIDE	0x1c44
+#define QUEUE_CONTROL_REGISTER_CPU_SIDE			0x1c50
+#define QUEUE_BASE_ADDRESS_REGISTER_CPU_SIDE		0x1c54
+#define INBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE	0x1c60
+#define INBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE	0x1c64
+#define INBOUND_POST_HEAD_POINTER_REGISTER_CPU_SIDE	0x1c68
+#define INBOUND_POST_TAIL_POINTER_REGISTER_CPU_SIDE	0x1c6c
+#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_CPU_SIDE	0x1c70
+#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU_SIDE	0x1c74
+#define OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU_SIDE	0x1c78
+#define OUTBOUND_POST_TAIL_POINTER_REGISTER_CPU_SIDE	0x1c7c
+
+/*
+ *  Register encodings
+ */
+#define GT_CPU_ENDIAN_SHF       12
+#define GT_CPU_ENDIAN_MSK       (MSK(1) << GT_CPU_ENDIAN_SHF)
+#define GT_CPU_ENDIAN_BIT       GT_CPU_ENDIAN_MSK
+#define GT_CPU_WR_SHF		16
+#define GT_CPU_WR_MSK		(MSK(1) << GT_CPU_WR_SHF)
+#define GT_CPU_WR_BIT		GT_CPU_WR_MSK
+#define GT_CPU_WR_DXDXDXDX	0
+#define GT_CPU_WR_DDDD		1
+
+
+#define GT_CFGADDR_CFGEN_SHF	31
+#define GT_CFGADDR_CFGEN_MSK	(MSK(1) << GT_CFGADDR_CFGEN_SHF)
+#define GT_CFGADDR_CFGEN_BIT	GT_CFGADDR_CFGEN_MSK
+
+#define GT_CFGADDR_BUSNUM_SHF	16
+#define GT_CFGADDR_BUSNUM_MSK	(MSK(8) << GT_CFGADDR_BUSNUM_SHF)
+
+#define GT_CFGADDR_DEVNUM_SHF	11
+#define GT_CFGADDR_DEVNUM_MSK	(MSK(5) << GT_CFGADDR_DEVNUM_SHF)
+
+#define GT_CFGADDR_FUNCNUM_SHF	8
+#define GT_CFGADDR_FUNCNUM_MSK	(MSK(3) << GT_CFGADDR_FUNCNUM_SHF)
+
+#define GT_CFGADDR_REGNUM_SHF	2
+#define GT_CFGADDR_REGNUM_MSK	(MSK(6) << GT_CFGADDR_REGNUM_SHF)
+
+
+#define GT_SDRAM_BM_ORDER_SHF	2
+#define GT_SDRAM_BM_ORDER_MSK	(MSK(1) << GT_SDRAM_BM_ORDER_SHF)
+#define GT_SDRAM_BM_ORDER_BIT	GT_SDRAM_BM_ORDER_MSK
+#define GT_SDRAM_BM_ORDER_SUB	1
+#define GT_SDRAM_BM_ORDER_LIN	0
+
+#define GT_SDRAM_BM_RSVD_ALL1	0xffb
+
+
+#define GT_SDRAM_ADDRDECODE_ADDR_SHF	0
+#define GT_SDRAM_ADDRDECODE_ADDR_MSK	(MSK(3) << GT_SDRAM_ADDRDECODE_ADDR_SHF)
+#define GT_SDRAM_ADDRDECODE_ADDR_0	0
+#define GT_SDRAM_ADDRDECODE_ADDR_1	1
+#define GT_SDRAM_ADDRDECODE_ADDR_2	2
+#define GT_SDRAM_ADDRDECODE_ADDR_3	3
+#define GT_SDRAM_ADDRDECODE_ADDR_4	4
+#define GT_SDRAM_ADDRDECODE_ADDR_5	5
+#define GT_SDRAM_ADDRDECODE_ADDR_6	6
+#define GT_SDRAM_ADDRDECODE_ADDR_7	7
+
+
+#define GT_SDRAM_B0_CASLAT_SHF		0
+#define GT_SDRAM_B0_CASLAT_MSK		(MSK(2) << GT_SDRAM_B0__SHF)
+#define GT_SDRAM_B0_CASLAT_2		1
+#define GT_SDRAM_B0_CASLAT_3		2
+
+#define GT_SDRAM_B0_FTDIS_SHF		2
+#define GT_SDRAM_B0_FTDIS_MSK		(MSK(1) << GT_SDRAM_B0_FTDIS_SHF)
+#define GT_SDRAM_B0_FTDIS_BIT		GT_SDRAM_B0_FTDIS_MSK
+
+#define GT_SDRAM_B0_SRASPRCHG_SHF	3
+#define GT_SDRAM_B0_SRASPRCHG_MSK	(MSK(1) << GT_SDRAM_B0_SRASPRCHG_SHF)
+#define GT_SDRAM_B0_SRASPRCHG_BIT	GT_SDRAM_B0_SRASPRCHG_MSK
+#define GT_SDRAM_B0_SRASPRCHG_2		0
+#define GT_SDRAM_B0_SRASPRCHG_3		1
+
+#define GT_SDRAM_B0_B0COMPAB_SHF	4
+#define GT_SDRAM_B0_B0COMPAB_MSK	(MSK(1) << GT_SDRAM_B0_B0COMPAB_SHF)
+#define GT_SDRAM_B0_B0COMPAB_BIT	GT_SDRAM_B0_B0COMPAB_MSK
+
+#define GT_SDRAM_B0_64BITINT_SHF	5
+#define GT_SDRAM_B0_64BITINT_MSK	(MSK(1) << GT_SDRAM_B0_64BITINT_SHF)
+#define GT_SDRAM_B0_64BITINT_BIT	GT_SDRAM_B0_64BITINT_MSK
+#define GT_SDRAM_B0_64BITINT_2		0
+#define GT_SDRAM_B0_64BITINT_4		1
+
+#define GT_SDRAM_B0_BW_SHF		6
+#define GT_SDRAM_B0_BW_MSK		(MSK(1) << GT_SDRAM_B0_BW_SHF)
+#define GT_SDRAM_B0_BW_BIT		GT_SDRAM_B0_BW_MSK
+#define GT_SDRAM_B0_BW_32		0
+#define GT_SDRAM_B0_BW_64		1
+
+#define GT_SDRAM_B0_BLODD_SHF		7
+#define GT_SDRAM_B0_BLODD_MSK		(MSK(1) << GT_SDRAM_B0_BLODD_SHF)
+#define GT_SDRAM_B0_BLODD_BIT		GT_SDRAM_B0_BLODD_MSK
+
+#define GT_SDRAM_B0_PAR_SHF		8
+#define GT_SDRAM_B0_PAR_MSK		(MSK(1) << GT_SDRAM_B0_PAR_SHF)
+#define GT_SDRAM_B0_PAR_BIT		GT_SDRAM_B0_PAR_MSK
+
+#define GT_SDRAM_B0_BYPASS_SHF		9
+#define GT_SDRAM_B0_BYPASS_MSK		(MSK(1) << GT_SDRAM_B0_BYPASS_SHF)
+#define GT_SDRAM_B0_BYPASS_BIT		GT_SDRAM_B0_BYPASS_MSK
+
+#define GT_SDRAM_B0_SRAS2SCAS_SHF	10
+#define GT_SDRAM_B0_SRAS2SCAS_MSK	(MSK(1) << GT_SDRAM_B0_SRAS2SCAS_SHF)
+#define GT_SDRAM_B0_SRAS2SCAS_BIT	GT_SDRAM_B0_SRAS2SCAS_MSK
+#define GT_SDRAM_B0_SRAS2SCAS_2		0
+#define GT_SDRAM_B0_SRAS2SCAS_3		1
+
+#define GT_SDRAM_B0_SIZE_SHF		11
+#define GT_SDRAM_B0_SIZE_MSK		(MSK(1) << GT_SDRAM_B0_SIZE_SHF)
+#define GT_SDRAM_B0_SIZE_BIT		GT_SDRAM_B0_SIZE_MSK
+#define GT_SDRAM_B0_SIZE_16M		0
+#define GT_SDRAM_B0_SIZE_64M		1
+
+#define GT_SDRAM_B0_EXTPAR_SHF		12
+#define GT_SDRAM_B0_EXTPAR_MSK		(MSK(1) << GT_SDRAM_B0_EXTPAR_SHF)
+#define GT_SDRAM_B0_EXTPAR_BIT		GT_SDRAM_B0_EXTPAR_MSK
+
+#define GT_SDRAM_B0_BLEN_SHF		13
+#define GT_SDRAM_B0_BLEN_MSK		(MSK(1) << GT_SDRAM_B0_BLEN_SHF)
+#define GT_SDRAM_B0_BLEN_BIT		GT_SDRAM_B0_BLEN_MSK
+#define GT_SDRAM_B0_BLEN_8		0
+#define GT_SDRAM_B0_BLEN_4		1
+
+
+#define GT_SDRAM_CFG_REFINT_SHF		0
+#define GT_SDRAM_CFG_REFINT_MSK		(MSK(14) << GT_SDRAM_CFG_REFINT_SHF)
+
+#define GT_SDRAM_CFG_NINTERLEAVE_SHF	14
+#define GT_SDRAM_CFG_NINTERLEAVE_MSK    (MSK(1) << GT_SDRAM_CFG_NINTERLEAVE_SHF)
+#define GT_SDRAM_CFG_NINTERLEAVE_BIT	GT_SDRAM_CFG_NINTERLEAVE_MSK
+
+#define GT_SDRAM_CFG_RMW_SHF		15
+#define GT_SDRAM_CFG_RMW_MSK		(MSK(1) << GT_SDRAM_CFG_RMW_SHF)
+#define GT_SDRAM_CFG_RMW_BIT		GT_SDRAM_CFG_RMW_MSK
+
+#define GT_SDRAM_CFG_NONSTAGREF_SHF	16
+#define GT_SDRAM_CFG_NONSTAGREF_MSK	(MSK(1) << GT_SDRAM_CFG_NONSTAGREF_SHF)
+#define GT_SDRAM_CFG_NONSTAGREF_BIT	GT_SDRAM_CFG_NONSTAGREF_MSK
+
+#define GT_SDRAM_CFG_DUPCNTL_SHF	19
+#define GT_SDRAM_CFG_DUPCNTL_MSK	(MSK(1) << GT_SDRAM_CFG_DUPCNTL_SHF)
+#define GT_SDRAM_CFG_DUPCNTL_BIT	GT_SDRAM_CFG_DUPCNTL_MSK
+
+#define GT_SDRAM_CFG_DUPBA_SHF		20
+#define GT_SDRAM_CFG_DUPBA_MSK		(MSK(1) << GT_SDRAM_CFG_DUPBA_SHF)
+#define GT_SDRAM_CFG_DUPBA_BIT		GT_SDRAM_CFG_DUPBA_MSK
+
+#define GT_SDRAM_CFG_DUPEOT0_SHF	21
+#define GT_SDRAM_CFG_DUPEOT0_MSK	(MSK(1) << GT_SDRAM_CFG_DUPEOT0_SHF)
+#define GT_SDRAM_CFG_DUPEOT0_BIT	GT_SDRAM_CFG_DUPEOT0_MSK
+
+#define GT_SDRAM_CFG_DUPEOT1_SHF	22
+#define GT_SDRAM_CFG_DUPEOT1_MSK	(MSK(1) << GT_SDRAM_CFG_DUPEOT1_SHF)
+#define GT_SDRAM_CFG_DUPEOT1_BIT	GT_SDRAM_CFG_DUPEOT1_MSK
+
+#define GT_SDRAM_OPMODE_OP_SHF		0
+#define GT_SDRAM_OPMODE_OP_MSK		(MSK(3) << GT_SDRAM_OPMODE_OP_SHF)
+#define GT_SDRAM_OPMODE_OP_NORMAL	0
+#define GT_SDRAM_OPMODE_OP_NOP		1
+#define GT_SDRAM_OPMODE_OP_PRCHG	2
+#define GT_SDRAM_OPMODE_OP_MODE		3
+#define GT_SDRAM_OPMODE_OP_CBR		4
+
+
+#define GT_PCI0_BARE_SWSCS3BOOTDIS_SHF	0
+#define GT_PCI0_BARE_SWSCS3BOOTDIS_MSK	(MSK(1) << GT_PCI0_BARE_SWSCS3BOOTDIS_SHF)
+#define GT_PCI0_BARE_SWSCS3BOOTDIS_BIT	GT_PCI0_BARE_SWSCS3BOOTDIS_MSK
+
+#define GT_PCI0_BARE_SWSCS32DIS_SHF	1
+#define GT_PCI0_BARE_SWSCS32DIS_MSK	(MSK(1) << GT_PCI0_BARE_SWSCS32DIS_SHF)
+#define GT_PCI0_BARE_SWSCS32DIS_BIT	GT_PCI0_BARE_SWSCS32DIS_MSK
+	
+#define GT_PCI0_BARE_SWSCS10DIS_SHF	2
+#define GT_PCI0_BARE_SWSCS10DIS_MSK	(MSK(1) << GT_PCI0_BARE_SWSCS10DIS_SHF)
+#define GT_PCI0_BARE_SWSCS10DIS_BIT	GT_PCI0_BARE_SWSCS10DIS_MSK
+
+#define GT_PCI0_BARE_INTIODIS_SHF	3
+#define GT_PCI0_BARE_INTIODIS_MSK	(MSK(1) << GT_PCI0_BARE_INTIODIS_SHF)
+#define GT_PCI0_BARE_INTIODIS_BIT	GT_PCI0_BARE_INTIODIS_MSK
+
+#define GT_PCI0_BARE_INTMEMDIS_SHF	4
+#define GT_PCI0_BARE_INTMEMDIS_MSK	(MSK(1) << GT_PCI0_BARE_INTMEMDIS_SHF)
+#define GT_PCI0_BARE_INTMEMDIS_BIT	GT_PCI0_BARE_INTMEMDIS_MSK
+
+#define GT_PCI0_BARE_CS3BOOTDIS_SHF	5
+#define GT_PCI0_BARE_CS3BOOTDIS_MSK	(MSK(1) << GT_PCI0_BARE_CS3BOOTDIS_SHF)
+#define GT_PCI0_BARE_CS3BOOTDIS_BIT	GT_PCI0_BARE_CS3BOOTDIS_MSK
+
+#define GT_PCI0_BARE_CS20DIS_SHF	6
+#define GT_PCI0_BARE_CS20DIS_MSK	(MSK(1) << GT_PCI0_BARE_CS20DIS_SHF)
+#define GT_PCI0_BARE_CS20DIS_BIT	GT_PCI0_BARE_CS20DIS_MSK
+
+#define GT_PCI0_BARE_SCS32DIS_SHF	7
+#define GT_PCI0_BARE_SCS32DIS_MSK	(MSK(1) << GT_PCI0_BARE_SCS32DIS_SHF)
+#define GT_PCI0_BARE_SCS32DIS_BIT	GT_PCI0_BARE_SCS32DIS_MSK
+
+#define GT_PCI0_BARE_SCS10DIS_SHF	8
+#define GT_PCI0_BARE_SCS10DIS_MSK	(MSK(1) << GT_PCI0_BARE_SCS10DIS_SHF)
+#define GT_PCI0_BARE_SCS10DIS_BIT	GT_PCI0_BARE_SCS10DIS_MSK
+
+
+#define GT_INTRCAUSE_MASABORT0_SHF	18
+#define GT_INTRCAUSE_MASABORT0_MSK	(MSK(1) << GT_INTRCAUSE_MASABORT0_SHF)
+#define GT_INTRCAUSE_MASABORT0_BIT	GT_INTRCAUSE_MASABORT0_MSK
+
+#define GT_INTRCAUSE_TARABORT0_SHF	19
+#define GT_INTRCAUSE_TARABORT0_MSK	(MSK(1) << GT_INTRCAUSE_TARABORT0_SHF)
+#define GT_INTRCAUSE_TARABORT0_BIT	GT_INTRCAUSE_TARABORT0_MSK
+
+
+#define GT_PCI0_CFGADDR_REGNUM_SHF	2
+#define GT_PCI0_CFGADDR_REGNUM_MSK	(MSK(6) << GT_PCI0_CFGADDR_REGNUM_SHF)
+#define GT_PCI0_CFGADDR_FUNCTNUM_SHF	8
+#define GT_PCI0_CFGADDR_FUNCTNUM_MSK    (MSK(3) << GT_PCI0_CFGADDR_FUNCTNUM_SHF)
+#define GT_PCI0_CFGADDR_DEVNUM_SHF	11
+#define GT_PCI0_CFGADDR_DEVNUM_MSK	(MSK(5) << GT_PCI0_CFGADDR_DEVNUM_SHF)
+#define GT_PCI0_CFGADDR_BUSNUM_SHF	16
+#define GT_PCI0_CFGADDR_BUSNUM_MSK	(MSK(8) << GT_PCI0_CFGADDR_BUSNUM_SHF)
+#define GT_PCI0_CFGADDR_CONFIGEN_SHF	31
+#define GT_PCI0_CFGADDR_CONFIGEN_MSK	(MSK(1) << GT_PCI0_CFGADDR_CONFIGEN_SHF)
+#define GT_PCI0_CFGADDR_CONFIGEN_BIT	GT_PCI0_CFGADDR_CONFIGEN_MSK
+
+#define GT_PCI0_CMD_MBYTESWAP_SHF       0
+#define GT_PCI0_CMD_MBYTESWAP_MSK       (MSK(1) << GT_PCI0_CMD_MBYTESWAP_SHF)
+#define GT_PCI0_CMD_MBYTESWAP_BIT       GT_PCI0_CMD_MBYTESWAP_MSK
+#define GT_PCI0_CMD_MWORDSWAP_SHF       10
+#define GT_PCI0_CMD_MWORDSWAP_MSK       (MSK(1) << GT_PCI0_CMD_MWORDSWAP_SHF)
+#define GT_PCI0_CMD_MWORDSWAP_BIT       GT_PCI0_CMD_MWORDSWAP_MSK
+#define GT_PCI0_CMD_SBYTESWAP_SHF       16
+#define GT_PCI0_CMD_SBYTESWAP_MSK       (MSK(1) << GT_PCI0_CMD_SBYTESWAP_SHF)
+#define GT_PCI0_CMD_SBYTESWAP_BIT       GT_PCI0_CMD_SBYTESWAP_MSK
+#define GT_PCI0_CMD_SWORDSWAP_SHF       11
+#define GT_PCI0_CMD_SWORDSWAP_MSK       (MSK(1) << GT_PCI0_CMD_SWORDSWAP_SHF)
+#define GT_PCI0_CMD_SWORDSWAP_BIT       GT_PCI0_CMD_SWORDSWAP_MSK
+
+/*
+ *  Misc
+ */
+#define GT_DEF_BASE		0x14000000
+#define GT_DEF_PCI0_MEM0_BASE	0x12000000
+#define GT_MAX_BANKSIZE		(256 * 1024 * 1024)   /* Max 256MB bank */
+#define GT_LATTIM_MIN    	6		      /* Minimum lat	*/
+
+#endif /* _ASM_GT64120_H */
diff -urN linux-2.4.32/include/asm-mips/mipsregs.h linux-2.4.32-adm5120/include/asm-mips/mipsregs.h
--- linux-2.4.32/include/asm-mips/mipsregs.h	2005-12-20 12:42:58.000000000 +0200
+++ linux-2.4.32-adm5120/include/asm-mips/mipsregs.h	2005-12-20 12:22:42.000000000 +0200
@@ -342,6 +342,7 @@
 #define  STATUSF_IP14		(_ULCAST_(1) <<  6)
 #define  STATUSB_IP15		7
 #define  STATUSF_IP15		(_ULCAST_(1) <<  7)
+#define	 STATUS_IE		1
 #define ST0_CH			0x00040000
 #define ST0_SR			0x00100000
 #define ST0_TS			0x00200000
@@ -587,6 +588,12 @@
 			: "=r" (__res));				\
 	__res;								\
 })
+/*used by adm5120 rtc.c mayby write32bitc0 is the replace,try later */
+#define write_32bit_cp0_register(register,value)			\
+	__asm__ __volatile__(						\
+	"mtc0\t%0,"STR(register)"\n\t"					\
+	"nop"								\
+	: : "r" (value));
 
 #define __write_32bit_c0_register(register, sel, value)			\
 do {									\
diff -urN linux-2.4.32/include/asm-mips/offset.h linux-2.4.32-adm5120/include/asm-mips/offset.h
--- linux-2.4.32/include/asm-mips/offset.h	2005-12-20 12:43:41.000000000 +0200
+++ linux-2.4.32-adm5120/include/asm-mips/offset.h	2005-12-20 12:09:27.000000000 +0200
@@ -0,0 +1,160 @@
+/* DO NOT TOUCH, AUTOGENERATED BY OFFSET.C */
+
+#ifndef _MIPS_OFFSET_H
+#define _MIPS_OFFSET_H
+
+#endif /* !(_MIPS_OFFSET_H) */
+/* MIPS pt_regs offsets. */
+#define PT_R0     24
+#define PT_R1     28
+#define PT_R2     32
+#define PT_R3     36
+#define PT_R4     40
+#define PT_R5     44
+#define PT_R6     48
+#define PT_R7     52
+#define PT_R8     56
+#define PT_R9     60
+#define PT_R10    64
+#define PT_R11    68
+#define PT_R12    72
+#define PT_R13    76
+#define PT_R14    80
+#define PT_R15    84
+#define PT_R16    88
+#define PT_R17    92
+#define PT_R18    96
+#define PT_R19    100
+#define PT_R20    104
+#define PT_R21    108
+#define PT_R22    112
+#define PT_R23    116
+#define PT_R24    120
+#define PT_R25    124
+#define PT_R26    128
+#define PT_R27    132
+#define PT_R28    136
+#define PT_R29    140
+#define PT_R30    144
+#define PT_R31    148
+#define PT_LO     156
+#define PT_HI     160
+#define PT_EPC    172
+#define PT_BVADDR 164
+#define PT_STATUS 152
+#define PT_CAUSE  168
+#define PT_SIZE   176
+
+/* MIPS task_struct offsets. */
+#define TASK_STATE         0
+#define TASK_FLAGS         4
+  #define _PT_TRACESYS        0x2
+#define TASK_SIGPENDING    8
+#define TASK_NEED_RESCHED  20
+#define TASK_PTRACE        24
+#define TASK_COUNTER       32
+#define TASK_NICE          36
+#define TASK_MM            44
+#define TASK_PROCESSOR     48
+#define TASK_PID           124
+#define TASK_STRUCT_SIZE   1048
+
+/* MIPS task_struct allocation info. */
+#define _THREAD_ORDER    0x1
+#define _THREAD_SIZE     0x2000
+#define _THREAD_MASK     0x1fff
+
+/* MIPS specific thread_struct offsets. */
+#define THREAD_REG16   616
+#define THREAD_REG17   620
+#define THREAD_REG18   624
+#define THREAD_REG19   628
+#define THREAD_REG20   632
+#define THREAD_REG21   636
+#define THREAD_REG22   640
+#define THREAD_REG23   644
+#define THREAD_REG29   648
+#define THREAD_REG30   652
+#define THREAD_REG31   656
+#define THREAD_STATUS  660
+#define THREAD_FPU     664
+#define THREAD_BVADDR  928
+#define THREAD_BUADDR  932
+#define THREAD_ECODE   936
+#define THREAD_TRAPNO  940
+#define THREAD_MFLAGS  944
+#define THREAD_CURDS   948
+#define THREAD_TRAMP   952
+#define THREAD_OLDCTX  956
+
+/* Linux mm_struct offsets. */
+#define MM_USERS      16
+#define MM_PGD        12
+#define MM_CONTEXT    120
+
+#define _PAGE_SIZE     0x1000
+#define _PAGE_SHIFT    0xc
+
+#define _PGD_T_SIZE    0x4
+#define _PMD_T_SIZE    0x4
+#define _PTE_T_SIZE    0x4
+
+#define _PGD_T_LOG2    0x2
+#define _PMD_T_LOG2    0x2
+#define _PTE_T_LOG2    0x2
+
+#define _PMD_SHIFT     0x16
+#define _PGDIR_SHIFT   0x16
+
+#define _PGD_ORDER     0x0
+#define _PTE_ORDER     0x0
+
+#define _PTRS_PER_PGD  0x400
+#define _PTRS_PER_PMD  0x1
+#define _PTRS_PER_PTE  0x400
+
+/* Linux sigcontext offsets. */
+#define SC_REGS       16
+#define SC_FPREGS     272
+#define SC_MDHI       552
+#define SC_MDLO       560
+#define SC_PC         8
+#define SC_STATUS     4
+#define SC_FPC_CSR    532
+#define SC_FPC_EIR    536
+#define SC_CAUSE      568
+#define SC_BADVADDR   572
+
+/* Linux signal numbers. */
+#define _SIGHUP     0x1
+#define _SIGINT     0x2
+#define _SIGQUIT    0x3
+#define _SIGILL     0x4
+#define _SIGTRAP    0x5
+#define _SIGIOT     0x6
+#define _SIGABRT    0x6
+#define _SIGEMT     0x7
+#define _SIGFPE     0x8
+#define _SIGKILL    0x9
+#define _SIGBUS     0xa
+#define _SIGSEGV    0xb
+#define _SIGSYS     0xc
+#define _SIGPIPE    0xd
+#define _SIGALRM    0xe
+#define _SIGTERM    0xf
+#define _SIGUSR1    0x10
+#define _SIGUSR2    0x11
+#define _SIGCHLD    0x12
+#define _SIGPWR     0x13
+#define _SIGWINCH   0x14
+#define _SIGURG     0x15
+#define _SIGIO      0x16
+#define _SIGSTOP    0x17
+#define _SIGTSTP    0x18
+#define _SIGCONT    0x19
+#define _SIGTTIN    0x1a
+#define _SIGTTOU    0x1b
+#define _SIGVTALRM  0x1c
+#define _SIGPROF    0x1d
+#define _SIGXCPU    0x1e
+#define _SIGXFSZ    0x1f
diff -urN linux-2.4.32/init/do_mounts.c linux-2.4.32-adm5120/init/do_mounts.c
--- linux-2.4.32/init/do_mounts.c	2005-12-20 12:43:00.000000000 +0200
+++ linux-2.4.32-adm5120/init/do_mounts.c	2005-12-20 12:22:42.000000000 +0200
@@ -465,7 +465,12 @@
 }
 __setup("ramdisk_start=", ramdisk_start_setup);
 
+#ifdef CONFIG_BLK_DEV_RAM_GZ
 static int __init crd_load(int in_fd, int out_fd);
+#endif
+#ifdef CONFIG_BLK_DEV_RAM_BZ
+static int __init crbz_load(int in_fd, int out_fd);
+#endif
 
 /*
  * This routine tries to find a RAM disk image to load, and returns the
@@ -509,17 +514,31 @@
 	 */
 	lseek(fd, start_block * BLOCK_SIZE, 0);
 	read(fd, buf, size);
+#ifdef CONFIG_BLK_DEV_RAM_BZ
+	/*
+	 * If it matches the bzip2 magic numbers, nblocks = -1??
+	 */
+	if (buf[0] == 'B' && buf[1] == 'Z' && buf[2] == 'h') {
+		printk(KERN_NOTICE
+		       "RAMDISK: bzip2 compressed image found at block %d\n",
+		       start_block); 
+		nblocks = -100;
+		goto done;
+	}
+#endif
 
+#ifdef CONFIG_BLK_DEV_RAM_GZ
 	/*
 	 * If it matches the gzip magic numbers, return -1
 	 */
 	if (buf[0] == 037 && ((buf[1] == 0213) || (buf[1] == 0236))) {
 		printk(KERN_NOTICE
-		       "RAMDISK: Compressed image found at block %d\n",
+		       "RAMDISK: gzip compressed image found at block %d\n",
 		       start_block);
 		nblocks = 0;
 		goto done;
 	}
+#endif
 
 	/* romfs is at block zero too */
 	if (romfsb->word0 == ROMSB_WORD0 &&
@@ -607,20 +626,30 @@
 		goto noclose_input;
 
 	nblocks = identify_ramdisk_image(in_fd, rd_image_start);
-	if (nblocks < 0)
+	if (nblocks < 0 && nblocks != -100 )
 		goto done;
 
-	if (nblocks == 0) {
 #ifdef BUILD_CRAMDISK
-		if (crd_load(in_fd, out_fd) == 0)
+	switch (nblocks) {
+		case -100:
+#ifdef CONFIG_BLK_DEV_RAM_BZ
+		    if (crbz_load(in_fd, out_fd) == 0)
+			goto successful_load;
+#endif
+		    break;
+		case 0:
+#ifdef CONFIG_BLK_DEV_RAM_GZ
+		    if (crd_load(in_fd, out_fd) == 0)
 			goto successful_load;
+#endif
+		    break;
+	}
 #else
 		printk(KERN_NOTICE
 		       "RAMDISK: Kernel does not support compressed "
 		       "RAM disk images\n");
 #endif
 		goto done;
-	}
 
 	/*
 	 * NOTE NOTE: nblocks suppose that the blocksize is BLOCK_SIZE, so
@@ -943,6 +972,8 @@
  * gzip declarations
  */
 
+#include <linux/vmalloc.h>
+
 #define OF(args)  args
 
 #ifndef memzero
@@ -967,47 +998,31 @@
 static long bytes_out;
 static int crd_infd, crd_outfd;
 
-#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
-		
-/* Diagnostic functions (stubbed out) */
-#define Assert(cond,msg)
-#define Trace(x)
-#define Tracev(x)
-#define Tracevv(x)
-#define Tracec(c,x)
-#define Tracecv(c,x)
-
 #define STATIC static
 
-static int  fill_inbuf(void);
-static void flush_window(void);
 static void *malloc(int size);
 static void free(void *where);
 static void error(char *m);
-static void gzip_mark(void **);
-static void gzip_release(void **);
+static int  fill_inbuf(void);
+static void flush_window(void);
 
-#include "../lib/inflate.c"
 
 static void __init *malloc(int size)
 {
-	return kmalloc(size, GFP_KERNEL);
+//	return kmalloc(size, GFP_KERNEL);
+	return vmalloc((unsigned long)size);
 }
 
 static void __init free(void *where)
 {
-	kfree(where);
-}
-
-static void __init gzip_mark(void **ptr)
-{
+	vfree(where);
 }
-
-static void __init gzip_release(void **ptr)
+static void __init error(char *x)
 {
+	printk(KERN_ERR "%s", x);
+	exit_code = 1;
 }
 
-
 /* ===========================================================================
  * Fill the input buffer. This is called only when the buffer is empty
  * and at least one byte is really needed.
@@ -1030,27 +1045,52 @@
  */
 static void __init flush_window(void)
 {
-    ulg c = crc;         /* temporary variable */
-    unsigned n;
-    uch *in, ch;
+//    ulg c = crc;         /* temporary variable */
+//    unsigned n;
+//    uch *in, ch;
     
     write(crd_outfd, window, outcnt);
-    in = window;
-    for (n = 0; n < outcnt; n++) {
-	    ch = *in++;
-	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
-    }
-    crc = c;
+//    in = window;
+//    for (n = 0; n < outcnt; n++) {
+//	    ch = *in++;
+//	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+//    }
+//    crc = c;
     bytes_out += (ulg)outcnt;
     outcnt = 0;
 }
 
-static void __init error(char *x)
+#ifdef CONFIG_BLK_DEV_RAM_GZ
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+		
+/* Diagnostic functions (stubbed out) */
+#define Assert(cond,msg)
+#define Trace(x)
+#define Tracev(x)
+#define Tracevv(x)
+#define Tracec(c,x)
+#define Tracecv(c,x)
+
+
+static void gzip_mark(void **);
+static void gzip_release(void **);
+
+#include "../lib/inflate.c"
+
+
+//#ifdef CONFIG_BLK_DEV_RAM_GZ
+static void __init gzip_mark(void **ptr)
+{
+}
+
+static void __init gzip_release(void **ptr)
 {
-	printk(KERN_ERR "%s", x);
-	exit_code = 1;
 }
+//#endif
 
+
+//#ifdef CONFIG_BLK_DEV_RAM_GZ
 static int __init crd_load(int in_fd, int out_fd)
 {
 	int result;
@@ -1081,6 +1121,105 @@
 	kfree(window);
 	return result;
 }
+#endif /*CONFIG_BLK_DEV_RAM_GZ*/
+#ifdef CONFIG_BLK_DEV_RAM_BZ
+
+static void puts(char *s);
+
+#include "../lib/bzip2_inflate.c"
+
+static void puts(char *s)
+{
+    printk(s);
+}
+
+static int __init crbz_load(int in_fd, int out_fd)
+{
+	bz_stream bzstream;
+	int result;
+	int rc;
+	int save = 0;
+	
+	insize = 0;		/* valid bytes in inbuff*/
+	inptr = 0;
+	outcnt = 0;
+	exit_code = 0;
+	bytes_out = 0;
+	
+	crd_infd = in_fd;
+	crd_outfd = out_fd;
+	inbuf = kmalloc(INBUFSIZ, GFP_KERNEL);
+	if (inbuf == 0) {
+		printk(KERN_ERR "RAMDISK: Couldn't allocate bzip2 buffer\n");
+		return -1;
+	}
+	window = kmalloc(WSIZE, GFP_KERNEL);
+	if (window == 0) {
+		printk(KERN_ERR "RAMDISK: Couldn't allocate bzip2 window\n");
+		kfree(inbuf);
+		return -1;
+	}
+	
+	bzstream.bzalloc = 0;
+	bzstream.bzfree = 0;
+	bzstream.opaque = 0;
+	
+	result = BZ2_bzDecompressInit( &bzstream, 0, 1 );
+	if (result != BZ_OK)
+		return -1;
+		
+	rc = fill_inbuf();
+	if ( rc == -1 )
+		return(-1);
+	bzstream.next_in = inbuf;
+	bzstream.avail_in = insize;
+	bzstream.next_out = window;
+	bzstream.avail_out = WSIZE ;
+	for(;;)
+	{
+		save = bzstream.total_out_lo32;
+		result = BZ2_bzDecompress ( &bzstream );
+		outcnt = bzstream.total_out_lo32 - save;
+	/* p(result,bzstream);   */
+		puts(".");
+
+		if (result != BZ_OK)
+			break;
+
+		if (outcnt > 0)
+		{
+//			puts("o");
+			flush_window(); // NEEDS OUTCNT
+			bzstream.next_out = window;
+			bzstream.avail_out = WSIZE;
+		}
+		
+		if (bzstream.avail_in == 0) //GIVES INSIZE
+		{
+//			puts("i");
+			rc = fill_inbuf();
+			if (rc == -1)
+				return -1;
+			bzstream.next_in = inbuf;
+			bzstream.avail_in = insize;
+		}
+	}
+	
+	if ( result == BZ_STREAM_END)
+	{
+		if (outcnt > 0)
+		{
+			flush_window();
+		}
+		result = BZ2_bzDecompressEnd( &bzstream);
+	}
+	kfree(inbuf);
+	kfree(window);
+	puts("\n");
+	return result;
+}
+#endif /*CONFIG_BLK_DEV_RAM_BZ*/
+
 
 #endif  /* BUILD_CRAMDISK && CONFIG_BLK_DEV_RAM */
 #endif  /* CONFIG_BLK_DEV_RAM */
diff -urN linux-2.4.32/lib/bzip2_inflate.c linux-2.4.32-adm5120/lib/bzip2_inflate.c
--- linux-2.4.32/lib/bzip2_inflate.c	1970-01-01 03:00:00.000000000 +0300
+++ linux-2.4.32-adm5120/lib/bzip2_inflate.c	2005-12-20 12:22:42.000000000 +0200
@@ -0,0 +1,1850 @@
+
+char hexdigits[17] = "0123456789abcdef";
+
+int itox( unsigned int n, char s[])
+{
+	int i = 10;
+	s[i--]='\0';
+	do s[i--] = hexdigits[ n % 16 ];
+	while ( ( ( n /= 16 ) > 0 ) && ( i > 1 ) );
+	for ( ; i>1; s[i--] = '0' );
+	s[i--]='x';
+	s[i--]='0';
+	return 0;
+}
+
+int putix( unsigned int n)
+{
+	char swork[17];
+	itox( n, swork );
+	puts( swork );
+	return 0;
+}
+
+int putpx( void * n)
+{
+	char swork[17];
+	itox( (unsigned int)n, swork );
+	puts( swork );
+	return 0;
+}
+
+void bz_internal_error ( int i )
+{
+	puts("\n");
+	putix(i);
+	puts("\n");
+	error("Bzip2 internal error.");
+}
+
+/*-------------------------------------------------------------*/
+/*
+
+	bzip2 stuff for linux kernel and ramdisk decompression.
+
+	This file was derived by Thomas Oehser, Tom@Toms.NET,
+	from bzlib.c from bzip2-1.0.2, to fit more with less.
+
+	The initial implementation is only tested to work with
+	kernel version 2.2.20 and only with bzImage (bz2bzImage).
+
+	Mostly I just chopped out compression stuff (leaving
+	only decompression) and the 'high-level' stuff, (that
+	expects stdio and libc), and chopped out any other bits
+	that required stuff that isn't around during kernel boot.
+
+	I crammed everything it needed together into this one
+	file, also.  And not always in a logical order.
+
+*/
+
+/*-------------------------------------------------------------*/
+
+/*--
+  This file is a part of bzip2 and/or libbzip2, a program and
+  library for lossless, block-sorting data compression.
+
+  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+
+  2. The origin of this software must not be misrepresented; you must 
+     not claim that you wrote the original software.  If you use this 
+     software in a product, an acknowledgment in the product 
+     documentation would be appreciated but is not required.
+
+  3. Altered source versions must be plainly marked as such, and must
+     not be misrepresented as being the original software.
+
+  4. The name of the author may not be used to endorse or promote 
+     products derived from this software without specific prior written 
+     permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  Julian Seward, Cambridge, UK.
+  jseward@acm.org
+  bzip2/libbzip2 version 1.0 of 21 March 2000
+
+  This program is based on (at least) the work of:
+     Mike Burrows
+     David Wheeler
+     Peter Fenwick
+     Alistair Moffat
+     Radford Neal
+     Ian H. Witten
+     Robert Sedgewick
+     Jon L. Bentley
+
+  For more information on these sources, see the manual.
+--*/
+
+/*-- General stuff. --*/
+
+#define BZ_VERSION  "1.0.2, 30-Dec-2001"
+
+typedef char            Char;
+typedef unsigned char   Bool;
+typedef unsigned char   UChar;
+typedef int             Int32;
+typedef unsigned int    UInt32;
+typedef short           Int16;
+typedef unsigned short  UInt16;
+
+#define True  ((Bool)1)
+#define False ((Bool)0)
+
+#ifndef __GNUC__
+#define __inline__  /* */
+#endif 
+
+extern void bz_internal_error ( int errcode );
+
+#define AssertH(cond,errcode) \
+   { if (!(cond)) bz_internal_error ( errcode ); }
+#define AssertD(cond,msg) /* */
+#define VPrintf0(zf) /* */
+#define VPrintf1(zf,za1) /* */
+#define VPrintf2(zf,za1,za2) /* */
+#define VPrintf3(zf,za1,za2,za3) /* */
+#define VPrintf4(zf,za1,za2,za3,za4) /* */
+#define VPrintf5(zf,za1,za2,za3,za4,za5) /* */
+
+#define BZALLOC(nnn) (strm->bzalloc)(strm->opaque,(nnn),1)
+#define BZFREE(ppp)  (strm->bzfree)(strm->opaque,(ppp))
+
+/*-- Header bytes. --*/
+
+#define BZ_HDR_B 0x42   /* 'B' */
+#define BZ_HDR_Z 0x5a   /* 'Z' */
+#define BZ_HDR_h 0x68   /* 'h' */
+#define BZ_HDR_0 0x30   /* '0' */
+  
+/*-- Constants for the back end. --*/
+
+#define BZ_MAX_ALPHA_SIZE 258
+#define BZ_MAX_CODE_LEN    23
+
+#define BZ_RUNA 0
+#define BZ_RUNB 1
+
+#define BZ_N_GROUPS 6
+#define BZ_G_SIZE   50
+#define BZ_N_ITERS  4
+
+#define BZ_MAX_SELECTORS (2 + (900000 / BZ_G_SIZE))
+
+
+
+/*-- Stuff for randomising repetitive blocks. --*/
+
+// extern Int32 BZ2_rNums[512];
+
+#define BZ_RAND_DECLS                          \
+   Int32 rNToGo;                               \
+   Int32 rTPos                                 \
+
+#define BZ_RAND_INIT_MASK                      \
+   s->rNToGo = 0;                              \
+   s->rTPos  = 0                               \
+
+#define BZ_RAND_MASK ((s->rNToGo == 1) ? 1 : 0)
+
+#define BZ_RAND_UPD_MASK                       \
+   if (s->rNToGo == 0) {                       \
+      s->rNToGo = BZ2_rNums[s->rTPos];         \
+      s->rTPos++;                              \
+      if (s->rTPos == 512) s->rTPos = 0;       \
+   }                                           \
+   s->rNToGo--;
+
+/*-- Stuff for doing CRCs. --*/
+
+// extern UInt32 BZ2_crc32Table[256];
+
+#define BZ_INITIALISE_CRC(crcVar)              \
+{                                              \
+   crcVar = 0xffffffffL;                       \
+}
+
+#define BZ_FINALISE_CRC(crcVar)                \
+{                                              \
+   crcVar = ~(crcVar);                         \
+}
+
+#define BZ_UPDATE_CRC(crcVar,cha)              \
+{                                              \
+   crcVar = (crcVar << 8) ^                    \
+            BZ2_crc32Table[(crcVar >> 24) ^    \
+                           ((UChar)cha)];      \
+}
+
+/*-- states for decompression. --*/
+
+#define BZ_X_IDLE        1
+#define BZ_X_OUTPUT      2
+
+#define BZ_X_MAGIC_1     10
+#define BZ_X_MAGIC_2     11
+#define BZ_X_MAGIC_3     12
+#define BZ_X_MAGIC_4     13
+#define BZ_X_BLKHDR_1    14
+#define BZ_X_BLKHDR_2    15
+#define BZ_X_BLKHDR_3    16
+#define BZ_X_BLKHDR_4    17
+#define BZ_X_BLKHDR_5    18
+#define BZ_X_BLKHDR_6    19
+#define BZ_X_BCRC_1      20
+#define BZ_X_BCRC_2      21
+#define BZ_X_BCRC_3      22
+#define BZ_X_BCRC_4      23
+#define BZ_X_RANDBIT     24
+#define BZ_X_ORIGPTR_1   25
+#define BZ_X_ORIGPTR_2   26
+#define BZ_X_ORIGPTR_3   27
+#define BZ_X_MAPPING_1   28
+#define BZ_X_MAPPING_2   29
+#define BZ_X_SELECTOR_1  30
+#define BZ_X_SELECTOR_2  31
+#define BZ_X_SELECTOR_3  32
+#define BZ_X_CODING_1    33
+#define BZ_X_CODING_2    34
+#define BZ_X_CODING_3    35
+#define BZ_X_MTF_1       36
+#define BZ_X_MTF_2       37
+#define BZ_X_MTF_3       38
+#define BZ_X_MTF_4       39
+#define BZ_X_MTF_5       40
+#define BZ_X_MTF_6       41
+#define BZ_X_ENDHDR_2    42
+#define BZ_X_ENDHDR_3    43
+#define BZ_X_ENDHDR_4    44
+#define BZ_X_ENDHDR_5    45
+#define BZ_X_ENDHDR_6    46
+#define BZ_X_CCRC_1      47
+#define BZ_X_CCRC_2      48
+#define BZ_X_CCRC_3      49
+#define BZ_X_CCRC_4      50
+
+/*-- Constants for the fast MTF decoder. --*/
+
+#define MTFA_SIZE 4096
+#define MTFL_SIZE 16
+
+
+#define BZ_RUN               0
+#define BZ_FLUSH             1
+#define BZ_FINISH            2
+
+#define BZ_OK                0
+#define BZ_RUN_OK            1
+#define BZ_FLUSH_OK          2
+#define BZ_FINISH_OK         3
+#define BZ_STREAM_END        4
+#define BZ_SEQUENCE_ERROR    (-1)
+#define BZ_PARAM_ERROR       (-2)
+#define BZ_MEM_ERROR         (-3)
+#define BZ_DATA_ERROR        (-4)
+#define BZ_DATA_ERROR_MAGIC  (-5)
+#define BZ_IO_ERROR          (-6)
+#define BZ_UNEXPECTED_EOF    (-7)
+#define BZ_OUTBUFF_FULL      (-8)
+#define BZ_CONFIG_ERROR      (-9)
+
+typedef 
+   struct {
+      char *next_in;
+      unsigned int avail_in;
+      unsigned int total_in_lo32;
+      unsigned int total_in_hi32;
+
+      char *next_out;
+      unsigned int avail_out;
+      unsigned int total_out_lo32;
+      unsigned int total_out_hi32;
+
+      void *state;
+
+      void *(*bzalloc)(void *,int,int);
+      void (*bzfree)(void *,void *);
+      void *opaque;
+   } 
+   bz_stream;
+
+#ifndef BZ_IMPORT
+#define BZ_EXPORT
+#endif
+
+#   define BZ_API(func) func
+#   define BZ_EXTERN extern
+
+/*-- Structure holding all the decompression-side stuff. --*/
+
+typedef
+   struct {
+      /* pointer back to the struct bz_stream */
+      bz_stream* strm;
+
+      /* state indicator for this stream */
+      Int32    state;
+
+      /* for doing the final run-length decoding */
+      UChar    state_out_ch;
+      Int32    state_out_len;
+      Bool     blockRandomised;
+      BZ_RAND_DECLS;
+
+      /* the buffer for bit stream reading */
+      UInt32   bsBuff;
+      Int32    bsLive;
+
+      /* misc administratium */
+      Int32    blockSize100k;
+      Bool     smallDecompress;
+      Int32    currBlockNo;
+      Int32    verbosity;
+
+      /* for undoing the Burrows-Wheeler transform */
+      Int32    origPtr;
+      UInt32   tPos;
+      Int32    k0;
+      Int32    unzftab[256];
+      Int32    nblock_used;
+      Int32    cftab[257];
+      Int32    cftabCopy[257];
+
+      /* for undoing the Burrows-Wheeler transform (FAST) */
+      UInt32   *tt;
+
+      /* for undoing the Burrows-Wheeler transform (SMALL) */
+      UInt16   *ll16;
+      UChar    *ll4;
+
+      /* stored and calculated CRCs */
+      UInt32   storedBlockCRC;
+      UInt32   storedCombinedCRC;
+      UInt32   calculatedBlockCRC;
+      UInt32   calculatedCombinedCRC;
+
+      /* map of bytes used in block */
+      Int32    nInUse;
+      Bool     inUse[256];
+      Bool     inUse16[16];
+      UChar    seqToUnseq[256];
+
+      /* for decoding the MTF values */
+      UChar    mtfa   [MTFA_SIZE];
+      Int32    mtfbase[256 / MTFL_SIZE];
+      UChar    selector   [BZ_MAX_SELECTORS];
+      UChar    selectorMtf[BZ_MAX_SELECTORS];
+      UChar    len  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+
+      Int32    limit  [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    base   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    perm   [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];
+      Int32    minLens[BZ_N_GROUPS];
+
+      /* save area for scalars in the main decompress code */
+      Int32    save_i;
+      Int32    save_j;
+      Int32    save_t;
+      Int32    save_alphaSize;
+      Int32    save_nGroups;
+      Int32    save_nSelectors;
+      Int32    save_EOB;
+      Int32    save_groupNo;
+      Int32    save_groupPos;
+      Int32    save_nextSym;
+      Int32    save_nblockMAX;
+      Int32    save_nblock;
+      Int32    save_es;
+      Int32    save_N;
+      Int32    save_curr;
+      Int32    save_zt;
+      Int32    save_zn; 
+      Int32    save_zvec;
+      Int32    save_zj;
+      Int32    save_gSel;
+      Int32    save_gMinlen;
+      Int32*   save_gLimit;
+      Int32*   save_gBase;
+      Int32*   save_gPerm;
+
+   }
+   DState;
+
+/*-- Macros for decompression. --*/
+
+#define BZ_GET_FAST(cccc)                     \
+    s->tPos = s->tt[s->tPos];                 \
+    cccc = (UChar)(s->tPos & 0xff);           \
+    s->tPos >>= 8;
+
+#define BZ_GET_FAST_C(cccc)                   \
+    c_tPos = c_tt[c_tPos];                    \
+    cccc = (UChar)(c_tPos & 0xff);            \
+    c_tPos >>= 8;
+
+#define SET_LL4(i,n)                                          \
+   { if (((i) & 0x1) == 0)                                    \
+        s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 0xf0) | (n); else    \
+        s->ll4[(i) >> 1] = (s->ll4[(i) >> 1] & 0x0f) | ((n) << 4);  \
+   }
+
+#define GET_LL4(i)                             \
+   ((((UInt32)(s->ll4[(i) >> 1])) >> (((i) << 2) & 0x4)) & 0xF)
+
+#define SET_LL(i,n)                          \
+   { s->ll16[i] = (UInt16)(n & 0x0000ffff);  \
+     SET_LL4(i, n >> 16);                    \
+   }
+
+#define GET_LL(i) \
+   (((UInt32)s->ll16[i]) | (GET_LL4(i) << 16))
+
+#define BZ_GET_SMALL(cccc)                            \
+      cccc = BZ2_indexIntoF ( s->tPos, s->cftab );    \
+      s->tPos = GET_LL(s->tPos);
+
+/*-- BZ_NO_STDIO seems to make NULL disappear on some platforms. --*/
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/*-------------------------------------------------------------*/
+/*--- Table for doing CRCs                                  ---*/
+/*---                                            crctable.c ---*/
+/*-------------------------------------------------------------*/
+
+/*--
+  I think this is an implementation of the AUTODIN-II,
+  Ethernet & FDDI 32-bit CRC standard.  Vaguely derived
+  from code by Rob Warnock, in Section 51 of the
+  comp.compression FAQ.
+--*/
+
+UInt32 BZ2_crc32Table[256] = {
+
+   /*-- Ugly, innit? --*/
+
+   0x00000000L, 0x04c11db7L, 0x09823b6eL, 0x0d4326d9L,
+   0x130476dcL, 0x17c56b6bL, 0x1a864db2L, 0x1e475005L,
+   0x2608edb8L, 0x22c9f00fL, 0x2f8ad6d6L, 0x2b4bcb61L,
+   0x350c9b64L, 0x31cd86d3L, 0x3c8ea00aL, 0x384fbdbdL,
+   0x4c11db70L, 0x48d0c6c7L, 0x4593e01eL, 0x4152fda9L,
+   0x5f15adacL, 0x5bd4b01bL, 0x569796c2L, 0x52568b75L,
+   0x6a1936c8L, 0x6ed82b7fL, 0x639b0da6L, 0x675a1011L,
+   0x791d4014L, 0x7ddc5da3L, 0x709f7b7aL, 0x745e66cdL,
+   0x9823b6e0L, 0x9ce2ab57L, 0x91a18d8eL, 0x95609039L,
+   0x8b27c03cL, 0x8fe6dd8bL, 0x82a5fb52L, 0x8664e6e5L,
+   0xbe2b5b58L, 0xbaea46efL, 0xb7a96036L, 0xb3687d81L,
+   0xad2f2d84L, 0xa9ee3033L, 0xa4ad16eaL, 0xa06c0b5dL,
+   0xd4326d90L, 0xd0f37027L, 0xddb056feL, 0xd9714b49L,
+   0xc7361b4cL, 0xc3f706fbL, 0xceb42022L, 0xca753d95L,
+   0xf23a8028L, 0xf6fb9d9fL, 0xfbb8bb46L, 0xff79a6f1L,
+   0xe13ef6f4L, 0xe5ffeb43L, 0xe8bccd9aL, 0xec7dd02dL,
+   0x34867077L, 0x30476dc0L, 0x3d044b19L, 0x39c556aeL,
+   0x278206abL, 0x23431b1cL, 0x2e003dc5L, 0x2ac12072L,
+   0x128e9dcfL, 0x164f8078L, 0x1b0ca6a1L, 0x1fcdbb16L,
+   0x018aeb13L, 0x054bf6a4L, 0x0808d07dL, 0x0cc9cdcaL,
+   0x7897ab07L, 0x7c56b6b0L, 0x71159069L, 0x75d48ddeL,
+   0x6b93dddbL, 0x6f52c06cL, 0x6211e6b5L, 0x66d0fb02L,
+   0x5e9f46bfL, 0x5a5e5b08L, 0x571d7dd1L, 0x53dc6066L,
+   0x4d9b3063L, 0x495a2dd4L, 0x44190b0dL, 0x40d816baL,
+   0xaca5c697L, 0xa864db20L, 0xa527fdf9L, 0xa1e6e04eL,
+   0xbfa1b04bL, 0xbb60adfcL, 0xb6238b25L, 0xb2e29692L,
+   0x8aad2b2fL, 0x8e6c3698L, 0x832f1041L, 0x87ee0df6L,
+   0x99a95df3L, 0x9d684044L, 0x902b669dL, 0x94ea7b2aL,
+   0xe0b41de7L, 0xe4750050L, 0xe9362689L, 0xedf73b3eL,
+   0xf3b06b3bL, 0xf771768cL, 0xfa325055L, 0xfef34de2L,
+   0xc6bcf05fL, 0xc27dede8L, 0xcf3ecb31L, 0xcbffd686L,
+   0xd5b88683L, 0xd1799b34L, 0xdc3abdedL, 0xd8fba05aL,
+   0x690ce0eeL, 0x6dcdfd59L, 0x608edb80L, 0x644fc637L,
+   0x7a089632L, 0x7ec98b85L, 0x738aad5cL, 0x774bb0ebL,
+   0x4f040d56L, 0x4bc510e1L, 0x46863638L, 0x42472b8fL,
+   0x5c007b8aL, 0x58c1663dL, 0x558240e4L, 0x51435d53L,
+   0x251d3b9eL, 0x21dc2629L, 0x2c9f00f0L, 0x285e1d47L,
+   0x36194d42L, 0x32d850f5L, 0x3f9b762cL, 0x3b5a6b9bL,
+   0x0315d626L, 0x07d4cb91L, 0x0a97ed48L, 0x0e56f0ffL,
+   0x1011a0faL, 0x14d0bd4dL, 0x19939b94L, 0x1d528623L,
+   0xf12f560eL, 0xf5ee4bb9L, 0xf8ad6d60L, 0xfc6c70d7L,
+   0xe22b20d2L, 0xe6ea3d65L, 0xeba91bbcL, 0xef68060bL,
+   0xd727bbb6L, 0xd3e6a601L, 0xdea580d8L, 0xda649d6fL,
+   0xc423cd6aL, 0xc0e2d0ddL, 0xcda1f604L, 0xc960ebb3L,
+   0xbd3e8d7eL, 0xb9ff90c9L, 0xb4bcb610L, 0xb07daba7L,
+   0xae3afba2L, 0xaafbe615L, 0xa7b8c0ccL, 0xa379dd7bL,
+   0x9b3660c6L, 0x9ff77d71L, 0x92b45ba8L, 0x9675461fL,
+   0x8832161aL, 0x8cf30badL, 0x81b02d74L, 0x857130c3L,
+   0x5d8a9099L, 0x594b8d2eL, 0x5408abf7L, 0x50c9b640L,
+   0x4e8ee645L, 0x4a4ffbf2L, 0x470cdd2bL, 0x43cdc09cL,
+   0x7b827d21L, 0x7f436096L, 0x7200464fL, 0x76c15bf8L,
+   0x68860bfdL, 0x6c47164aL, 0x61043093L, 0x65c52d24L,
+   0x119b4be9L, 0x155a565eL, 0x18197087L, 0x1cd86d30L,
+   0x029f3d35L, 0x065e2082L, 0x0b1d065bL, 0x0fdc1becL,
+   0x3793a651L, 0x3352bbe6L, 0x3e119d3fL, 0x3ad08088L,
+   0x2497d08dL, 0x2056cd3aL, 0x2d15ebe3L, 0x29d4f654L,
+   0xc5a92679L, 0xc1683bceL, 0xcc2b1d17L, 0xc8ea00a0L,
+   0xd6ad50a5L, 0xd26c4d12L, 0xdf2f6bcbL, 0xdbee767cL,
+   0xe3a1cbc1L, 0xe760d676L, 0xea23f0afL, 0xeee2ed18L,
+   0xf0a5bd1dL, 0xf464a0aaL, 0xf9278673L, 0xfde69bc4L,
+   0x89b8fd09L, 0x8d79e0beL, 0x803ac667L, 0x84fbdbd0L,
+   0x9abc8bd5L, 0x9e7d9662L, 0x933eb0bbL, 0x97ffad0cL,
+   0xafb010b1L, 0xab710d06L, 0xa6322bdfL, 0xa2f33668L,
+   0xbcb4666dL, 0xb8757bdaL, 0xb5365d03L, 0xb1f740b4L
+};
+
+/*-------------------------------------------------------------*/
+/*--- Table for randomising repetitive blocks               ---*/
+/*---                                           randtable.c ---*/
+/*-------------------------------------------------------------*/
+
+Int32 BZ2_rNums[512] = { 
+   619, 720, 127, 481, 931, 816, 813, 233, 566, 247, 
+   985, 724, 205, 454, 863, 491, 741, 242, 949, 214, 
+   733, 859, 335, 708, 621, 574, 73, 654, 730, 472, 
+   419, 436, 278, 496, 867, 210, 399, 680, 480, 51, 
+   878, 465, 811, 169, 869, 675, 611, 697, 867, 561, 
+   862, 687, 507, 283, 482, 129, 807, 591, 733, 623, 
+   150, 238, 59, 379, 684, 877, 625, 169, 643, 105, 
+   170, 607, 520, 932, 727, 476, 693, 425, 174, 647, 
+   73, 122, 335, 530, 442, 853, 695, 249, 445, 515, 
+   909, 545, 703, 919, 874, 474, 882, 500, 594, 612, 
+   641, 801, 220, 162, 819, 984, 589, 513, 495, 799, 
+   161, 604, 958, 533, 221, 400, 386, 867, 600, 782, 
+   382, 596, 414, 171, 516, 375, 682, 485, 911, 276, 
+   98, 553, 163, 354, 666, 933, 424, 341, 533, 870, 
+   227, 730, 475, 186, 263, 647, 537, 686, 600, 224, 
+   469, 68, 770, 919, 190, 373, 294, 822, 808, 206, 
+   184, 943, 795, 384, 383, 461, 404, 758, 839, 887, 
+   715, 67, 618, 276, 204, 918, 873, 777, 604, 560, 
+   951, 160, 578, 722, 79, 804, 96, 409, 713, 940, 
+   652, 934, 970, 447, 318, 353, 859, 672, 112, 785, 
+   645, 863, 803, 350, 139, 93, 354, 99, 820, 908, 
+   609, 772, 154, 274, 580, 184, 79, 626, 630, 742, 
+   653, 282, 762, 623, 680, 81, 927, 626, 789, 125, 
+   411, 521, 938, 300, 821, 78, 343, 175, 128, 250, 
+   170, 774, 972, 275, 999, 639, 495, 78, 352, 126, 
+   857, 956, 358, 619, 580, 124, 737, 594, 701, 612, 
+   669, 112, 134, 694, 363, 992, 809, 743, 168, 974, 
+   944, 375, 748, 52, 600, 747, 642, 182, 862, 81, 
+   344, 805, 988, 739, 511, 655, 814, 334, 249, 515, 
+   897, 955, 664, 981, 649, 113, 974, 459, 893, 228, 
+   433, 837, 553, 268, 926, 240, 102, 654, 459, 51, 
+   686, 754, 806, 760, 493, 403, 415, 394, 687, 700, 
+   946, 670, 656, 610, 738, 392, 760, 799, 887, 653, 
+   978, 321, 576, 617, 626, 502, 894, 679, 243, 440, 
+   680, 879, 194, 572, 640, 724, 926, 56, 204, 700, 
+   707, 151, 457, 449, 797, 195, 791, 558, 945, 679, 
+   297, 59, 87, 824, 713, 663, 412, 693, 342, 606, 
+   134, 108, 571, 364, 631, 212, 174, 643, 304, 329, 
+   343, 97, 430, 751, 497, 314, 983, 374, 822, 928, 
+   140, 206, 73, 263, 980, 736, 876, 478, 430, 305, 
+   170, 514, 364, 692, 829, 82, 855, 953, 676, 246, 
+   369, 970, 294, 750, 807, 827, 150, 790, 288, 923, 
+   804, 378, 215, 828, 592, 281, 565, 555, 710, 82, 
+   896, 831, 547, 261, 524, 462, 293, 465, 502, 56, 
+   661, 821, 976, 991, 658, 869, 905, 758, 745, 193, 
+   768, 550, 608, 933, 378, 286, 215, 979, 792, 961, 
+   61, 688, 793, 644, 986, 403, 106, 366, 905, 644, 
+   372, 567, 466, 434, 645, 210, 389, 550, 919, 135, 
+   780, 773, 635, 389, 707, 100, 626, 958, 165, 504, 
+   920, 176, 193, 713, 857, 265, 203, 50, 668, 108, 
+   645, 990, 626, 197, 510, 357, 358, 850, 858, 364, 
+   936, 638
+};
+
+
+/*-- Core (low-level) library functions --*/
+
+BZ_EXTERN int BZ_API(BZ2_bzCompressInit) ( 
+      bz_stream* strm, 
+      int        blockSize100k, 
+      int        verbosity, 
+      int        workFactor 
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzCompress) ( 
+      bz_stream* strm, 
+      int action 
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzCompressEnd) ( 
+      bz_stream* strm 
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzDecompressInit) ( 
+      bz_stream *strm, 
+      int       verbosity, 
+      int       small
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzDecompress) ( 
+      bz_stream* strm 
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzDecompressEnd) ( 
+      bz_stream *strm 
+   );
+
+/*-- Utility functions --*/
+
+BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffCompress) ( 
+      char*         dest, 
+      unsigned int* destLen,
+      char*         source, 
+      unsigned int  sourceLen,
+      int           blockSize100k, 
+      int           verbosity, 
+      int           workFactor 
+   );
+
+BZ_EXTERN int BZ_API(BZ2_bzBuffToBuffDecompress) ( 
+      char*         dest, 
+      unsigned int* destLen,
+      char*         source, 
+      unsigned int  sourceLen,
+      int           small, 
+      int           verbosity 
+   );
+
+
+/*--
+   Code contributed by Yoshioka Tsuneo
+   (QWF00133@niftyserve.or.jp/tsuneo-y@is.aist-nara.ac.jp),
+   to support better zlib compatibility.
+   This code is not _officially_ part of libbzip2 (yet);
+   I haven't tested it, documented it, or considered the
+   threading-safeness of it.
+   If this code breaks, please contact both Yoshioka and me.
+--*/
+
+BZ_EXTERN const char * BZ_API(BZ2_bzlibVersion) (
+      void
+   );
+
+
+
+/*---------------------------------------------------*/
+
+static
+int bz_config_ok ( void )
+{
+   if (sizeof(int)   != 4) return 0;
+   if (sizeof(short) != 2) return 0;
+   if (sizeof(char)  != 1) return 0;
+   return 1;
+}
+
+/*---------------------------------------------------*/
+static
+void* default_bzalloc ( void* opaque, Int32 items, Int32 size )
+{
+   void* v = malloc ( items * size );
+   return v;
+}
+
+static
+void default_bzfree ( void* opaque, void* addr )
+{
+   if (addr != NULL) free ( addr );
+}
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzDecompressInit) 
+                     ( bz_stream* strm, 
+                       int        verbosity,
+                       int        small )
+{
+   DState* s;
+
+   if (!bz_config_ok()) return BZ_CONFIG_ERROR;
+
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   if (small != 0 && small != 1) return BZ_PARAM_ERROR;
+   if (verbosity < 0 || verbosity > 4) return BZ_PARAM_ERROR;
+
+   if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;
+   if (strm->bzfree == NULL) strm->bzfree = default_bzfree;
+
+   s = BZALLOC( sizeof(DState) );
+   if (s == NULL) return BZ_MEM_ERROR;
+   s->strm                  = strm;
+   strm->state              = s;
+   s->state                 = BZ_X_MAGIC_1;
+   s->bsLive                = 0;
+   s->bsBuff                = 0;
+   s->calculatedCombinedCRC = 0;
+   strm->total_in_lo32      = 0;
+   strm->total_in_hi32      = 0;
+   strm->total_out_lo32     = 0;
+   strm->total_out_hi32     = 0;
+   s->smallDecompress       = (Bool)small;
+   s->ll4                   = NULL;
+   s->ll16                  = NULL;
+   s->tt                    = NULL;
+   s->currBlockNo           = 0;
+   s->verbosity             = verbosity;
+
+   return BZ_OK;
+}
+
+
+/*---------------------------------------------------*/
+static
+void unRLE_obuf_to_output_FAST ( DState* s )
+{
+   UChar k1;
+
+   if (s->blockRandomised) {
+
+      while (True) {
+         /* try to finish existing run */
+         while (True) {
+            if (s->strm->avail_out == 0) return;
+            if (s->state_out_len == 0) break;
+            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
+            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
+            s->state_out_len--;
+            s->strm->next_out++;
+            s->strm->avail_out--;
+            s->strm->total_out_lo32++;
+            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+         }
+   
+         /* can a new run be started? */
+         if (s->nblock_used == s->save_nblock+1) return;
+               
+   
+         s->state_out_len = 1;
+         s->state_out_ch = s->k0;
+         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         s->state_out_len = 2;
+         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         s->state_out_len = 3;
+         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         BZ_GET_FAST(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         s->state_out_len = ((Int32)k1) + 4;
+         BZ_GET_FAST(s->k0); BZ_RAND_UPD_MASK; 
+         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;
+      }
+
+   } else {
+
+      /* restore */
+      UInt32        c_calculatedBlockCRC = s->calculatedBlockCRC;
+      UChar         c_state_out_ch       = s->state_out_ch;
+      Int32         c_state_out_len      = s->state_out_len;
+      Int32         c_nblock_used        = s->nblock_used;
+      Int32         c_k0                 = s->k0;
+      UInt32*       c_tt                 = s->tt;
+      UInt32        c_tPos               = s->tPos;
+      char*         cs_next_out          = s->strm->next_out;
+      unsigned int  cs_avail_out         = s->strm->avail_out;
+      /* end restore */
+
+      UInt32       avail_out_INIT = cs_avail_out;
+      Int32        s_save_nblockPP = s->save_nblock+1;
+      unsigned int total_out_lo32_old;
+
+      while (True) {
+
+         /* try to finish existing run */
+         if (c_state_out_len > 0) {
+            while (True) {
+               if (cs_avail_out == 0) goto return_notr;
+               if (c_state_out_len == 1) break;
+               *( (UChar*)(cs_next_out) ) = c_state_out_ch;
+               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );
+               c_state_out_len--;
+               cs_next_out++;
+               cs_avail_out--;
+            }
+            s_state_out_len_eq_one:
+            {
+               if (cs_avail_out == 0) { 
+                  c_state_out_len = 1; goto return_notr;
+               };
+               *( (UChar*)(cs_next_out) ) = c_state_out_ch;
+               BZ_UPDATE_CRC ( c_calculatedBlockCRC, c_state_out_ch );
+               cs_next_out++;
+               cs_avail_out--;
+            }
+         }   
+         /* can a new run be started? */
+         if (c_nblock_used == s_save_nblockPP) {
+            c_state_out_len = 0; goto return_notr;
+         };   
+         c_state_out_ch = c_k0;
+         BZ_GET_FAST_C(k1); c_nblock_used++;
+         if (k1 != c_k0) { 
+            c_k0 = k1; goto s_state_out_len_eq_one; 
+         };
+         if (c_nblock_used == s_save_nblockPP) 
+            goto s_state_out_len_eq_one;
+   
+         c_state_out_len = 2;
+         BZ_GET_FAST_C(k1); c_nblock_used++;
+         if (c_nblock_used == s_save_nblockPP) continue;
+         if (k1 != c_k0) { c_k0 = k1; continue; };
+   
+         c_state_out_len = 3;
+         BZ_GET_FAST_C(k1); c_nblock_used++;
+         if (c_nblock_used == s_save_nblockPP) continue;
+         if (k1 != c_k0) { c_k0 = k1; continue; };
+   
+         BZ_GET_FAST_C(k1); c_nblock_used++;
+         c_state_out_len = ((Int32)k1) + 4;
+         BZ_GET_FAST_C(c_k0); c_nblock_used++;
+      }
+
+      return_notr:
+      total_out_lo32_old = s->strm->total_out_lo32;
+      s->strm->total_out_lo32 += (avail_out_INIT - cs_avail_out);
+      if (s->strm->total_out_lo32 < total_out_lo32_old)
+         s->strm->total_out_hi32++;
+
+      /* save */
+      s->calculatedBlockCRC = c_calculatedBlockCRC;
+      s->state_out_ch       = c_state_out_ch;
+      s->state_out_len      = c_state_out_len;
+      s->nblock_used        = c_nblock_used;
+      s->k0                 = c_k0;
+      s->tt                 = c_tt;
+      s->tPos               = c_tPos;
+      s->strm->next_out     = cs_next_out;
+      s->strm->avail_out    = cs_avail_out;
+      /* end save */
+   }
+}
+
+/*---------------------------------------------------*/
+__inline__ Int32 BZ2_indexIntoF ( Int32 indx, Int32 *cftab )
+{
+   Int32 nb, na, mid;
+   nb = 0;
+   na = 256;
+   do {
+      mid = (nb + na) >> 1;
+      if (indx >= cftab[mid]) nb = mid; else na = mid;
+   }
+   while (na - nb != 1);
+   return nb;
+}
+
+/*---------------------------------------------------*/
+static
+void unRLE_obuf_to_output_SMALL ( DState* s )
+{
+   UChar k1;
+
+   if (s->blockRandomised) {
+
+      while (True) {
+         /* try to finish existing run */
+         while (True) {
+            if (s->strm->avail_out == 0) return;
+            if (s->state_out_len == 0) break;
+            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
+            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
+            s->state_out_len--;
+            s->strm->next_out++;
+            s->strm->avail_out--;
+            s->strm->total_out_lo32++;
+            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+         }
+   
+         /* can a new run be started? */
+         if (s->nblock_used == s->save_nblock+1) return;
+               
+   
+         s->state_out_len = 1;
+         s->state_out_ch = s->k0;
+         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         s->state_out_len = 2;
+         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         s->state_out_len = 3;
+         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         BZ_GET_SMALL(k1); BZ_RAND_UPD_MASK; 
+         k1 ^= BZ_RAND_MASK; s->nblock_used++;
+         s->state_out_len = ((Int32)k1) + 4;
+         BZ_GET_SMALL(s->k0); BZ_RAND_UPD_MASK; 
+         s->k0 ^= BZ_RAND_MASK; s->nblock_used++;
+      }
+
+   } else {
+
+      while (True) {
+         /* try to finish existing run */
+         while (True) {
+            if (s->strm->avail_out == 0) return;
+            if (s->state_out_len == 0) break;
+            *( (UChar*)(s->strm->next_out) ) = s->state_out_ch;
+            BZ_UPDATE_CRC ( s->calculatedBlockCRC, s->state_out_ch );
+            s->state_out_len--;
+            s->strm->next_out++;
+            s->strm->avail_out--;
+            s->strm->total_out_lo32++;
+            if (s->strm->total_out_lo32 == 0) s->strm->total_out_hi32++;
+         }
+   
+         /* can a new run be started? */
+         if (s->nblock_used == s->save_nblock+1) return;
+   
+         s->state_out_len = 1;
+         s->state_out_ch = s->k0;
+         BZ_GET_SMALL(k1); s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         s->state_out_len = 2;
+         BZ_GET_SMALL(k1); s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         s->state_out_len = 3;
+         BZ_GET_SMALL(k1); s->nblock_used++;
+         if (s->nblock_used == s->save_nblock+1) continue;
+         if (k1 != s->k0) { s->k0 = k1; continue; };
+   
+         BZ_GET_SMALL(k1); s->nblock_used++;
+         s->state_out_len = ((Int32)k1) + 4;
+         BZ_GET_SMALL(s->k0); s->nblock_used++;
+      }
+
+   }
+}
+
+Int32 BZ2_decompress ( DState* s );
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzDecompress) ( bz_stream *strm )
+{
+   DState* s;
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   s = strm->state;
+   if (s == NULL) return BZ_PARAM_ERROR;
+   if (s->strm != strm) return BZ_PARAM_ERROR;
+
+   while (True) {
+      if (s->state == BZ_X_IDLE) return BZ_SEQUENCE_ERROR;
+      if (s->state == BZ_X_OUTPUT) {
+         if (s->smallDecompress)
+            unRLE_obuf_to_output_SMALL ( s ); else
+            unRLE_obuf_to_output_FAST  ( s );
+         if (s->nblock_used == s->save_nblock+1 && s->state_out_len == 0) {
+            BZ_FINALISE_CRC ( s->calculatedBlockCRC );
+            if (s->verbosity >= 3) 
+               VPrintf2 ( " {0x%x, 0x%x}", s->storedBlockCRC, 
+                          s->calculatedBlockCRC );
+            if (s->verbosity >= 2) VPrintf0 ( "]" );
+            if (s->calculatedBlockCRC != s->storedBlockCRC)
+               return BZ_DATA_ERROR;
+            s->calculatedCombinedCRC 
+               = (s->calculatedCombinedCRC << 1) | 
+                    (s->calculatedCombinedCRC >> 31);
+            s->calculatedCombinedCRC ^= s->calculatedBlockCRC;
+            s->state = BZ_X_BLKHDR_1;
+         } else {
+            return BZ_OK;
+         }
+      }
+      if (s->state >= BZ_X_MAGIC_1) {
+         Int32 r = BZ2_decompress ( s );
+         if (r == BZ_STREAM_END) {
+            if (s->verbosity >= 3)
+               VPrintf2 ( "\n    combined CRCs: stored = 0x%x, computed = 0x%x", 
+                          s->storedCombinedCRC, s->calculatedCombinedCRC );
+            if (s->calculatedCombinedCRC != s->storedCombinedCRC)
+               return BZ_DATA_ERROR;
+            return r;
+         }
+         if (s->state != BZ_X_OUTPUT) return r;
+      }
+   }
+
+   AssertH ( 0, 6001 );
+
+   return 0;  /*NOTREACHED*/
+}
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzDecompressEnd)  ( bz_stream *strm )
+{
+   DState* s;
+   if (strm == NULL) return BZ_PARAM_ERROR;
+   s = strm->state;
+   if (s == NULL) return BZ_PARAM_ERROR;
+   if (s->strm != strm) return BZ_PARAM_ERROR;
+
+   if (s->tt   != NULL) BZFREE(s->tt);
+   if (s->ll16 != NULL) BZFREE(s->ll16);
+   if (s->ll4  != NULL) BZFREE(s->ll4);
+
+   BZFREE(strm->state);
+   strm->state = NULL;
+
+   return BZ_OK;
+}
+
+/*---------------------------------------------------*/
+int BZ_API(BZ2_bzBuffToBuffDecompress) 
+                           ( char*         dest, 
+                             unsigned int* destLen,
+                             char*         source, 
+                             unsigned int  sourceLen,
+                             int           small,
+                             int           verbosity )
+{
+   bz_stream strm;
+   int ret;
+
+   if (dest == NULL || destLen == NULL || 
+       source == NULL ||
+       (small != 0 && small != 1) ||
+       verbosity < 0 || verbosity > 4) 
+          return BZ_PARAM_ERROR;
+
+   strm.bzalloc = NULL;
+   strm.bzfree = NULL;
+   strm.opaque = NULL;
+   ret = BZ2_bzDecompressInit ( &strm, verbosity, small );
+   if (ret != BZ_OK) return ret;
+
+   strm.next_in = source;
+   strm.next_out = dest;
+   strm.avail_in = sourceLen;
+   strm.avail_out = *destLen;
+
+   ret = BZ2_bzDecompress ( &strm );
+   if (ret == BZ_OK) goto output_overflow_or_eof;
+   if (ret != BZ_STREAM_END) goto errhandler;
+
+   /* normal termination */
+   *destLen -= strm.avail_out;
+   BZ2_bzDecompressEnd ( &strm );
+   return BZ_OK;
+
+   output_overflow_or_eof:
+   if (strm.avail_out > 0) {
+      BZ2_bzDecompressEnd ( &strm );
+      return BZ_UNEXPECTED_EOF;
+   } else {
+      BZ2_bzDecompressEnd ( &strm );
+      return BZ_OUTBUFF_FULL;
+   };      
+
+   errhandler:
+   BZ2_bzDecompressEnd ( &strm );
+   return ret; 
+}
+
+/*---------------------------------------------------*/
+static
+void makeMaps_d ( DState* s )
+{
+   Int32 i;
+   s->nInUse = 0;
+   for (i = 0; i < 256; i++)
+      if (s->inUse[i]) {
+         s->seqToUnseq[s->nInUse] = i;
+         s->nInUse++;
+      }
+}
+
+/*---------------------------------------------------*/
+#define RETURN(rrr)                               \
+   { retVal = rrr; goto save_state_and_return; };
+
+#define GET_BITS(lll,vvv,nnn)                     \
+   case lll: s->state = lll;                      \
+   while (True) {                                 \
+      if (s->bsLive >= nnn) {                     \
+         UInt32 v;                                \
+         v = (s->bsBuff >>                        \
+             (s->bsLive-nnn)) & ((1 << nnn)-1);   \
+         s->bsLive -= nnn;                        \
+         vvv = v;                                 \
+         break;                                   \
+      }                                           \
+      if (s->strm->avail_in == 0) RETURN(BZ_OK);  \
+      s->bsBuff                                   \
+         = (s->bsBuff << 8) |                     \
+           ((UInt32)                              \
+              (*((UChar*)(s->strm->next_in))));   \
+      s->bsLive += 8;                             \
+      s->strm->next_in++;                         \
+      s->strm->avail_in--;                        \
+      s->strm->total_in_lo32++;                   \
+      if (s->strm->total_in_lo32 == 0)            \
+         s->strm->total_in_hi32++;                \
+   }
+
+#define GET_UCHAR(lll,uuu)                        \
+   GET_BITS(lll,uuu,8)
+
+#define GET_BIT(lll,uuu)                          \
+   GET_BITS(lll,uuu,1)
+
+/*---------------------------------------------------*/
+#define GET_MTF_VAL(label1,label2,lval)           \
+{                                                 \
+   if (groupPos == 0) {                           \
+      groupNo++;                                  \
+      if (groupNo >= nSelectors)                  \
+         RETURN(BZ_DATA_ERROR);                   \
+      groupPos = BZ_G_SIZE;                       \
+      gSel = s->selector[groupNo];                \
+      gMinlen = s->minLens[gSel];                 \
+      gLimit = &(s->limit[gSel][0]);              \
+      gPerm = &(s->perm[gSel][0]);                \
+      gBase = &(s->base[gSel][0]);                \
+   }                                              \
+   groupPos--;                                    \
+   zn = gMinlen;                                  \
+   GET_BITS(label1, zvec, zn);                    \
+   while (1) {                                    \
+      if (zn > 20 /* the longest code */)         \
+         RETURN(BZ_DATA_ERROR);                   \
+      if (zvec <= gLimit[zn]) break;              \
+      zn++;                                       \
+      GET_BIT(label2, zj);                        \
+      zvec = (zvec << 1) | zj;                    \
+   };                                             \
+   if (zvec - gBase[zn] < 0                       \
+       || zvec - gBase[zn] >= BZ_MAX_ALPHA_SIZE)  \
+      RETURN(BZ_DATA_ERROR);                      \
+   lval = gPerm[zvec - gBase[zn]];                \
+}
+
+/*---------------------------------------------------*/
+void BZ2_hbCreateDecodeTables ( Int32 *limit,
+                                Int32 *base,
+                                Int32 *perm,
+                                UChar *length,
+                                Int32 minLen,
+                                Int32 maxLen,
+                                Int32 alphaSize )
+{
+   Int32 pp, i, j, vec;
+
+   pp = 0;
+   for (i = minLen; i <= maxLen; i++)
+      for (j = 0; j < alphaSize; j++)
+         if (length[j] == i) { perm[pp] = j; pp++; };
+
+   for (i = 0; i < BZ_MAX_CODE_LEN; i++) base[i] = 0;
+   for (i = 0; i < alphaSize; i++) base[length[i]+1]++;
+
+   for (i = 1; i < BZ_MAX_CODE_LEN; i++) base[i] += base[i-1];
+
+   for (i = 0; i < BZ_MAX_CODE_LEN; i++) limit[i] = 0;
+   vec = 0;
+
+   for (i = minLen; i <= maxLen; i++) {
+      vec += (base[i+1] - base[i]);
+      limit[i] = vec-1;
+      vec <<= 1;
+   }
+   for (i = minLen + 1; i <= maxLen; i++)
+      base[i] = ((limit[i-1] + 1) << 1) - base[i];
+}
+
+
+/*---------------------------------------------------*/
+Int32 BZ2_decompress ( DState* s )
+{
+   UChar      uc;
+   Int32      retVal;
+   Int32      minLen, maxLen;
+   bz_stream* strm = s->strm;
+
+   /* stuff that needs to be saved/restored */
+   Int32  i;
+   Int32  j;
+   Int32  t;
+   Int32  alphaSize;
+   Int32  nGroups;
+   Int32  nSelectors;
+   Int32  EOB;
+   Int32  groupNo;
+   Int32  groupPos;
+   Int32  nextSym;
+   Int32  nblockMAX;
+   Int32  nblock;
+   Int32  es;
+   Int32  N;
+   Int32  curr;
+   Int32  zt;
+   Int32  zn; 
+   Int32  zvec;
+   Int32  zj;
+   Int32  gSel;
+   Int32  gMinlen;
+   Int32* gLimit;
+   Int32* gBase;
+   Int32* gPerm;
+
+   if (s->state == BZ_X_MAGIC_1) {
+      /*initialise the save area*/
+      s->save_i           = 0;
+      s->save_j           = 0;
+      s->save_t           = 0;
+      s->save_alphaSize   = 0;
+      s->save_nGroups     = 0;
+      s->save_nSelectors  = 0;
+      s->save_EOB         = 0;
+      s->save_groupNo     = 0;
+      s->save_groupPos    = 0;
+      s->save_nextSym     = 0;
+      s->save_nblockMAX   = 0;
+      s->save_nblock      = 0;
+      s->save_es          = 0;
+      s->save_N           = 0;
+      s->save_curr        = 0;
+      s->save_zt          = 0;
+      s->save_zn          = 0;
+      s->save_zvec        = 0;
+      s->save_zj          = 0;
+      s->save_gSel        = 0;
+      s->save_gMinlen     = 0;
+      s->save_gLimit      = NULL;
+      s->save_gBase       = NULL;
+      s->save_gPerm       = NULL;
+   }
+
+   /*restore from the save area*/
+   i           = s->save_i;
+   j           = s->save_j;
+   t           = s->save_t;
+   alphaSize   = s->save_alphaSize;
+   nGroups     = s->save_nGroups;
+   nSelectors  = s->save_nSelectors;
+   EOB         = s->save_EOB;
+   groupNo     = s->save_groupNo;
+   groupPos    = s->save_groupPos;
+   nextSym     = s->save_nextSym;
+   nblockMAX   = s->save_nblockMAX;
+   nblock      = s->save_nblock;
+   es          = s->save_es;
+   N           = s->save_N;
+   curr        = s->save_curr;
+   zt          = s->save_zt;
+   zn          = s->save_zn; 
+   zvec        = s->save_zvec;
+   zj          = s->save_zj;
+   gSel        = s->save_gSel;
+   gMinlen     = s->save_gMinlen;
+   gLimit      = s->save_gLimit;
+   gBase       = s->save_gBase;
+   gPerm       = s->save_gPerm;
+
+   retVal = BZ_OK;
+
+   switch (s->state) {
+
+      GET_UCHAR(BZ_X_MAGIC_1, uc);
+      if (uc != BZ_HDR_B) RETURN(BZ_DATA_ERROR_MAGIC);
+
+      GET_UCHAR(BZ_X_MAGIC_2, uc);
+      if (uc != BZ_HDR_Z) RETURN(BZ_DATA_ERROR_MAGIC);
+
+      GET_UCHAR(BZ_X_MAGIC_3, uc)
+      if (uc != BZ_HDR_h) RETURN(BZ_DATA_ERROR_MAGIC);
+
+      GET_BITS(BZ_X_MAGIC_4, s->blockSize100k, 8)
+      if (s->blockSize100k < (BZ_HDR_0 + 1) || 
+          s->blockSize100k > (BZ_HDR_0 + 9)) RETURN(BZ_DATA_ERROR_MAGIC);
+      s->blockSize100k -= BZ_HDR_0;
+
+      if (s->smallDecompress) {
+         s->ll16 = BZALLOC( s->blockSize100k * 100000 * sizeof(UInt16) );
+         s->ll4  = BZALLOC( 
+                      ((1 + s->blockSize100k * 100000) >> 1) * sizeof(UChar) 
+                   );
+         if (s->ll16 == NULL || s->ll4 == NULL) RETURN(BZ_MEM_ERROR);
+      } else {
+         s->tt  = BZALLOC( s->blockSize100k * 100000 * sizeof(Int32) );
+         if (s->tt == NULL) RETURN(BZ_MEM_ERROR);
+      }
+
+      GET_UCHAR(BZ_X_BLKHDR_1, uc);
+
+      if (uc == 0x17) goto endhdr_2;
+      if (uc != 0x31) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_2, uc);
+      if (uc != 0x41) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_3, uc);
+      if (uc != 0x59) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_4, uc);
+      if (uc != 0x26) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_5, uc);
+      if (uc != 0x53) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_BLKHDR_6, uc);
+      if (uc != 0x59) RETURN(BZ_DATA_ERROR);
+
+      s->currBlockNo++;
+      if (s->verbosity >= 2)
+         VPrintf1 ( "\n    [%d: huff+mtf ", s->currBlockNo );
+ 
+      s->storedBlockCRC = 0;
+      GET_UCHAR(BZ_X_BCRC_1, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_BCRC_2, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_BCRC_3, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_BCRC_4, uc);
+      s->storedBlockCRC = (s->storedBlockCRC << 8) | ((UInt32)uc);
+
+      GET_BITS(BZ_X_RANDBIT, s->blockRandomised, 1);
+
+      s->origPtr = 0;
+      GET_UCHAR(BZ_X_ORIGPTR_1, uc);
+      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
+      GET_UCHAR(BZ_X_ORIGPTR_2, uc);
+      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
+      GET_UCHAR(BZ_X_ORIGPTR_3, uc);
+      s->origPtr = (s->origPtr << 8) | ((Int32)uc);
+
+      if (s->origPtr < 0)
+         RETURN(BZ_DATA_ERROR);
+      if (s->origPtr > 10 + 100000*s->blockSize100k) 
+         RETURN(BZ_DATA_ERROR);
+
+      /*--- Receive the mapping table ---*/
+      for (i = 0; i < 16; i++) {
+         GET_BIT(BZ_X_MAPPING_1, uc);
+         if (uc == 1) 
+            s->inUse16[i] = True; else 
+            s->inUse16[i] = False;
+      }
+
+      for (i = 0; i < 256; i++) s->inUse[i] = False;
+
+      for (i = 0; i < 16; i++)
+         if (s->inUse16[i])
+            for (j = 0; j < 16; j++) {
+               GET_BIT(BZ_X_MAPPING_2, uc);
+               if (uc == 1) s->inUse[i * 16 + j] = True;
+            }
+      makeMaps_d ( s );
+      if (s->nInUse == 0) RETURN(BZ_DATA_ERROR);
+      alphaSize = s->nInUse+2;
+
+      /*--- Now the selectors ---*/
+      GET_BITS(BZ_X_SELECTOR_1, nGroups, 3);
+      if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR);
+      GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15);
+      if (nSelectors < 1) RETURN(BZ_DATA_ERROR);
+      for (i = 0; i < nSelectors; i++) {
+         j = 0;
+         while (True) {
+            GET_BIT(BZ_X_SELECTOR_3, uc);
+            if (uc == 0) break;
+            j++;
+            if (j >= nGroups) RETURN(BZ_DATA_ERROR);
+         }
+         s->selectorMtf[i] = j;
+      }
+
+      /*--- Undo the MTF values for the selectors. ---*/
+      {
+         UChar pos[BZ_N_GROUPS], tmp, v;
+         for (v = 0; v < nGroups; v++) pos[v] = v;
+   
+         for (i = 0; i < nSelectors; i++) {
+            v = s->selectorMtf[i];
+            tmp = pos[v];
+            while (v > 0) { pos[v] = pos[v-1]; v--; }
+            pos[0] = tmp;
+            s->selector[i] = tmp;
+         }
+      }
+
+      /*--- Now the coding tables ---*/
+      for (t = 0; t < nGroups; t++) {
+         GET_BITS(BZ_X_CODING_1, curr, 5);
+         for (i = 0; i < alphaSize; i++) {
+            while (True) {
+               if (curr < 1 || curr > 20) RETURN(BZ_DATA_ERROR);
+               GET_BIT(BZ_X_CODING_2, uc);
+               if (uc == 0) break;
+               GET_BIT(BZ_X_CODING_3, uc);
+               if (uc == 0) curr++; else curr--;
+            }
+            s->len[t][i] = curr;
+         }
+      }
+
+      /*--- Create the Huffman decoding tables ---*/
+      for (t = 0; t < nGroups; t++) {
+         minLen = 32;
+         maxLen = 0;
+         for (i = 0; i < alphaSize; i++) {
+            if (s->len[t][i] > maxLen) maxLen = s->len[t][i];
+            if (s->len[t][i] < minLen) minLen = s->len[t][i];
+         }
+         BZ2_hbCreateDecodeTables ( 
+            &(s->limit[t][0]), 
+            &(s->base[t][0]), 
+            &(s->perm[t][0]), 
+            &(s->len[t][0]),
+            minLen, maxLen, alphaSize
+         );
+         s->minLens[t] = minLen;
+      }
+
+      /*--- Now the MTF values ---*/
+
+      EOB      = s->nInUse+1;
+      nblockMAX = 100000 * s->blockSize100k;
+      groupNo  = -1;
+      groupPos = 0;
+
+      for (i = 0; i <= 255; i++) s->unzftab[i] = 0;
+
+      /*-- MTF init --*/
+      {
+         Int32 ii, jj, kk;
+         kk = MTFA_SIZE-1;
+         for (ii = 256 / MTFL_SIZE - 1; ii >= 0; ii--) {
+            for (jj = MTFL_SIZE-1; jj >= 0; jj--) {
+               s->mtfa[kk] = (UChar)(ii * MTFL_SIZE + jj);
+               kk--;
+            }
+            s->mtfbase[ii] = kk + 1;
+         }
+      }
+      /*-- end MTF init --*/
+
+      nblock = 0;
+      GET_MTF_VAL(BZ_X_MTF_1, BZ_X_MTF_2, nextSym);
+
+      while (True) {
+
+         if (nextSym == EOB) break;
+
+         if (nextSym == BZ_RUNA || nextSym == BZ_RUNB) {
+
+            es = -1;
+            N = 1;
+            do {
+               if (nextSym == BZ_RUNA) es = es + (0+1) * N; else
+               if (nextSym == BZ_RUNB) es = es + (1+1) * N;
+               N = N * 2;
+               GET_MTF_VAL(BZ_X_MTF_3, BZ_X_MTF_4, nextSym);
+            }
+               while (nextSym == BZ_RUNA || nextSym == BZ_RUNB);
+
+            es++;
+            uc = s->seqToUnseq[ s->mtfa[s->mtfbase[0]] ];
+            s->unzftab[uc] += es;
+
+            if (s->smallDecompress)
+               while (es > 0) {
+                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
+                  s->ll16[nblock] = (UInt16)uc;
+                  nblock++;
+                  es--;
+               }
+            else
+               while (es > 0) {
+                  if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
+                  s->tt[nblock] = (UInt32)uc;
+                  nblock++;
+                  es--;
+               };
+
+            continue;
+
+         } else {
+
+            if (nblock >= nblockMAX) RETURN(BZ_DATA_ERROR);
+
+            /*-- uc = MTF ( nextSym-1 ) --*/
+            {
+               Int32 ii, jj, kk, pp, lno, off;
+               UInt32 nn;
+               nn = (UInt32)(nextSym - 1);
+
+               if (nn < MTFL_SIZE) {
+                  /* avoid general-case expense */
+                  pp = s->mtfbase[0];
+                  uc = s->mtfa[pp+nn];
+                  while (nn > 3) {
+                     Int32 z = pp+nn;
+                     s->mtfa[(z)  ] = s->mtfa[(z)-1];
+                     s->mtfa[(z)-1] = s->mtfa[(z)-2];
+                     s->mtfa[(z)-2] = s->mtfa[(z)-3];
+                     s->mtfa[(z)-3] = s->mtfa[(z)-4];
+                     nn -= 4;
+                  }
+                  while (nn > 0) { 
+                     s->mtfa[(pp+nn)] = s->mtfa[(pp+nn)-1]; nn--; 
+                  };
+                  s->mtfa[pp] = uc;
+               } else { 
+                  /* general case */
+                  lno = nn / MTFL_SIZE;
+                  off = nn % MTFL_SIZE;
+                  pp = s->mtfbase[lno] + off;
+                  uc = s->mtfa[pp];
+                  while (pp > s->mtfbase[lno]) { 
+                     s->mtfa[pp] = s->mtfa[pp-1]; pp--; 
+                  };
+                  s->mtfbase[lno]++;
+                  while (lno > 0) {
+                     s->mtfbase[lno]--;
+                     s->mtfa[s->mtfbase[lno]] 
+                        = s->mtfa[s->mtfbase[lno-1] + MTFL_SIZE - 1];
+                     lno--;
+                  }
+                  s->mtfbase[0]--;
+                  s->mtfa[s->mtfbase[0]] = uc;
+                  if (s->mtfbase[0] == 0) {
+                     kk = MTFA_SIZE-1;
+                     for (ii = 256 / MTFL_SIZE-1; ii >= 0; ii--) {
+                        for (jj = MTFL_SIZE-1; jj >= 0; jj--) {
+                           s->mtfa[kk] = s->mtfa[s->mtfbase[ii] + jj];
+                           kk--;
+                        }
+                        s->mtfbase[ii] = kk + 1;
+                     }
+                  }
+               }
+            }
+            /*-- end uc = MTF ( nextSym-1 ) --*/
+
+            s->unzftab[s->seqToUnseq[uc]]++;
+            if (s->smallDecompress)
+               s->ll16[nblock] = (UInt16)(s->seqToUnseq[uc]); else
+               s->tt[nblock]   = (UInt32)(s->seqToUnseq[uc]);
+            nblock++;
+
+            GET_MTF_VAL(BZ_X_MTF_5, BZ_X_MTF_6, nextSym);
+            continue;
+         }
+      }
+
+      /* Now we know what nblock is, we can do a better sanity
+         check on s->origPtr.
+      */
+      if (s->origPtr < 0 || s->origPtr >= nblock)
+         RETURN(BZ_DATA_ERROR);
+
+      s->state_out_len = 0;
+      s->state_out_ch  = 0;
+      BZ_INITIALISE_CRC ( s->calculatedBlockCRC );
+      s->state = BZ_X_OUTPUT;
+      if (s->verbosity >= 2) VPrintf0 ( "rt+rld" );
+
+      /*-- Set up cftab to facilitate generation of T^(-1) --*/
+      s->cftab[0] = 0;
+      for (i = 1; i <= 256; i++) s->cftab[i] = s->unzftab[i-1];
+      for (i = 1; i <= 256; i++) s->cftab[i] += s->cftab[i-1];
+
+      if (s->smallDecompress) {
+
+         /*-- Make a copy of cftab, used in generation of T --*/
+         for (i = 0; i <= 256; i++) s->cftabCopy[i] = s->cftab[i];
+
+         /*-- compute the T vector --*/
+         for (i = 0; i < nblock; i++) {
+            uc = (UChar)(s->ll16[i]);
+            SET_LL(i, s->cftabCopy[uc]);
+            s->cftabCopy[uc]++;
+         }
+
+         /*-- Compute T^(-1) by pointer reversal on T --*/
+         i = s->origPtr;
+         j = GET_LL(i);
+         do {
+            Int32 tmp = GET_LL(j);
+            SET_LL(j, i);
+            i = j;
+            j = tmp;
+         }
+            while (i != s->origPtr);
+
+         s->tPos = s->origPtr;
+         s->nblock_used = 0;
+         if (s->blockRandomised) {
+            BZ_RAND_INIT_MASK;
+            BZ_GET_SMALL(s->k0); s->nblock_used++;
+            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; 
+         } else {
+            BZ_GET_SMALL(s->k0); s->nblock_used++;
+         }
+
+      } else {
+
+         /*-- compute the T^(-1) vector --*/
+         for (i = 0; i < nblock; i++) {
+            uc = (UChar)(s->tt[i] & 0xff);
+            s->tt[s->cftab[uc]] |= (i << 8);
+            s->cftab[uc]++;
+         }
+
+         s->tPos = s->tt[s->origPtr] >> 8;
+         s->nblock_used = 0;
+         if (s->blockRandomised) {
+            BZ_RAND_INIT_MASK;
+            BZ_GET_FAST(s->k0); s->nblock_used++;
+            BZ_RAND_UPD_MASK; s->k0 ^= BZ_RAND_MASK; 
+         } else {
+            BZ_GET_FAST(s->k0); s->nblock_used++;
+         }
+
+      }
+
+      RETURN(BZ_OK);
+
+
+
+    endhdr_2:
+
+      GET_UCHAR(BZ_X_ENDHDR_2, uc);
+      if (uc != 0x72) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_3, uc);
+      if (uc != 0x45) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_4, uc);
+      if (uc != 0x38) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_5, uc);
+      if (uc != 0x50) RETURN(BZ_DATA_ERROR);
+      GET_UCHAR(BZ_X_ENDHDR_6, uc);
+      if (uc != 0x90) RETURN(BZ_DATA_ERROR);
+
+      s->storedCombinedCRC = 0;
+      GET_UCHAR(BZ_X_CCRC_1, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_CCRC_2, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_CCRC_3, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+      GET_UCHAR(BZ_X_CCRC_4, uc);
+      s->storedCombinedCRC = (s->storedCombinedCRC << 8) | ((UInt32)uc);
+
+      s->state = BZ_X_IDLE;
+      RETURN(BZ_STREAM_END);
+
+      default: AssertH ( False, 4001 );   } 
+   AssertH ( False, 4002 );
+
+   save_state_and_return:
+
+   s->save_i           = i;
+   s->save_j           = j;
+   s->save_t           = t;
+   s->save_alphaSize   = alphaSize;
+   s->save_nGroups     = nGroups;
+   s->save_nSelectors  = nSelectors;
+   s->save_EOB         = EOB;
+   s->save_groupNo     = groupNo;
+   s->save_groupPos    = groupPos;
+   s->save_nextSym     = nextSym;
+   s->save_nblockMAX   = nblockMAX;
+   s->save_nblock      = nblock;
+   s->save_es          = es;
+   s->save_N           = N;
+   s->save_curr        = curr;
+   s->save_zt          = zt;
+   s->save_zn          = zn;
+   s->save_zvec        = zvec;
+   s->save_zj          = zj;
+   s->save_gSel        = gSel;
+   s->save_gMinlen     = gMinlen;
+   s->save_gLimit      = gLimit;
+   s->save_gBase       = gBase;
+   s->save_gPerm       = gPerm;
+
+   return retVal;   
+}
+
+/*---------------------------------------------------*/
+#define WEIGHTOF(zz0)  ((zz0) & 0xffffff00)
+#define DEPTHOF(zz1)   ((zz1) & 0x000000ff)
+#define MYMAX(zz2,zz3) ((zz2) > (zz3) ? (zz2) : (zz3))
+
+#define ADDWEIGHTS(zw1,zw2)                           \
+   (WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \
+   (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))
+
+#define UPHEAP(z)                                     \
+{                                                     \
+   Int32 zz, tmp;                                     \
+   zz = z; tmp = heap[zz];                            \
+   while (weight[tmp] < weight[heap[zz >> 1]]) {      \
+      heap[zz] = heap[zz >> 1];                       \
+      zz >>= 1;                                       \
+   }                                                  \
+   heap[zz] = tmp;                                    \
+}
+
+#define DOWNHEAP(z)                                   \
+{                                                     \
+   Int32 zz, yy, tmp;                                 \
+   zz = z; tmp = heap[zz];                            \
+   while (True) {                                     \
+      yy = zz << 1;                                   \
+      if (yy > nHeap) break;                          \
+      if (yy < nHeap &&                               \
+          weight[heap[yy+1]] < weight[heap[yy]])      \
+         yy++;                                        \
+      if (weight[tmp] < weight[heap[yy]]) break;      \
+      heap[zz] = heap[yy];                            \
+      zz = yy;                                        \
+   }                                                  \
+   heap[zz] = tmp;                                    \
+}
+
+/*---------------------------------------------------*/
+void BZ2_hbMakeCodeLengths ( UChar *len, 
+                             Int32 *freq,
+                             Int32 alphaSize,
+                             Int32 maxLen )
+{
+   /*--
+      Nodes and heap entries run from 1.  Entry 0
+      for both the heap and nodes is a sentinel.
+   --*/
+   Int32 nNodes, nHeap, n1, n2, i, j, k;
+   Bool  tooLong;
+
+   Int32 heap   [ BZ_MAX_ALPHA_SIZE + 2 ];
+   Int32 weight [ BZ_MAX_ALPHA_SIZE * 2 ];
+   Int32 parent [ BZ_MAX_ALPHA_SIZE * 2 ]; 
+
+   for (i = 0; i < alphaSize; i++)
+      weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
+
+   while (True) {
+
+      nNodes = alphaSize;
+      nHeap = 0;
+
+      heap[0] = 0;
+      weight[0] = 0;
+      parent[0] = -2;
+
+      for (i = 1; i <= alphaSize; i++) {
+         parent[i] = -1;
+         nHeap++;
+         heap[nHeap] = i;
+         UPHEAP(nHeap);
+      }
+
+      AssertH( nHeap < (BZ_MAX_ALPHA_SIZE+2), 2001 );
+   
+      while (nHeap > 1) {
+         n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
+         n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--; DOWNHEAP(1);
+         nNodes++;
+         parent[n1] = parent[n2] = nNodes;
+         weight[nNodes] = ADDWEIGHTS(weight[n1], weight[n2]);
+         parent[nNodes] = -1;
+         nHeap++;
+         heap[nHeap] = nNodes;
+         UPHEAP(nHeap);
+      }
+
+      AssertH( nNodes < (BZ_MAX_ALPHA_SIZE * 2), 2002 );
+
+      tooLong = False;
+      for (i = 1; i <= alphaSize; i++) {
+         j = 0;
+         k = i;
+         while (parent[k] >= 0) { k = parent[k]; j++; }
+         len[i-1] = j;
+         if (j > maxLen) tooLong = True;
+      }
+      
+      if (! tooLong) break;
+
+      for (i = 1; i < alphaSize; i++) {
+         j = weight[i] >> 8;
+         j = 1 + (j / 2);
+         weight[i] = j << 8;
+      }
+   }
+}
+
+
+/*---------------------------------------------------*/
+void BZ2_hbAssignCodes ( Int32 *code,
+                         UChar *length,
+                         Int32 minLen,
+                         Int32 maxLen,
+                         Int32 alphaSize )
+{
+   Int32 n, vec, i;
+
+   vec = 0;
+   for (n = minLen; n <= maxLen; n++) {
+      for (i = 0; i < alphaSize; i++)
+         if (length[i] == n) { code[i] = vec; vec++; };
+      vec <<= 1;
+   }
+}
+
+/* the-end. */
diff -urN linux-2.4.32/Makefile linux-2.4.32-adm5120/Makefile
--- linux-2.4.32/Makefile	2005-12-20 12:43:18.000000000 +0200
+++ linux-2.4.32-adm5120/Makefile	2005-12-20 12:50:54.000000000 +0200
@@ -36,7 +36,7 @@
 OBJDUMP		= $(CROSS_COMPILE)objdump
 MAKEFILES	= $(TOPDIR)/.config
 GENKSYMS	= /sbin/genksyms
-DEPMOD		= /sbin/depmod
+DEPMOD		= true
 MODFLAGS	= -DMODULE
 CFLAGS_KERNEL	=
 PERL		= perl
@@ -301,7 +301,11 @@
 		$(LIBS) \
 		--end-group \
 		-o vmlinux
+#	$(NM) vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > System.map
 	$(NM) vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > System.map
+	
+	$(OBJCOPY) -O binary vmlinux vmlinux.bin
+	gzip -c vmlinux.bin > vmlinuz
 
 symlinks:
 	rm -f include/asm
