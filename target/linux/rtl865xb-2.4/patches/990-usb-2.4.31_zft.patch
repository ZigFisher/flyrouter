--- linux-2.4.31/drivers/usb/Config.in.orig	2005-12-21 04:30:28.000000000 +0200
+++ linux-2.4.31/drivers/usb/Config.in	2009-08-17 11:27:09.000000000 +0300
@@ -77,6 +77,7 @@
    if [ "$CONFIG_VIDEO_DEV" = "n" ]; then
       comment '  Video4Linux support is needed for USB Multimedia device support'
    else
+      dep_tristate '  USB SPCA5XX Sunplus Vimicro Sonix Cameras' CONFIG_USB_SPCA5XX $CONFIG_USB $CONFIG_VIDEO_DEV   
       dep_tristate '  USB IBM (Xirlink) C-it Camera support' CONFIG_USB_IBMCAM $CONFIG_USB $CONFIG_VIDEO_DEV
       dep_tristate '  USB Konica Webcam support' CONFIG_USB_KONICAWC $CONFIG_USB $CONFIG_VIDEO_DEV
       dep_tristate '  USB OV511 Camera support' CONFIG_USB_OV511 $CONFIG_USB $CONFIG_VIDEO_DEV
--- linux-2.4.31/drivers/usb/Makefile.orig	2009-08-17 11:43:39.000000000 +0300
+++ linux-2.4.31/drivers/usb/Makefile	2009-08-17 11:45:49.000000000 +0300
@@ -85,6 +85,11 @@
 	obj-y += host/usb-uhci.o
 endif
 
+subdir-$(CONFIG_USB_SPCA5XX)   += spca5xx 
+ifeq ($(CONFIG_USB_SPCA5XX),y) 
+       obj-y += spca5xx/spca5xx.o 
+endif 
+
 subdir-$(CONFIG_USB_OHCI)	+= host
 ifeq ($(CONFIG_USB_OHCI),y)
 	obj-y += host/usb-ohci.o 
diff -ruN usb_old/spca5xx/cs2102.h usb/spca5xx/cs2102.h
--- linux-2.4.31/drivers/usb_old/spca5xx/cs2102.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/cs2102.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,413 @@
+ 
+#ifndef CS2102USB_H
+#define CS2102USB_H
+/****************************************************************************
+#	 	Century Semiconductor CS2102    library                     #
+# 		Copyright (C) 2004 2005 Michel Xhaard   mxhaard@magic.fr    #
+#               Copyright (C) 2005 Alvaro Salmador naplam33 at msn.com      #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 cs2102_start_data[][3]={
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x10, 0x0002},
+ { 0xa0, 0x00, 0x0010},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x20, 0x0080},
+ { 0xa0, 0x21, 0x0081},
+ { 0xa0, 0x30, 0x0083},
+ { 0xa0, 0x31, 0x0084},
+ { 0xa0, 0x32, 0x0085},
+ { 0xa0, 0x23, 0x0086},
+ { 0xa0, 0x24, 0x0087},
+ { 0xa0, 0x25, 0x0088},
+ { 0xa0, 0xb3, 0x008b},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x03, 0x0012},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0x02, 0x0092},
+ { 0xa0, 0x08, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x12, 0x0092},
+ { 0xa0, 0x89, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x13, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0xe9, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x22, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0b, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x30, 0x0092},
+ { 0xa0, 0x30, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x31, 0x0092},
+ { 0xa0, 0x30, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x32, 0x0092},
+ { 0xa0, 0x30, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x37, 0x0101},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x10, 0x01ae},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa0, 0x68, 0x018d},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x24, 0x0120},
+ { 0xa0, 0x44, 0x0121},
+ { 0xa0, 0x64, 0x0122},
+ { 0xa0, 0x84, 0x0123},
+ { 0xa0, 0x9d, 0x0124},
+ { 0xa0, 0xb2, 0x0125},
+ { 0xa0, 0xc4, 0x0126},
+ { 0xa0, 0xd3, 0x0127},
+ { 0xa0, 0xe0, 0x0128},
+ { 0xa0, 0xeb, 0x0129},
+ { 0xa0, 0xf4, 0x012a},
+ { 0xa0, 0xfb, 0x012b},
+ { 0xa0, 0xff, 0x012c},
+ { 0xa0, 0xff, 0x012d},
+ { 0xa0, 0xff, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x18, 0x0130},
+ { 0xa0, 0x20, 0x0131},
+ { 0xa0, 0x20, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0e, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x00, 0x013c},
+ { 0xa0, 0x00, 0x013d},
+ { 0xa0, 0x00, 0x013e},
+ { 0xa0, 0x01, 0x013f},
+ { 0xa0, 0x58, 0x010a},
+ { 0xa0, 0xf4, 0x010b},
+ { 0xa0, 0xf4, 0x010c},
+ { 0xa0, 0xf4, 0x010d},
+ { 0xa0, 0x58, 0x010e},
+ { 0xa0, 0xf4, 0x010f},
+ { 0xa0, 0xf4, 0x0110},
+ { 0xa0, 0xf4, 0x0111},
+ { 0xa0, 0x58, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x23, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x24, 0x0092},
+ { 0xa0, 0x55, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x25, 0x0092},
+ { 0xa0, 0xcc, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x21, 0x0092},
+ { 0xa0, 0x3f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x02, 0x0190},
+ { 0xa0, 0xab, 0x0191},
+ { 0xa0, 0x98, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x30, 0x0196},
+ { 0xa0, 0xd4, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x10, 0x01a9},
+ { 0xa0, 0x24, 0x01aa},
+ { 0xa0, 0x39, 0x001d},
+ { 0xa0, 0x70, 0x001e},
+ { 0xa0, 0xb0, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ {0,0,0}
+ };
+
+
+static __u16 cs2102_scale_data[][3]={
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x00, 0x0002},
+ { 0xa0, 0x00, 0x0010},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x20, 0x0080},
+ { 0xa0, 0x21, 0x0081},
+ { 0xa0, 0x30, 0x0083},
+ { 0xa0, 0x31, 0x0084},
+ { 0xa0, 0x32, 0x0085},
+ { 0xa0, 0x23, 0x0086},
+ { 0xa0, 0x24, 0x0087},
+ { 0xa0, 0x25, 0x0088},
+ { 0xa0, 0xb3, 0x008b},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x03, 0x0012},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0x02, 0x0092},
+ { 0xa0, 0x08, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x12, 0x0092},
+ { 0xa0, 0x87, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x13, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0xe7, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x22, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0b, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x30, 0x0092},
+ { 0xa0, 0x30, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x31, 0x0092},
+ { 0xa0, 0x30, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x32, 0x0092},
+ { 0xa0, 0x30, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x77, 0x0101},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x15, 0x01ae},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa0, 0x68, 0x018d},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x24, 0x0120},
+ { 0xa0, 0x44, 0x0121},
+ { 0xa0, 0x64, 0x0122},
+ { 0xa0, 0x84, 0x0123},
+ { 0xa0, 0x9d, 0x0124},
+ { 0xa0, 0xb2, 0x0125},
+ { 0xa0, 0xc4, 0x0126},
+ { 0xa0, 0xd3, 0x0127},
+ { 0xa0, 0xe0, 0x0128},
+ { 0xa0, 0xeb, 0x0129},
+ { 0xa0, 0xf4, 0x012a},
+ { 0xa0, 0xfb, 0x012b},
+ { 0xa0, 0xff, 0x012c},
+ { 0xa0, 0xff, 0x012d},
+ { 0xa0, 0xff, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x18, 0x0130},
+ { 0xa0, 0x20, 0x0131},
+ { 0xa0, 0x20, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0e, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x00, 0x013c},
+ { 0xa0, 0x00, 0x013d},
+ { 0xa0, 0x00, 0x013e},
+ { 0xa0, 0x01, 0x013f},
+ { 0xa0, 0x58, 0x010a},
+ { 0xa0, 0xf4, 0x010b},
+ { 0xa0, 0xf4, 0x010c},
+ { 0xa0, 0xf4, 0x010d},
+ { 0xa0, 0x58, 0x010e},
+ { 0xa0, 0xf4, 0x010f},
+ { 0xa0, 0xf4, 0x0110},
+ { 0xa0, 0xf4, 0x0111},
+ { 0xa0, 0x58, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x23, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x24, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x25, 0x0092},
+ { 0xa0, 0xe6, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x21, 0x0092},
+ { 0xa0, 0x3f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x01, 0x0190},
+ { 0xa0, 0x55, 0x0191},
+ { 0xa0, 0xcc, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x18, 0x0196},
+ { 0xa0, 0x6a, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x10, 0x01a9},
+ { 0xa0, 0x24, 0x01aa},
+ { 0xa0, 0x3f, 0x001d},
+ { 0xa0, 0xa5, 0x001e},
+ { 0xa0, 0xf0, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+  {0,0,0}
+ };
+
+#endif //CS2102USB_H
diff -ruN usb_old/spca5xx/hdcs2020.h usb/spca5xx/hdcs2020.h
--- linux-2.4.31/drivers/usb_old/spca5xx/hdcs2020.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/hdcs2020.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,897 @@
+ 
+/****************************************************************************
+#	 	Agilent HDCS2020 library                                    #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+/* play poker with registers at your own risk !! */
+static __u16 hdcs2020xx_start_data[][3]=
+{
+ { 0xA0, 0x01, 0x0000},
+ { 0xA0, 0x03, 0x0008},
+ { 0xA0, 0x0E, 0x0010},
+ { 0xA0, 0x10, 0x0002},
+ { 0xA0, 0x02, 0x0003},
+ { 0xA0, 0x80, 0x0004},
+ { 0xA0, 0x01, 0x0005},
+ { 0xA0, 0xD0, 0x0006}, //D0 ?? E0 did not start
+ { 0xA0, 0x01, 0x0001},
+ { 0xA0, 0x03, 0x0012},
+ { 0xA0, 0x01, 0x0012},
+ { 0xA0, 0x08, 0x008D},
+ { 0xA0, 0x08, 0x0098},
+ { 0xA0, 0x02, 0x009A},
+ { 0xA0, 0x08, 0x011A},
+ { 0xA0, 0x02, 0x011C},
+ { 0xA0, 0x01, 0x009B},
+ { 0xA0, 0xD8, 0x009C},
+ { 0xA0, 0x02, 0x009D},
+ { 0xA0, 0x88, 0x009E},
+ { 0xA0, 0x02, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x07, 0x0092},
+ { 0xA0, 0x06, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x08, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x09, 0x0092},
+ { 0xA0, 0x06, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0A, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0B, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0C, 0x0092},
+ { 0xA0, 0x08, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0D, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x10, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x12, 0x0092},
+ { 0xA0, 0x05, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x13, 0x0092},
+ { 0xA0, 0x63, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x15, 0x0092},
+ { 0xA0, 0x70, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x37, 0x0101},
+ { 0xA0, 0x0D, 0x0100},
+ { 0xA0, 0x06, 0x0189},
+ { 0xA0, 0x00, 0x01AD},
+ { 0xA0, 0x03, 0x01C5},
+ { 0xA0, 0x13, 0x01CB},
+ { 0xA0, 0x08, 0x0250},
+ { 0xA0, 0x08, 0x0301},
+ { 0xA0, 0x70, 0x018D},
+ { 0xA1, 0x01, 0x0002},
+ { 0xA1, 0x01, 0x0008},
+ { 0xA0, 0x03, 0x0008},
+ { 0xA0, 0x04, 0x01C6},
+ { 0xA1, 0x01, 0x01C8},
+ { 0xA1, 0x01, 0x01C9},
+ { 0xA1, 0x01, 0x01CA},
+ { 0xA0, 0x07, 0x01CB},
+ { 0xA0, 0x11, 0x0120},
+ { 0xA0, 0x37, 0x0121},
+ { 0xA0, 0x58, 0x0122},
+ { 0xA0, 0x79, 0x0123},
+ { 0xA0, 0x91, 0x0124},
+ { 0xA0, 0xA6, 0x0125},
+ { 0xA0, 0xB8, 0x0126},
+ { 0xA0, 0xC7, 0x0127},
+ { 0xA0, 0xD3, 0x0128},
+ { 0xA0, 0xDE, 0x0129},
+ { 0xA0, 0xE6, 0x012A},
+ { 0xA0, 0xED, 0x012B},
+ { 0xA0, 0xF3, 0x012C},
+ { 0xA0, 0xF8, 0x012D},
+ { 0xA0, 0xFB, 0x012E},
+ { 0xA0, 0xFF, 0x012F},
+ { 0xA0, 0x26, 0x0130},
+ { 0xA0, 0x23, 0x0131},
+ { 0xA0, 0x20, 0x0132},
+ { 0xA0, 0x1C, 0x0133},
+ { 0xA0, 0x16, 0x0134},
+ { 0xA0, 0x13, 0x0135},
+ { 0xA0, 0x10, 0x0136},
+ { 0xA0, 0x0D, 0x0137},
+ { 0xA0, 0x0B, 0x0138},
+ { 0xA0, 0x09, 0x0139},
+ { 0xA0, 0x07, 0x013A},
+ { 0xA0, 0x06, 0x013B},
+ { 0xA0, 0x05, 0x013C},
+ { 0xA0, 0x04, 0x013D},
+ { 0xA0, 0x03, 0x013E},
+ { 0xA0, 0x02, 0x013F},
+ { 0xA0, 0x4C, 0x010A},
+ { 0xA0, 0xF5, 0x010B},
+ { 0xA0, 0xFF, 0x010C},
+ { 0xA0, 0xF9, 0x010D},
+ { 0xA0, 0x51, 0x010E},
+ { 0xA0, 0xF5, 0x010F},
+ { 0xA0, 0xFB, 0x0110},
+ { 0xA0, 0xED, 0x0111},
+ { 0xA0, 0x5F, 0x0112},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x00, 0x0180},
+ { 0xA0, 0x00, 0x0019},
+ { 0xA0, 0x20, 0x0087},
+ { 0xA0, 0x21, 0x0088},
+ { 0xA0, 0x20, 0x0092},
+ { 0xA0, 0x04, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x21, 0x0092},
+ { 0xA0, 0x3D, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x03, 0x0092},
+ { 0xA0, 0x41, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x04, 0x0092},
+ { 0xA0, 0x10, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x05, 0x0092},
+ { 0xA0, 0x3D, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0E, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0F, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x14, 0x01A9},
+ { 0xA0, 0x24, 0x01AA},
+ { 0xA0, 0x00, 0x0190},
+ { 0xA0, 0x04, 0x0191},
+ { 0xA0, 0x3D, 0x0192},
+ { 0xA0, 0x00, 0x0195},
+ { 0xA0, 0x00, 0x0196},
+ { 0xA0, 0x9B, 0x0197},
+ { 0xA0, 0x10, 0x018C},
+ { 0xA0, 0x20, 0x018F},
+ { 0xA0, 0x41, 0x001D},
+ { 0xA0, 0x6F, 0x001E},
+ { 0xA0, 0xAD, 0x001F},
+ { 0xA0, 0xFF, 0x0020},
+ { 0xA0, 0x0F, 0x0087},
+ { 0xA0, 0x0E, 0x0088},
+ { 0xA0, 0x40, 0x0180},
+ { 0xA1, 0x01, 0x0195},
+ { 0xA1, 0x01, 0x0196},
+ { 0xA1, 0x01, 0x0197},
+ { 0xA0, 0x3D, 0x0192},
+ { 0xA0, 0x04, 0x0191},
+ { 0xA0, 0x00, 0x0190},
+ { 0xA0, 0x1D, 0x0116},
+ { 0xA0, 0x40, 0x0117},
+ { 0xA0, 0x85, 0x0118},
+ { 0xA1, 0x01, 0x0116},
+ { 0xA1, 0x01, 0x0118},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x42, 0x0180},
+ { 0xA0, 0x1D, 0x0116},
+ { 0xA0, 0x40, 0x0117},
+ { 0xA0, 0x85, 0x0118},
+ { 0xA1, 0x01, 0x0116},
+ { 0xA1, 0x01, 0x0118},
+ //{ 0xA0, 0x02, 0x0008},
+ { 0xA0, 0x00, 0x0007},
+ {0,0,0}
+ };
+
+static __u16 hdcs2020xx_scale_data[][3]=
+{
+ { 0xA0, 0x01, 0x0000},
+ { 0xA0, 0x03, 0x0008},
+ { 0xA0, 0x0E, 0x0010},
+ { 0xA0, 0x00, 0x0002},
+ { 0xA0, 0x02, 0x0003},
+ { 0xA0, 0x80, 0x0004},
+ { 0xA0, 0x01, 0x0005},
+ { 0xA0, 0xE0, 0x0006},
+ { 0xA0, 0x01, 0x0001},
+ { 0xA0, 0x03, 0x0012},
+ { 0xA0, 0x01, 0x0012},
+ { 0xA0, 0x08, 0x008D},
+ { 0xA0, 0x00, 0x0098},
+ { 0xA0, 0x03, 0x009A},
+ { 0xA0, 0x00, 0x011A},
+ { 0xA0, 0x03, 0x011C},
+ { 0xA0, 0x01, 0x009B},
+ { 0xA0, 0xE6, 0x009C},
+ { 0xA0, 0x02, 0x009D},
+ { 0xA0, 0x86, 0x009E},
+ { 0xA0, 0x02, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x07, 0x0092},
+ { 0xA0, 0x06, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x08, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x09, 0x0092},
+ { 0xA0, 0x06, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0A, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0B, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0C, 0x0092},
+ { 0xA0, 0x08, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0D, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x10, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x12, 0x0092},
+ { 0xA0, 0x05, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x13, 0x0092},
+ { 0xA0, 0x63, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x15, 0x0092},
+ { 0xA0, 0x70, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0xB7, 0x0101},
+ { 0xA0, 0x0D, 0x0100},
+ { 0xA0, 0x06, 0x0189},
+ { 0xA0, 0x00, 0x01AD},
+ { 0xA0, 0x03, 0x01C5},
+ { 0xA0, 0x13, 0x01CB},
+ { 0xA0, 0x08, 0x0250},
+ { 0xA0, 0x08, 0x0301},
+ { 0xA0, 0x70, 0x018D},
+ { 0xA1, 0x01, 0x0002},
+ { 0xA1, 0x01, 0x0008},
+ { 0xA0, 0x03, 0x0008},
+ { 0xA0, 0x04, 0x01C6},
+ { 0xA1, 0x01, 0x01C8},
+ { 0xA1, 0x01, 0x01C9},
+ { 0xA1, 0x01, 0x01CA},
+ { 0xA0, 0x07, 0x01CB},
+ { 0xA0, 0x11, 0x0120},
+ { 0xA0, 0x37, 0x0121},
+ { 0xA0, 0x58, 0x0122},
+ { 0xA0, 0x79, 0x0123},
+ { 0xA0, 0x91, 0x0124},
+ { 0xA0, 0xA6, 0x0125},
+ { 0xA0, 0xB8, 0x0126},
+ { 0xA0, 0xC7, 0x0127},
+ { 0xA0, 0xD3, 0x0128},
+ { 0xA0, 0xDE, 0x0129},
+ { 0xA0, 0xE6, 0x012A},
+ { 0xA0, 0xED, 0x012B},
+ { 0xA0, 0xF3, 0x012C},
+ { 0xA0, 0xF8, 0x012D},
+ { 0xA0, 0xFB, 0x012E},
+ { 0xA0, 0xFF, 0x012F},
+ { 0xA0, 0x26, 0x0130},
+ { 0xA0, 0x23, 0x0131},
+ { 0xA0, 0x20, 0x0132},
+ { 0xA0, 0x1C, 0x0133},
+ { 0xA0, 0x16, 0x0134},
+ { 0xA0, 0x13, 0x0135},
+ { 0xA0, 0x10, 0x0136},
+ { 0xA0, 0x0D, 0x0137},
+ { 0xA0, 0x0B, 0x0138},
+ { 0xA0, 0x09, 0x0139},
+ { 0xA0, 0x07, 0x013A},
+ { 0xA0, 0x06, 0x013B},
+ { 0xA0, 0x05, 0x013C},
+ { 0xA0, 0x04, 0x013D},
+ { 0xA0, 0x03, 0x013E},
+ { 0xA0, 0x02, 0x013F},
+ { 0xA0, 0x4C, 0x010A},
+ { 0xA0, 0xF5, 0x010B},
+ { 0xA0, 0xFF, 0x010C},
+ { 0xA0, 0xF9, 0x010D},
+ { 0xA0, 0x51, 0x010E},
+ { 0xA0, 0xF5, 0x010F},
+ { 0xA0, 0xFB, 0x0110},
+ { 0xA0, 0xED, 0x0111},
+ { 0xA0, 0x5F, 0x0112},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x00, 0x0180},
+ { 0xA0, 0x00, 0x0019},
+ { 0xA0, 0x20, 0x0087},
+ { 0xA0, 0x21, 0x0088},
+ { 0xA0, 0x20, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x21, 0x0092},
+ { 0xA0, 0x1B, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x03, 0x0092},
+ { 0xA0, 0x44, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x04, 0x0092},
+ { 0xA0, 0x08, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x05, 0x0092},
+ { 0xA0, 0x1B, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0E, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x0F, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x14, 0x01A9},
+ { 0xA0, 0x24, 0x01AA},
+ { 0xA0, 0x00, 0x0190},
+ { 0xA0, 0x02, 0x0191},
+ { 0xA0, 0x1B, 0x0192},
+ { 0xA0, 0x00, 0x0195},
+ { 0xA0, 0x00, 0x0196},
+ { 0xA0, 0x4D, 0x0197},
+ { 0xA0, 0x10, 0x018C},
+ { 0xA0, 0x20, 0x018F},
+ { 0xA0, 0x44, 0x001D},
+ { 0xA0, 0x6F, 0x001E},
+ { 0xA0, 0xAD, 0x001F},
+ { 0xA0, 0xEB, 0x0020},
+ { 0xA0, 0x0F, 0x0087},
+ { 0xA0, 0x0E, 0x0088},
+ { 0xA0, 0x40, 0x0180},
+ { 0xA1, 0x01, 0x0195},
+ { 0xA1, 0x01, 0x0196},
+ { 0xA1, 0x01, 0x0197},
+ { 0xA0, 0x1B, 0x0192},
+ { 0xA0, 0x02, 0x0191},
+ { 0xA0, 0x00, 0x0190},
+ { 0xA0, 0x1D, 0x0116},
+ { 0xA0, 0x40, 0x0117},
+ { 0xA0, 0x99, 0x0118},
+ { 0xA1, 0x01, 0x0116},
+ { 0xA1, 0x01, 0x0118},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x42, 0x0180},
+ { 0xA0, 0x1D, 0x0116},
+ { 0xA0, 0x40, 0x0117},
+ { 0xA0, 0x99, 0x0118}, 
+// { 0xA0, 0x02, 0x0008},
+ { 0xA0, 0x00, 0x0007},
+ //{ 0xA0, 0x18, 0x00FE},
+ {0,0,0}
+ };
+static __u16 hdcs2020xb_start_data[][3]=
+{
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x11, 0x0002},
+ { 0xa0, 0x03, 0x0008}, // qtable 0x05
+ { 0xa0, 0x08, 0x0010},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x03, 0x0012},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0xe8, 0x009c},
+ { 0xa0, 0x88, 0x009e},
+ { 0xa0, 0x1c, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0a, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0b, 0x0092},
+ { 0xa0, 0x06, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0c, 0x0092},
+ { 0xa0, 0x7b, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0d, 0x0092},
+ { 0xa0, 0xa7, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0xfb, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x09, 0x0092},
+ { 0xa0, 0x08, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+
+ { 0xa0, 0x0f, 0x0092}, // set sensor gain
+ { 0xa0, 0x18, 0x0093}, //0x18
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x18, 0x0093}, //0x18
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x18, 0x0093}, //0x18
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x12, 0x0092},
+ { 0xa0, 0x18, 0x0093}, //0x18
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+
+ { 0xa0, 0x15, 0x0092},
+ { 0xa0, 0x4e, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x1c, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0xb7, 0x0101},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x70, 0x018d},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x02, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},//
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x13, 0x0120},
+ { 0xa0, 0x38, 0x0121},
+ { 0xa0, 0x59, 0x0122},
+ { 0xa0, 0x79, 0x0123},
+ { 0xa0, 0x92, 0x0124},
+ { 0xa0, 0xa7, 0x0125},
+ { 0xa0, 0xb9, 0x0126},
+ { 0xa0, 0xc8, 0x0127},
+ { 0xa0, 0xd4, 0x0128},
+ { 0xa0, 0xdf, 0x0129},
+ { 0xa0, 0xe7, 0x012a},
+ { 0xa0, 0xee, 0x012b},
+ { 0xa0, 0xf4, 0x012c},
+ { 0xa0, 0xf9, 0x012d},
+ { 0xa0, 0xfc, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x26, 0x0130},
+ { 0xa0, 0x22, 0x0131},
+ { 0xa0, 0x20, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0d, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x05, 0x013c},
+ { 0xa0, 0x04, 0x013d},
+ { 0xa0, 0x03, 0x013e},
+ { 0xa0, 0x02, 0x013f},
+ /********************/
+ { 0xa0, 0x66, 0x010a},//66
+ { 0xa0, 0xed, 0x010b},//ed
+ { 0xa0, 0xed, 0x010c},//ed
+ { 0xa0, 0xed, 0x010d},//ed
+ { 0xa0, 0x66, 0x010e},//66
+ { 0xa0, 0xed, 0x010f},//ed
+ { 0xa0, 0xed, 0x0110},//ed
+ { 0xa0, 0xed, 0x0111},//ed
+ { 0xa0, 0x66, 0x0112},//66
+ 
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x13, 0x0092},
+ { 0xa0, 0x31, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0e, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x19, 0x0092},
+ { 0xa0, 0xcd, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x02, 0x0191},
+ { 0xa0, 0x62, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x3d, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ /********************/
+ { 0xa0, 0x0c, 0x01a9},//0x14
+ { 0xa0, 0x28, 0x01aa},
+ /********************/
+ { 0xa0, 0x04, 0x001d},
+ { 0xa0, 0x18, 0x001e},
+ { 0xa0, 0x2c, 0x001f},
+ { 0xa0, 0x41, 0x0020},
+ { 0xa0, 0x60, 0x011d},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ {0,0,0}
+ };
+static __u16 hdcs2020xb_scale_data[][3]={
+{ 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x00, 0x0002},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x0010},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x03, 0x0012},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0xe8, 0x009c},
+ { 0xa0, 0x88, 0x009e},
+ { 0xa0, 0x1c, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0a, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0b, 0x0092},
+ { 0xa0, 0x06, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0c, 0x0092},
+ { 0xa0, 0x7a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0d, 0x0092},
+ { 0xa0, 0xa7, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0xfb, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x09, 0x0092},
+ { 0xa0, 0x08, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ #if 0
+ { 0xa0, 0x0f, 0x0092}, // set sensor gain
+ { 0xa0, 0x4f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x4f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x4f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x12, 0x0092},
+ { 0xa0, 0x4f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ #endif
+ { 0xa0, 0x0f, 0x0092}, // original setting
+ { 0xa0, 0x18, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x18, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x18, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x12, 0x0092},
+ { 0xa0, 0x18, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+/**********************/
+ { 0xa0, 0x15, 0x0092},
+ { 0xa0, 0x4e, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x1c, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0xf7, 0x0101},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x70, 0x018d},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x02, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x13, 0x0120},
+ { 0xa0, 0x38, 0x0121},
+ { 0xa0, 0x59, 0x0122},
+ { 0xa0, 0x79, 0x0123},
+ { 0xa0, 0x92, 0x0124},
+ { 0xa0, 0xa7, 0x0125},
+ { 0xa0, 0xb9, 0x0126},
+ { 0xa0, 0xc8, 0x0127},
+ { 0xa0, 0xd4, 0x0128},
+ { 0xa0, 0xdf, 0x0129},
+ { 0xa0, 0xe7, 0x012a},
+ { 0xa0, 0xee, 0x012b},
+ { 0xa0, 0xf4, 0x012c},
+ { 0xa0, 0xf9, 0x012d},
+ { 0xa0, 0xfc, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x26, 0x0130},
+ { 0xa0, 0x22, 0x0131},
+ { 0xa0, 0x20, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0d, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x05, 0x013c},
+ { 0xa0, 0x04, 0x013d},
+ { 0xa0, 0x03, 0x013e},
+ { 0xa0, 0x02, 0x013f},
+ { 0xa0, 0x66, 0x010a},
+ { 0xa0, 0xed, 0x010b},
+ { 0xa0, 0xed, 0x010c},
+ { 0xa0, 0xed, 0x010d},
+ { 0xa0, 0x66, 0x010e},
+ { 0xa0, 0xed, 0x010f},
+ { 0xa0, 0xed, 0x0110},
+ { 0xa0, 0xed, 0x0111},
+ { 0xa0, 0x66, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ /**** set exposure ***/
+ { 0xa0, 0x13, 0x0092},
+ { 0xa0, 0x31, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0e, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x19, 0x0092},
+ { 0xa0, 0xcd, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x02, 0x0191},
+ { 0xa0, 0x62, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x3d, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x0c, 0x01a9},
+ { 0xa0, 0x28, 0x01aa},
+ { 0xa0, 0x04, 0x001d},
+ { 0xa0, 0x18, 0x001e},
+ { 0xa0, 0x2c, 0x001f},
+ { 0xa0, 0x41, 0x0020},
+ { 0xa0, 0x60, 0x011d},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ {0,0,0}
+ };
diff -ruN usb_old/spca5xx/hv7131b.h usb/spca5xx/hv7131b.h
--- linux-2.4.31/drivers/usb_old/spca5xx/hv7131b.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/hv7131b.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,458 @@
+ 
+/****************************************************************************
+#	 	Hynix HV7131b library                                       #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 hv7131bxx_start_data[][3]={
+ { 0xA0, 0x01, 0x0000},
+ { 0xA0, 0x10, 0x0002},
+ { 0xA0, 0x00, 0x0010},
+ { 0xA0, 0x01, 0x0001},
+ { 0xA0, 0x77, 0x0101},
+ { 0xA0, 0x03, 0x0008},//00
+ { 0xA0, 0x03, 0x0012},
+ { 0xA0, 0x01, 0x0012},
+ { 0xA0, 0x02, 0x0003},
+ { 0xA0, 0x80, 0x0004},
+ { 0xA0, 0x01, 0x0005},
+ { 0xA0, 0xE0, 0x0006},
+ { 0xA0, 0x00, 0x0098},
+ { 0xA0, 0x00, 0x009A},
+ { 0xA0, 0x00, 0x011A},
+ { 0xA0, 0x00, 0x011C},
+	 { 0xA0, 0x30, 0x0092},
+ { 0xA0, 0x2D, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x01, 0x0092},
+ { 0xA0, 0x05, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x11, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ 	{ 0xA0, 0x13, 0x0092},
+// { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x14, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x15, 0x0092},
+ { 0xA0, 0xE8, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x16, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x17, 0x0092},
+ { 0xA0, 0x86, 0x0093},//88
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x31, 0x0092},
+ { 0xA0, 0x38, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x32, 0x0092},
+ { 0xA0, 0x38, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x33, 0x0092},
+ { 0xA0, 0x38, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x5B, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x00, 0x0019},
+ { 0xA0, 0x05, 0x0012},
+ { 0xA0, 0x0D, 0x0100},
+ { 0xA0, 0x68, 0x018D},
+ { 0xA0, 0x60, 0x01A8},
+ { 0xA0, 0x00, 0x01AD},
+ { 0xA0, 0xC0, 0x019B},
+ { 0xA0, 0xA0, 0x019C},
+ { 0xA0, 0x02, 0x0188},
+ { 0xA0, 0x06, 0x0189},
+ { 0xA0, 0x03, 0x01C5},
+ { 0xA0, 0x13, 0x01CB},
+ { 0xA0, 0x08, 0x0250},
+ { 0xA0, 0x08, 0x0301},
+	 { 0xA0, 0x02, 0x0092},
+// { 0xA0, 0x80, 0x0093},
+{ 0xA0, 0x90, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA1, 0x01, 0x0002},
+	 { 0xA0, 0x00, 0x0092},
+ { 0xA0, 0x02, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA1, 0x01, 0x0095},
+ { 0xA1, 0x01, 0x0096},
+ { 0xA1, 0x01, 0x0008},
+ { 0xA0, 0x03, 0x0008},//00
+ { 0xA0, 0x08, 0x01C6},
+ { 0xA1, 0x01, 0x01C8},
+ { 0xA1, 0x01, 0x01C9},
+ { 0xA1, 0x01, 0x01CA},
+ { 0xA0, 0x0F, 0x01CB},
+ { 0xA0, 0x13, 0x0120},
+ { 0xA0, 0x38, 0x0121},
+ { 0xA0, 0x59, 0x0122},
+ { 0xA0, 0x79, 0x0123},
+ { 0xA0, 0x92, 0x0124},
+ { 0xA0, 0xA7, 0x0125},
+ { 0xA0, 0xB9, 0x0126},
+ { 0xA0, 0xC8, 0x0127},
+ { 0xA0, 0xD4, 0x0128},
+ { 0xA0, 0xDF, 0x0129},
+ { 0xA0, 0xE7, 0x012A},
+ { 0xA0, 0xEE, 0x012B},
+ { 0xA0, 0xF4, 0x012C},
+ { 0xA0, 0xF9, 0x012D},
+ { 0xA0, 0xFC, 0x012E},
+ { 0xA0, 0xFF, 0x012F},
+ { 0xA0, 0x26, 0x0130},
+ { 0xA0, 0x22, 0x0131},
+ { 0xA0, 0x20, 0x0132},
+ { 0xA0, 0x1C, 0x0133},
+ { 0xA0, 0x16, 0x0134},
+ { 0xA0, 0x13, 0x0135},
+ { 0xA0, 0x10, 0x0136},
+ { 0xA0, 0x0D, 0x0137},
+ { 0xA0, 0x0B, 0x0138},
+ { 0xA0, 0x09, 0x0139},
+ { 0xA0, 0x07, 0x013A},
+ { 0xA0, 0x06, 0x013B},
+ { 0xA0, 0x05, 0x013C},
+ { 0xA0, 0x04, 0x013D},
+ { 0xA0, 0x03, 0x013E},
+ { 0xA0, 0x02, 0x013F},
+ { 0xA0, 0x50, 0x010A},
+ { 0xA0, 0xF8, 0x010B},
+ { 0xA0, 0xF8, 0x010C},
+ { 0xA0, 0xF8, 0x010D},
+ { 0xA0, 0x50, 0x010E},
+ { 0xA0, 0xF8, 0x010F},
+ { 0xA0, 0xF8, 0x0110},
+ { 0xA0, 0xF8, 0x0111},
+ { 0xA0, 0x50, 0x0112},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x10, 0x0180},
+ { 0xA0, 0x00, 0x0019},
+	 { 0xA0, 0x25, 0x0092},
+ { 0xA0, 0x07, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x26, 0x0092},
+ { 0xA0, 0xA1, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x27, 0x0092},
+ { 0xA0, 0x20, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x20, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x21, 0x0092},
+ { 0xA0, 0xA0, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x22, 0x0092},
+ { 0xA0, 0x16, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x23, 0x0092},
+ { 0xA0, 0x40, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x2F, 0x0190},
+ { 0xA0, 0x4D, 0x0191},
+ { 0xA0, 0x60, 0x0192},
+ { 0xA0, 0x01, 0x0195},
+ { 0xA0, 0x86, 0x0196},
+ { 0xA0, 0xA0, 0x0197},
+ { 0xA0, 0x07, 0x018C},
+ { 0xA0, 0x0F, 0x018F},
+ { 0xA0, 0x18, 0x01A9},
+ { 0xA0, 0x24, 0x01AA},
+ { 0xA0, 0x00, 0x001D},
+ { 0xA0, 0xA0, 0x001E},
+ { 0xA0, 0x16, 0x001F},
+ { 0xA0, 0x40, 0x0020},
+ { 0xA0, 0x60, 0x011D},
+ { 0xA1, 0x01, 0x001D},
+ { 0xA1, 0x01, 0x001E},
+ { 0xA1, 0x01, 0x001F},
+ { 0xA1, 0x01, 0x0020},
+ { 0xA0, 0x40, 0x0180},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x42, 0x0180},
+ { 0xA0, 0x40, 0x0116},
+ { 0xA0, 0x40, 0x0117},
+ { 0xA0, 0x40, 0x0118},  
+// { 0xA0, 0x02, 0x0008},
+ {0,0,0}
+ };
+ 
+static __u16 hv7131bxx_scale_data[][3]= {
+ { 0xA0, 0x01, 0x0000},
+ { 0xA0, 0x00, 0x0002},
+ { 0xA0, 0x00, 0x0010},
+ { 0xA0, 0x01, 0x0001},
+ { 0xA0, 0x37, 0x0101},
+ { 0xA0, 0x03, 0x0008},//00
+ { 0xA0, 0x03, 0x0012},
+ { 0xA0, 0x01, 0x0012},
+ { 0xA0, 0x02, 0x0003},
+ { 0xA0, 0x80, 0x0004},
+ { 0xA0, 0x01, 0x0005},
+ { 0xA0, 0xE0, 0x0006},
+ { 0xA0, 0x00, 0x0098},
+ { 0xA0, 0x00, 0x009A},
+ { 0xA0, 0x00, 0x011A},
+ { 0xA0, 0x00, 0x011C},
+	 { 0xA0, 0x30, 0x0092},
+ { 0xA0, 0x2D, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x01, 0x0092},
+ { 0xA0, 0x05, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x11, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x13, 0x0092},
+ //{ 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x14, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x15, 0x0092},
+ { 0xA0, 0xE6, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x16, 0x0092},
+ { 0xA0, 0x02, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x17, 0x0092},
+ { 0xA0, 0x86, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x31, 0x0092},
+ { 0xA0, 0x38, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x32, 0x0092},
+ { 0xA0, 0x38, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x33, 0x0092},
+ { 0xA0, 0x38, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+	 { 0xA0, 0x5B, 0x0092},
+ { 0xA0, 0x01, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x00, 0x0019},
+ { 0xA0, 0x05, 0x0012},
+ { 0xA0, 0x0D, 0x0100},
+ { 0xA0, 0x70, 0x018D},
+ { 0xA0, 0x60, 0x01A8},
+ { 0xA0, 0x00, 0x01AD},
+ { 0xA0, 0xC0, 0x019B},
+ { 0xA0, 0xA0, 0x019C},
+ { 0xA0, 0x02, 0x0188},
+ { 0xA0, 0x06, 0x0189},
+ { 0xA0, 0x03, 0x01C5},
+ { 0xA0, 0x13, 0x01CB},
+ { 0xA0, 0x08, 0x0250},
+ { 0xA0, 0x08, 0x0301},
+ { 0xA0, 0x02, 0x0092},
+// { 0xA0, 0x80, 0x0093},
+{ 0xA0, 0x90, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA1, 0x01, 0x0002},
+ { 0xA0, 0x00, 0x0092},
+ { 0xA0, 0x02, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA1, 0x01, 0x0095},
+ { 0xA1, 0x01, 0x0096},
+ { 0xA1, 0x01, 0x0008},
+ { 0xA0, 0x03, 0x0008},//00
+ { 0xA0, 0x08, 0x01C6},
+ { 0xA1, 0x01, 0x01C8},
+ { 0xA1, 0x01, 0x01C9},
+ { 0xA1, 0x01, 0x01CA},
+ { 0xA0, 0x0F, 0x01CB},
+ { 0xA0, 0x13, 0x0120},
+ { 0xA0, 0x38, 0x0121},
+ { 0xA0, 0x59, 0x0122},
+ { 0xA0, 0x79, 0x0123},
+ { 0xA0, 0x92, 0x0124},
+ { 0xA0, 0xA7, 0x0125},
+ { 0xA0, 0xB9, 0x0126},
+ { 0xA0, 0xC8, 0x0127},
+ { 0xA0, 0xD4, 0x0128},
+ { 0xA0, 0xDF, 0x0129},
+ { 0xA0, 0xE7, 0x012A},
+ { 0xA0, 0xEE, 0x012B},
+ { 0xA0, 0xF4, 0x012C},
+ { 0xA0, 0xF9, 0x012D},
+ { 0xA0, 0xFC, 0x012E},
+ { 0xA0, 0xFF, 0x012F},
+ { 0xA0, 0x26, 0x0130},
+ { 0xA0, 0x22, 0x0131},
+ { 0xA0, 0x20, 0x0132},
+ { 0xA0, 0x1C, 0x0133},
+ { 0xA0, 0x16, 0x0134},
+ { 0xA0, 0x13, 0x0135},
+ { 0xA0, 0x10, 0x0136},
+ { 0xA0, 0x0D, 0x0137},
+ { 0xA0, 0x0B, 0x0138},
+ { 0xA0, 0x09, 0x0139},
+ { 0xA0, 0x07, 0x013A},
+ { 0xA0, 0x06, 0x013B},
+ { 0xA0, 0x05, 0x013C},
+ { 0xA0, 0x04, 0x013D},
+ { 0xA0, 0x03, 0x013E},
+ { 0xA0, 0x02, 0x013F},
+ { 0xA0, 0x50, 0x010A},
+ { 0xA0, 0xF8, 0x010B},
+ { 0xA0, 0xF8, 0x010C},
+ { 0xA0, 0xF8, 0x010D},
+ { 0xA0, 0x50, 0x010E},
+ { 0xA0, 0xF8, 0x010F},
+ { 0xA0, 0xF8, 0x0110},
+ { 0xA0, 0xF8, 0x0111},
+ { 0xA0, 0x50, 0x0112},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x10, 0x0180},
+ { 0xA0, 0x00, 0x0019},
+ { 0xA0, 0x25, 0x0092},
+ { 0xA0, 0x07, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x26, 0x0092},
+ { 0xA0, 0xA1, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x27, 0x0092},
+ { 0xA0, 0x20, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x20, 0x0092},
+ { 0xA0, 0x00, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x21, 0x0092},
+ { 0xA0, 0x40, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x22, 0x0092},
+ { 0xA0, 0x13, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x23, 0x0092},
+ { 0xA0, 0x4C, 0x0093},
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091},
+ { 0xA0, 0x2F, 0x0190},
+ { 0xA0, 0x4D, 0x0191},
+ { 0xA0, 0x60, 0x0192},
+ { 0xA0, 0x00, 0x0195},
+ { 0xA0, 0xC3, 0x0196},
+ { 0xA0, 0x50, 0x0197},
+ { 0xA0, 0x0C, 0x018C},
+ { 0xA0, 0x18, 0x018F},
+ { 0xA0, 0x18, 0x01A9},
+ { 0xA0, 0x24, 0x01AA},
+ { 0xA0, 0x00, 0x001D},
+ { 0xA0, 0x40, 0x001E},
+ { 0xA0, 0x13, 0x001F},
+ { 0xA0, 0x4C, 0x0020},
+ { 0xA0, 0x60, 0x011D},
+ { 0xA1, 0x01, 0x001D},
+ { 0xA1, 0x01, 0x001E},
+ { 0xA1, 0x01, 0x001F},
+ { 0xA1, 0x01, 0x0020},
+ { 0xA0, 0x40, 0x0180},
+ { 0xA1, 0x01, 0x0180},
+ { 0xA0, 0x42, 0x0180},
+ { 0xA0, 0x40, 0x0116},
+ { 0xA0, 0x40, 0x0117},
+ { 0xA0, 0x40, 0x0118},
+// { 0xA0, 0x02, 0x0008},
+ {0,0,0}
+ };
diff -ruN usb_old/spca5xx/hv7131c.h usb/spca5xx/hv7131c.h
--- linux-2.4.31/drivers/usb_old/spca5xx/hv7131c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/hv7131c.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,343 @@
+  
+/****************************************************************************
+#	 	Hynix HV7131b library                                       #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static __u16 hv7131cxx_start_data[][3]={
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x10, 0x0002},
+ { 0xa0, 0x01, 0x0010},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x77, 0x0101},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x07, 0x0012},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x01, 0x009b},
+ { 0xa0, 0xe8, 0x009c},
+ { 0xa0, 0x02, 0x009d},
+ { 0xa0, 0x88, 0x009e},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0x05, 0x0012},
+ 	{ 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x0c, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x13, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x15, 0x0092},
+ { 0xa0, 0xe8, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x16, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x17, 0x0092},
+ { 0xa0, 0x88, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x89, 0x018d},
+ { 0xa0, 0x50, 0x01a8},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa0, 0xc0, 0x019b},
+ { 0xa0, 0xa0, 0x019c},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa1, 0x01, 0x0002},
+	 { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x02, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa1, 0x01, 0x0095},
+ { 0xa1, 0x01, 0x0096},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x04, 0x0120},
+ { 0xa0, 0x16, 0x0121},
+ { 0xa0, 0x30, 0x0122},
+ { 0xa0, 0x4e, 0x0123},
+ { 0xa0, 0x68, 0x0124},
+ { 0xa0, 0x81, 0x0125},
+ { 0xa0, 0x98, 0x0126},
+ { 0xa0, 0xac, 0x0127},
+ { 0xa0, 0xbe, 0x0128},
+ { 0xa0, 0xcd, 0x0129},
+ { 0xa0, 0xda, 0x012a},
+ { 0xa0, 0xe4, 0x012b},
+ { 0xa0, 0xed, 0x012c},
+ { 0xa0, 0xf5, 0x012d},
+ { 0xa0, 0xfb, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x0c, 0x0130},
+ { 0xa0, 0x16, 0x0131},
+ { 0xa0, 0x1b, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x19, 0x0134},
+ { 0xa0, 0x18, 0x0135},
+ { 0xa0, 0x15, 0x0136},
+ { 0xa0, 0x12, 0x0137},
+ { 0xa0, 0x10, 0x0138},
+ { 0xa0, 0x0d, 0x0139},
+ { 0xa0, 0x0b, 0x013a},
+ { 0xa0, 0x09, 0x013b},
+ { 0xa0, 0x08, 0x013c},
+ { 0xa0, 0x06, 0x013d},
+ { 0xa0, 0x05, 0x013e},
+ { 0xa0, 0x03, 0x013f},
+ { 0xa0, 0x60, 0x010a},
+ { 0xa0, 0xf0, 0x010b},
+ { 0xa0, 0xf0, 0x010c},
+ { 0xa0, 0xf0, 0x010d},
+ { 0xa0, 0x60, 0x010e},
+ { 0xa0, 0xf0, 0x010f},
+ { 0xa0, 0xf0, 0x0110},
+ { 0xa0, 0xf0, 0x0111},
+ { 0xa0, 0x60, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x10, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+	 { 0xa0, 0x25, 0x0092},
+ { 0xa0, 0x07, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x26, 0x0092},
+ { 0xa0, 0x53, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x27, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x2f, 0x0190},
+ { 0xa0, 0x9b, 0x0191},
+ { 0xa0, 0x80, 0x0192},
+ { 0xa0, 0x01, 0x0195},
+ { 0xa0, 0xd4, 0x0196},
+ { 0xa0, 0xc0, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x60, 0x01a8},
+ { 0xa0, 0x10, 0x01a9},
+ { 0xa0, 0x13, 0x01aa},
+ { 0xa1, 0x01, 0x001d},
+ { 0xa1, 0x01, 0x001e},
+ { 0xa1, 0x01, 0x001f},
+ { 0xa1, 0x01, 0x0020},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ {0,0,0}
+ };
+ 
+static __u16 hv7131cxx_scale_data[][3]= {
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x00, 0x0002}, //diff 
+ { 0xa0, 0x01, 0x0010},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x77, 0x0101},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x07, 0x0012},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x01, 0x009b},
+ { 0xa0, 0xe8, 0x009c},
+ { 0xa0, 0x02, 0x009d},
+ { 0xa0, 0x88, 0x009e},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x0c, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x11, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x13, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x15, 0x0092},
+ { 0xa0, 0xe8, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x16, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x17, 0x0092},
+ { 0xa0, 0x88, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x89, 0x018d},
+ { 0xa0, 0x50, 0x01a8},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa0, 0xc0, 0x019b},
+ { 0xa0, 0xa0, 0x019c},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x02, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa1, 0x01, 0x0095},
+ { 0xa1, 0x01, 0x0096},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x04, 0x0120},
+ { 0xa0, 0x16, 0x0121},
+ { 0xa0, 0x30, 0x0122},
+ { 0xa0, 0x4e, 0x0123},
+ { 0xa0, 0x68, 0x0124},
+ { 0xa0, 0x81, 0x0125},
+ { 0xa0, 0x98, 0x0126},
+ { 0xa0, 0xac, 0x0127},
+ { 0xa0, 0xbe, 0x0128},
+ { 0xa0, 0xcd, 0x0129},
+ { 0xa0, 0xda, 0x012a},
+ { 0xa0, 0xe4, 0x012b},
+ { 0xa0, 0xed, 0x012c},
+ { 0xa0, 0xf5, 0x012d},
+ { 0xa0, 0xfb, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x0c, 0x0130},
+ { 0xa0, 0x16, 0x0131},
+ { 0xa0, 0x1b, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x19, 0x0134},
+ { 0xa0, 0x18, 0x0135},
+ { 0xa0, 0x15, 0x0136},
+ { 0xa0, 0x12, 0x0137},
+ { 0xa0, 0x10, 0x0138},
+ { 0xa0, 0x0d, 0x0139},
+ { 0xa0, 0x0b, 0x013a},
+ { 0xa0, 0x09, 0x013b},
+ { 0xa0, 0x08, 0x013c},
+ { 0xa0, 0x06, 0x013d},
+ { 0xa0, 0x05, 0x013e},
+ { 0xa0, 0x03, 0x013f},
+ { 0xa0, 0x60, 0x010a},
+ { 0xa0, 0xf0, 0x010b},
+ { 0xa0, 0xf0, 0x010c},
+ { 0xa0, 0xf0, 0x010d},
+ { 0xa0, 0x60, 0x010e},
+ { 0xa0, 0xf0, 0x010f},
+ { 0xa0, 0xf0, 0x0110},
+ { 0xa0, 0xf0, 0x0111},
+ { 0xa0, 0x60, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x10, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x25, 0x0092},
+ { 0xa0, 0x07, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x26, 0x0092},
+ { 0xa0, 0x53, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x27, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x2f, 0x0190},
+ { 0xa0, 0x9b, 0x0191},
+ { 0xa0, 0x80, 0x0192},
+ { 0xa0, 0x01, 0x0195},
+ { 0xa0, 0xd4, 0x0196},
+ { 0xa0, 0xc0, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x60, 0x01a8},
+ { 0xa0, 0x10, 0x01a9},
+ { 0xa0, 0x13, 0x01aa},
+ { 0xa1, 0x01, 0x001d},
+ { 0xa1, 0x01, 0x001e},
+ { 0xa1, 0x01, 0x001f},
+ { 0xa1, 0x01, 0x0020},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ {0,0,0}
+ };
diff -ruN usb_old/spca5xx/icm105a.h usb/spca5xx/icm105a.h
--- linux-2.4.31/drivers/usb_old/spca5xx/icm105a.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/icm105a.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,1170 @@
+/****************************************************************************
+#	 	Ic-media ICM105A library                                    #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+
+ static __u16 icm105axx_start_data[][3]= {
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x10, 0x0002},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x0c, 0x0010},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x03, 0x0012},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0xa1, 0x008b},
+ { 0xa0, 0x00, 0x0097},
+ { 0xa0, 0x01, 0x0098},
+ { 0xa0, 0x00, 0x0099},
+ { 0xa0, 0x01, 0x009a},
+ { 0xa0, 0x01, 0x011a},
+ { 0xa0, 0x01, 0x011c},
+ { 0xa0, 0x01, 0x009b},
+ { 0xa0, 0xe8, 0x009c},
+ { 0xa0, 0x02, 0x009d},
+ { 0xa0, 0x88, 0x009e},
+ { 0xa0, 0x37, 0x0101},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x10, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x11, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xa0, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x13, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x15, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x17, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x19, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x06, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x17, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x26, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x07, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x19, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x22, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x08, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x21, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x09, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x23, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x0a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x25, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x0b, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0xec, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x2e, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x0c, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0xfa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x2a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x07, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x94, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x90, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x91, 0x0092},
+ { 0xa0, 0x1f, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x64, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x9b, 0x0092},
+ { 0xa0, 0xf0, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x9c, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x14, 0x0092},
+ { 0xa0, 0x1a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x22, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x24, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x26, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x84, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa0, 0xa8, 0x0092},
+ { 0xa0, 0xc0, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x02, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x1c, 0x0120},
+ { 0xa0, 0x3d, 0x0121},
+ { 0xa0, 0x5d, 0x0122},
+ { 0xa0, 0x7d, 0x0123},
+ { 0xa0, 0x94, 0x0124},
+ { 0xa0, 0xa9, 0x0125},
+ { 0xa0, 0xbb, 0x0126},
+ { 0xa0, 0xca, 0x0127},
+ { 0xa0, 0xd6, 0x0128},
+ { 0xa0, 0xe0, 0x0129},
+ { 0xa0, 0xe9, 0x012a},
+ { 0xa0, 0xf0, 0x012b},
+ { 0xa0, 0xf6, 0x012c},
+ { 0xa0, 0xfa, 0x012d},
+ { 0xa0, 0xfe, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x1b, 0x0130},
+ { 0xa0, 0x20, 0x0131},
+ { 0xa0, 0x1f, 0x0132},
+ { 0xa0, 0x1b, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0d, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x05, 0x013c},
+ { 0xa0, 0x04, 0x013d},
+ { 0xa0, 0x02, 0x013e},
+ { 0xa0, 0x01, 0x013f},
+ { 0xa0, 0x52, 0x010a},
+ { 0xa0, 0xf7, 0x010b},
+ { 0xa0, 0xf7, 0x010c},
+ { 0xa0, 0xf7, 0x010d},
+ { 0xa0, 0x52, 0x010e},
+ { 0xa0, 0xf7, 0x010f},
+ { 0xa0, 0xf7, 0x0110},
+ { 0xa0, 0xf7, 0x0111},
+ { 0xa0, 0x52, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x0d, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0c, 0x0092},
+ { 0xa0, 0x8c, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0e, 0x0092},
+ { 0xa0, 0x95, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0f, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x1c, 0x0092},
+ { 0xa0, 0x94, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x1d, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x22, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x24, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x26, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x84, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x02, 0x00a3},
+ { 0xa0, 0x94, 0x00a4},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x04, 0x0191},
+ { 0xa0, 0x20, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x84, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x10, 0x01a9},
+ { 0xa0, 0x12, 0x01aa},
+ { 0xa0, 0xe3, 0x001d},
+ { 0xa0, 0xec, 0x001e},
+ { 0xa0, 0xf5, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x00, 0x01a7},
+ { 0xa0, 0xc0, 0x01a8},
+ { 0xa0, 0xc0, 0x011d},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ {0,0,0},
+ };
+ 
+static __u16 icm105axx_scale_data[][3]= { 
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x00, 0x0002},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x0c, 0x0010},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x03, 0x0012},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0xa1, 0x008b},
+ { 0xa0, 0x00, 0x0097},
+ { 0xa0, 0x02, 0x0098},
+ { 0xa0, 0x00, 0x0099},
+ { 0xa0, 0x02, 0x009a},
+ { 0xa0, 0x02, 0x011a},
+ { 0xa0, 0x02, 0x011c},
+ { 0xa0, 0x01, 0x009b},
+ { 0xa0, 0xe6, 0x009c},
+ { 0xa0, 0x02, 0x009d},
+ { 0xa0, 0x86, 0x009e},
+ { 0xa0, 0x77, 0x0101},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ 	{ 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x10, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x11, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xa0, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x13, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x15, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x04, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x17, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x19, 0x0093},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x06, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x17, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x26, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x07, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x19, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x22, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x08, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x21, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x09, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x23, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x0a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x25, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0xaa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x0b, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0xec, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x2e, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x03, 0x0092},
+ { 0xa0, 0x0c, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x04, 0x0092},
+ { 0xa0, 0xfa, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x2a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x08, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x07, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x94, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x90, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x91, 0x0092},
+ { 0xa0, 0x10, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x64, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x9b, 0x0092},
+ { 0xa0, 0xf0, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x9c, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x14, 0x0092},
+ { 0xa0, 0x1a, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+	 { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x22, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x24, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x26, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ 	{ 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x84, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa0, 0xa8, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x78, 0x018d},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x02, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x1c, 0x0120},
+ { 0xa0, 0x3d, 0x0121},
+ { 0xa0, 0x5d, 0x0122},
+ { 0xa0, 0x7d, 0x0123},
+ { 0xa0, 0x94, 0x0124},
+ { 0xa0, 0xa9, 0x0125},
+ { 0xa0, 0xbb, 0x0126},
+ { 0xa0, 0xca, 0x0127},
+ { 0xa0, 0xd6, 0x0128},
+ { 0xa0, 0xe0, 0x0129},
+ { 0xa0, 0xe9, 0x012a},
+ { 0xa0, 0xf0, 0x012b},
+ { 0xa0, 0xf6, 0x012c},
+ { 0xa0, 0xfa, 0x012d},
+ { 0xa0, 0xfe, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x1b, 0x0130},
+ { 0xa0, 0x20, 0x0131},
+ { 0xa0, 0x1f, 0x0132},
+ { 0xa0, 0x1b, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0d, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x05, 0x013c},
+ { 0xa0, 0x04, 0x013d},
+ { 0xa0, 0x02, 0x013e},
+ { 0xa0, 0x01, 0x013f},
+ { 0xa0, 0x52, 0x010a},
+ { 0xa0, 0xf7, 0x010b},
+ { 0xa0, 0xf7, 0x010c},
+ { 0xa0, 0xf7, 0x010d},
+ { 0xa0, 0x52, 0x010e},
+ { 0xa0, 0xf7, 0x010f},
+ { 0xa0, 0xf7, 0x0110},
+ { 0xa0, 0xf7, 0x0111},
+ { 0xa0, 0x52, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x0d, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0c, 0x0092},
+ { 0xa0, 0x20, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0e, 0x0092},
+ { 0xa0, 0x0e, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x0f, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x1c, 0x0092},
+ { 0xa0, 0x0d, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x1d, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x22, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x24, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x26, 0x0092},
+ { 0xa0, 0x80, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x84, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x02, 0x00a3},
+ { 0xa0, 0x0d, 0x00a4},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x04, 0x0191},
+ { 0xa0, 0x1a, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x4b, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x10, 0x01a9},
+ { 0xa0, 0x12, 0x01aa},
+ { 0xa0, 0xc8, 0x001d},
+ { 0xa0, 0xd8, 0x001e},
+ { 0xa0, 0xea, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x00, 0x01a7},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa0, 0x40, 0x0116},
+ { 0xa0, 0x40, 0x0117},
+ { 0xa0, 0x40, 0x0118},
+ {0,0,0}
+ };
diff -ruN usb_old/spca5xx/Makefile usb/spca5xx/Makefile
--- linux-2.4.31/drivers/usb_old/spca5xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/Makefile	2005-11-13 13:01:58.000000000 +0100
@@ -0,0 +1,9 @@
+
+spca5xx-objs := spcadecoder.o spca_core.o
+
+obj-$(CONFIG_USB_SPCA5XX) += spca5xx.o
+
+include $(TOPDIR)/Rules.make
+
+spca5xx.o: $(spca5xx-objs)
+	$(LD) -r -o $@ $(spca5xx-objs)
diff -ruN usb_old/spca5xx/Makefile-2.6 usb/spca5xx/Makefile-2.6
--- linux-2.4.31/drivers/usb_old/spca5xx/Makefile-2.6	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/Makefile-2.6	2005-11-21 15:29:27.000000000 +0100
@@ -0,0 +1,9 @@
+
+spca5xx-objs := spcadecoder.o spca_core.o
+
+obj-$(CONFIG_USB_SPCA5XX) += spca5xx.o
+
+clean:
+	rm -f *.[oas] .*.flags *.ko .*.cmd .*.d .*.tmp *.mod.c 
+	rm -rf .tmp_versions
+
diff -ruN usb_old/spca5xx/Makefile.org usb/spca5xx/Makefile.org
--- linux-2.4.31/drivers/usb_old/spca5xx/Makefile.org	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/Makefile.org	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,218 @@
+VERSION    = 00.57.06LE
+CVSVERSION = "$Experimental work Michel Xhaard && Reza Jelveh 03/02/2004"
+DEFINES    =
+
+###
+# The following flags enable experimental features.
+# By default, these are enabled for development versions of the driver, and
+# disabled for release versions.
+
+# Optional: Enable driver debugging
+DEFINES   += -DSPCA50X_ENABLE_DEBUG
+
+# 
+
+# Optional: Enable compression
+DEFINES   += -DSPCA50X_ENABLE_COMPRESSION
+
+###
+# Rest of Makefile follows here. You probably won't need to touch this.
+
+# Setup defines
+
+
+ifneq ($(shell uname -r | cut -d. -f1,2), 2.4)
+
+ifneq ($(KERNELRELEASE),)   # We were called by kbuild
+CFLAGS += $(DEFINES) 
+obj-m += spca5xx.o
+spca5xx-objs := spca_core.o spcadecoder.o 
+
+else   # We were called from command line
+
+KERNEL_VERSION = `uname -r`
+KERNELDIR := /lib/modules/$(KERNEL_VERSION)/build
+PWD  := $(shell pwd)
+MODULE_INSTALLDIR = /lib/modules/$(KERNEL_VERSION)/kernel/drivers/usb/media/
+
+# Targets, don't change!
+default:
+	@echo '   Building SPCA5 Light Edition driver for 2.5/2.6 kernel.'
+	@echo '   Remember: you must have read/write access to your kernel source tree.'
+	$(MAKE) -C $(KERNELDIR) SUBDIRS=$(PWD) CC=$(CC) modules
+
+install:
+	mkdir -p $(MODULE_INSTALLDIR)
+	rm -f $(MODULE_INSTALLDIR)spca50x.ko
+	rm -f $(MODULE_INSTALLDIR)et61x.ko
+	install -c -m 0644 spca5xx.ko $(MODULE_INSTALLDIR)
+	/sbin/depmod -ae
+
+uninstall:
+	rm -f $(MODULE_INSTALLDIR)/spca5xx.ko
+	/sbin/depmod -aq
+
+endif
+
+else   # kernel version test
+
+#############################################################################
+# For Linux 2.4 users.
+# Change the following lines according to your system configuration.
+# It is important to configure your particular source tree ("make dep") before
+# compiling this module!
+#############################################################################
+###
+# This makefile will build the spca50x driver module external to the kernel
+# source tree. It makes it easier to swap kernels.
+
+
+KERNEL_VERSION = `uname -r`
+
+###
+# Location of the header files (most importantly the config files)
+# for the kernel you want to build the module against.
+# This should be correct for the currently installed kernel on your machine.
+KINCLUDE   = /lib/modules/$(KERNEL_VERSION)/build/include
+KERNEL_ACFILE = $(KINCLUDE)/linux/autoconf.h
+KERNEL_MODVERSIONSFILE = $(KINCLUDE)/linux/modversions.h
+MODULE_INSTALLDIR = /lib/modules/$(KERNEL_VERSION)/kernel/drivers/usb/
+
+# Detect module versioning support
+ifneq ($(strip $(shell grep 'define CONFIG_MODVERSIONS 1' $(KERNEL_ACFILE))),)
+	DEFINES += -DMODVERSIONS -include $(KERNEL_MODVERSIONSFILE)
+endif
+
+# Detect SMP support
+ifneq ($(strip $(shell grep 'define CONFIG_SMP 1' $(KERNEL_ACFILE))),)
+	DEFINES += -D__SMP__ -DSMP
+endif
+
+# Setup the tools
+CC         = gcc
+LD         = ld
+
+# Setup compiler warnings
+WARNINGS   = -Wall -Wpointer-arith
+WARNINGS  += -Wcast-align -Wwrite-strings -Wstrict-prototypes
+WARNINGS  += -Wuninitialized -Wreturn-type -Wunused -Wparentheses
+
+# Setup compiler flags
+CFLAGS     = -O2 -fomit-frame-pointer -fno-strict-aliasing -pipe
+CFLAGS    += -mpreferred-stack-boundary=2 
+CFLAGS    += -I$(KINCLUDE) -Idrivers/usb
+
+# Setup link flags
+LDFLAGS    = --strip-debug -r
+
+# Setup the list of files to be included in a distribution
+DIST_FILES = CHANGELOG \
+             README \
+             Makefile \
+             drivers/usb/Config.in \
+             drivers/usb/spcadecoder.c \
+             drivers/usb/spcadecoder.h \
+             drivers/usb/jpeg_header.h \
+	     drivers/usb/jpeg_qtables.h \
+	     drivers/usb/spcagamma.h \
+	     drivers/usb/spcaCompat.h \
+	     drivers/usb/spcausb.h \
+             drivers/usb/spca500_init.h \
+             drivers/usb/spca501_init.h \
+	     drivers/usb/sp5xxfw2.dat \
+             drivers/usb/sp5xxfw2.h \
+             drivers/usb/spca505_init.h \
+             drivers/usb/spca506.h \
+             drivers/usb/spca508_init.h \
+	     drivers/usb/spca561.h \
+	     drivers/usb/sonix.h \
+             drivers/usb/cs2102.h \
+             drivers/usb/hv7131b.h \
+	     drivers/usb/icm105a.h \
+             drivers/usb/hv7131c.h \
+	     drivers/usb/hdcs2020.h \
+             drivers/usb/pb0330.h \
+	     drivers/usb/tas5130c.h \
+	     drivers/usb/zc3xx.h\
+	     drivers/usb/tv8532.h\
+	     drivers/usb/cxlib.h\
+	     drivers/usb/sn9cxxx.h\
+	     drivers/usb/cx11646.h\
+	     drivers/usb/pac207.h\
+	     drivers/usb/spca5xx.c \
+             drivers/usb/spca5xx.h 
+
+OBJS       = drivers/usb/spcadecoder.o \
+             drivers/usb/spca5xx.o
+
+BINARY     = spca5xx.o
+
+###
+# Targets follow here
+
+binary:	$(OBJS)
+	@echo Linking $(BINARY)
+	@$(LD) $(LDFLAGS) -o $(BINARY) $(OBJS)
+
+install: binary
+	@echo Installing.. Your root password may be required.
+	su -c "make install-root"
+
+install-root:
+	@echo Installing..
+	@mkdir -p /lib/modules/`uname -r`/kernel/drivers/usb
+	@rm -f /lib/modules/`uname -r`/kernel/drivers/usb/spca50x.o
+	@rm -f /lib/modules/`uname -r`/kernel/drivers/usb/et61x.o
+	@cp spca5xx.o /lib/modules/`uname -r`/kernel/drivers/usb/spca5xx.o
+	@/sbin/depmod
+
+dist:	clean binary
+	@echo Making distributable archives
+	@rm -f spca5xx-src-$(VERSION).tar.gz
+	@tar zcf spca5xx-src-$(VERSION).tar.gz $(DIST_FILES)
+	@rm -f spca5xx-module-$(VERSION).tar.gz
+	@cp $(BINARY) spca5xx-$(VERSION).o
+	@tar zcf spca5xx-module-$(VERSION).tar.gz spca5xx-$(VERSION).o README
+	@rm spca5xx-$(VERSION).o
+
+.c.o:	Makefile $*.c
+	@echo Compiling $*.c
+	@$(CC) $(CFLAGS) $(WARNINGS) $(DEFINES) -c $*.c -o $*.o
+
+###
+# Dependencies follow here
+
+drivers/usb/spca5xx.o: drivers/usb/spca5xx.h \
+		       drivers/usb/spcaCompat.h \
+		       drivers/usb/spcausb.h \
+		       drivers/usb/sonix.h \
+                       drivers/usb/spca500_init.h \
+                       drivers/usb/spca501_init.h \
+		       drivers/usb/sp5xxfw2.h \
+                       drivers/usb/spca505_init.h \
+		       drivers/usb/spca506.h \
+                       drivers/usb/spca508_init.h \
+		       drivers/usb/spca561.h \
+		       drivers/usb/zc3xx.h\
+		       drivers/usb/tv8532.h\
+		       drivers/usb/cx11646.h\
+		       drivers/usb/mr97311.h\
+		       drivers/usb/sn9cxxx.h\
+		       drivers/usb/pac207.h\
+                       
+
+drivers/usb/spcadecoder.o: drivers/usb/spcadecoder.h \
+			   drivers/usb/spcagamma.h \
+                           drivers/usb/jpeg_header.h
+
+endif  # End kernel version test
+
+
+############################################################################## 
+# OTHER TARGETS 
+##############################################################################
+clean:
+	rm -r -f *.o .spcadecoder.o.cmd \
+	.spca_core.o.cmd  *.o *.ko *.mod.* .[a-z]* core *.i
+	
+############################################################################## 
diff -ruN usb_old/spca5xx/pas106b.h usb/spca5xx/pas106b.h
--- linux-2.4.31/drivers/usb_old/spca5xx/pas106b.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/pas106b.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,443 @@
+ 
+/****************************************************************************
+#	PAS106B library                                                     #
+# 	Copyright (C) 2005 Thomas Kaiser thomas@kaiser.linux-site.net       #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 pas106b_start_data[][3]={
+/* 176x144 */
+/* Sream and Sensor specific */
+ { 0xA1, 0x01, 0x0010}, //CMOSSensorSelect
+/* System */
+ { 0xA0, 0x01, 0x0000}, //SystemControl
+ { 0xA0, 0x01, 0x0000}, //SystemControl
+/* Picture size */
+ { 0xA0, 0x00, 0x0002}, //ClockSelect//00
+/* JPEG control */
+ { 0xA0, 0x03, 0x0008}, //ClockSetting
+/* Sream and Sensor specific */
+ { 0xA0, 0x0F, 0x0010}, //CMOSSensorSelect
+/* Picture size */
+ { 0xA0, 0x00, 0x0003}, //FrameWidthHigh 00
+ { 0xA0, 0xB0, 0x0004}, //FrameWidthLow B0
+ { 0xA0, 0x00, 0x0005}, //FrameHeightHigh 00
+ { 0xA0, 0x90, 0x0006}, //FrameHightLow 90
+/* System */
+ { 0xA0, 0x01, 0x0001}, //SystemOperating
+/* Sream and Sensor specific */
+ { 0xA0, 0x03, 0x0012}, //VideoControlFunction
+ { 0xA0, 0x01, 0x0012}, //VideoControlFunction
+/* Sensor Interface */
+ { 0xA0, 0x08, 0x008D}, //Compatibily Mode
+/* Window inside sensor array */
+ { 0xA0, 0x03, 0x009A}, //WinXStartLow
+ { 0xA0, 0x00, 0x011A}, //FirstYLow
+ { 0xA0, 0x03, 0x011C}, //FirstxLow
+ { 0xA0, 0x28, 0x009C}, //WinHeightLow
+ { 0xA0, 0x68, 0x009E}, //WinWidthLow
+/* Init the sensor */
+ { 0xA0, 0x02, 0x0092}, //write register 0x02 to sensor (i2c)
+ { 0xA0, 0x04, 0x0093}, //Value 0x04
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x08, 0x0092}, //write register 0x08 to sensor (i2c)
+ { 0xA0, 0x00, 0x0093}, //Value 0x00
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x09, 0x0092}, //write register 0x09 to sensor (i2c)
+ { 0xA0, 0x05, 0x0093}, //Value 0x05
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0A, 0x0092}, //write register 0x0A to sensor (i2c)
+ { 0xA0, 0x02, 0x0093}, //Value 0x02
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0B, 0x0092}, //write register 0x0B to sensor (i2c)
+ { 0xA0, 0x02, 0x0093}, //Value 0x02
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0C, 0x0092}, //write register 0x0C to sensor (i2c)
+ { 0xA0, 0x05, 0x0093}, //Value 0x05
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0D, 0x0092}, //write register 0x0D to sensor (i2c)
+ { 0xA0, 0x00, 0x0093}, //Value 0x00
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0E, 0x0092}, //write register 0x0E to sensor (i2c)
+ { 0xA0, 0x02, 0x0093}, //Value 0x02
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x14, 0x0092}, //write register 0x14 to sensor (i2c)
+ { 0xA0, 0x81, 0x0093}, //Value 0x81
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x07, 0x0092}, //write register 0x07 to sensor (i2c)
+ { 0xA0, 0xB1, 0x0093}, //Value 0xB1
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x05, 0x0092}, //write register 0x05 to sensor (i2c)
+ { 0xA0, 0x03, 0x0093}, //Value 0x03
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x04, 0x0092}, //write register 0x04 to sensor (i2c)
+ { 0xA0, 0x01, 0x0093}, //Value 0x01
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x03, 0x0092}, //write register 0x03 to sensor (i2c)
+ { 0xA0, 0x3B, 0x0093}, //Value 0x3B
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+/* Other registors */
+ { 0xA0, 0x37, 0x0101}, //SensorCorrection
+/* Frame retreiving */
+ { 0xA0, 0x00, 0x0019}, //AutoAdjustFPS
+/* Gains */
+ { 0xA0, 0xa0, 0x01A8}, //DigitalGain
+/* Unknown */
+ { 0xA0, 0x00, 0x01Ad},
+/* Sharpness */
+ { 0xA0, 0x03, 0x01C5}, //SharpnessMode
+ { 0xA0, 0x13, 0x01CB}, //Sharpness05
+/* Other registors */
+ { 0xA0, 0x0D, 0x0100}, //OperationMode
+/* Auto exposure and white balance */
+ { 0xA0, 0x06, 0x0189}, // AWBStatus
+/*Dead pixels */
+ { 0xA0, 0x08, 0x0250}, //DeadPixelsMode
+/* EEPROM */
+ { 0xA0, 0x08, 0x0301}, //EEPROMAccess
+/* JPEG control */
+ { 0xA0, 0x03, 0x0008}, //ClockSetting
+/* Unknown */
+ { 0xA0, 0x08, 0x01C6},
+/* Sharpness */
+ { 0xA0, 0x0F, 0x01CB}, //Sharpness05
+/* Other registers */
+ { 0xA0, 0x0D, 0x0100}, //OperationMode
+/* Auto exposure and white balance */
+ { 0xA0, 0x06, 0x0189}, // AWBStatus
+/*Dead pixels */
+ { 0xA0, 0x08, 0x0250}, //DeadPixelsMode
+/* EEPROM */
+ { 0xA0, 0x08, 0x0301}, //EEPROMAccess
+/* JPEG control */
+ { 0xA0, 0x03, 0x0008}, //ClockSetting
+/* Sharpness */
+ { 0xA0, 0x08, 0x01C6}, //Sharpness00
+ { 0xA0, 0x0F, 0x01CB}, //Sharpness05
+/* Gamma matrix */
+ { 0xA0, 0x04, 0x0120},
+ { 0xA0, 0x16, 0x0121},
+ { 0xA0, 0x30, 0x0122},
+ { 0xA0, 0x4E, 0x0123},
+ { 0xA0, 0x68, 0x0124},
+ { 0xA0, 0x81, 0x0125},
+ { 0xA0, 0x98, 0x0126},
+ { 0xA0, 0xAC, 0x0127},
+ { 0xA0, 0xBE, 0x0128},
+ { 0xA0, 0xCD, 0x0129},
+ { 0xA0, 0xDA, 0x012A},
+ { 0xA0, 0xE4, 0x012B},
+ { 0xA0, 0xED, 0x012C},
+ { 0xA0, 0xF5, 0x012D},
+ { 0xA0, 0xFB, 0x012E},
+ { 0xA0, 0xFF, 0x012F},
+ { 0xA0, 0x0C, 0x0130},
+ { 0xA0, 0x16, 0x0131},
+ { 0xA0, 0x1B, 0x0132},
+ { 0xA0, 0x1C, 0x0133},
+ { 0xA0, 0x19, 0x0134},
+ { 0xA0, 0x18, 0x0135},
+ { 0xA0, 0x15, 0x0136},
+ { 0xA0, 0x12, 0x0137},
+ { 0xA0, 0x10, 0x0138},
+ { 0xA0, 0x0D, 0x0139},
+ { 0xA0, 0x0B, 0x013A},
+ { 0xA0, 0x09, 0x013B},
+ { 0xA0, 0x08, 0x013C},
+ { 0xA0, 0x06, 0x013D},
+ { 0xA0, 0x05, 0x013E},
+ { 0xA0, 0x03, 0x013F},
+/* Color matrix */
+ { 0xA0, 0x58, 0x010A},
+ { 0xA0, 0xF4, 0x010B},
+ { 0xA0, 0xF4, 0x010C},
+ { 0xA0, 0xF4, 0x010D},
+ { 0xA0, 0x58, 0x010E},
+ { 0xA0, 0xF4, 0x010F},
+ { 0xA0, 0xF4, 0x0110},
+ { 0xA0, 0xF4, 0x0111},
+ { 0xA0, 0x58, 0x0112},
+/* Auto correction */
+ { 0xA0, 0x03, 0x0181}, //WinXstart
+ { 0xA0, 0x08, 0x0182}, //WinXWidth
+ { 0xA0, 0x16, 0x0183}, //WinXCenter
+ { 0xA0, 0x03, 0x0184}, //WinYStart
+ { 0xA0, 0x05, 0x0185}, //WinYWidth
+ { 0xA0, 0x14, 0x0186}, //WinYCenter
+ { 0xA0, 0x00, 0x0180}, //AutoCorrectEnable
+/* Auto exposure and white balance */
+ { 0xA0, 0x00, 0x0190}, //ExposureLimitHigh
+ { 0xA0, 0x03, 0x0191}, //ExposureLimitMid
+ { 0xA0, 0xB1, 0x0192}, //ExposureLimitLow
+ { 0xA0, 0x00, 0x0195}, //AntiFlickerHigh
+ { 0xA0, 0x00, 0x0196}, //AntiFlickerLow
+ { 0xA0, 0x87, 0x0197}, //AntiFlickerLow
+ { 0xA0, 0x0C, 0x018C}, //AEBFreeze
+ { 0xA0, 0x18, 0x018F}, //AEBUnfreeze
+/* Gains */
+ { 0xA0, 0x20, 0x01A9}, //DigitalLimitDiff
+ { 0xA0, 0x26, 0x01AA}, //DigitalGainStep
+ { 0xA0, 0xA0, 0x011D}, //GlobalGain
+ { 0xA0, 0x60, 0x011D}, //GlobalGain
+/* Auto correction */
+ { 0xA0, 0x40, 0x0180}, //AutoCorrectEnable
+ { 0xa1, 0x01, 0x0180}, //AutoCorrectEnable
+ { 0xA0, 0x42, 0x0180}, //AutoCorrectEnable
+/* Gains */
+ { 0xA0, 0x40, 0x0116}, //RGain
+ { 0xA0, 0x40, 0x0117}, //GGain
+ { 0xA0, 0x40, 0x0118}, //BGain
+ {0,0,0}
+ };
+ 
+static __u16 pas106b_scale_data[][3]= {
+/* 352x288 */
+/* Sream and Sensor specific */
+ { 0xA1, 0x01, 0x0010}, //CMOSSensorSelect
+/* System */
+ { 0xA0, 0x01, 0x0000}, //SystemControl
+ { 0xA0, 0x01, 0x0000}, //SystemControl
+/* Picture size */
+ { 0xA0, 0x00, 0x0002}, //ClockSelect
+/* JPEG control */
+ { 0xA0, 0x03, 0x0008}, //ClockSetting
+/* Sream and Sensor specific */
+ { 0xA0, 0x0F, 0x0010}, //CMOSSensorSelect
+/* Picture size */
+ { 0xA0, 0x01, 0x0003}, //FrameWidthHigh
+ { 0xA0, 0x60, 0x0004}, //FrameWidthLow
+ { 0xA0, 0x01, 0x0005}, //FrameHeightHigh
+ { 0xA0, 0x20, 0x0006}, //FrameHightLow
+/* System */
+ { 0xA0, 0x01, 0x0001}, //SystemOperating
+/* Sream and Sensor specific */
+ { 0xA0, 0x03, 0x0012}, //VideoControlFunction
+ { 0xA0, 0x01, 0x0012}, //VideoControlFunction
+/* Sensor Interface */
+ { 0xA0, 0x08, 0x008D}, //Compatibily Mode
+/* Window inside sensor array */
+ { 0xA0, 0x03, 0x009A}, //WinXStartLow
+ { 0xA0, 0x00, 0x011A}, //FirstYLow
+ { 0xA0, 0x03, 0x011C}, //FirstxLow
+ { 0xA0, 0x28, 0x009C}, //WinHeightLow
+ { 0xA0, 0x68, 0x009E}, //WinWidthLow
+/* Init the sensor */
+ { 0xA0, 0x02, 0x0092}, //write register 0x02 to sensor (i2c)
+ { 0xA0, 0x04, 0x0093}, //Value 0x04
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x08, 0x0092}, //write register 0x08 to sensor (i2c)
+ { 0xA0, 0x00, 0x0093}, //Value 0x00
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x09, 0x0092}, //write register 0x09 to sensor (i2c)
+ { 0xA0, 0x05, 0x0093}, //Value 0x05
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0A, 0x0092}, //write register 0x0A to sensor (i2c)
+ { 0xA0, 0x02, 0x0093}, //Value 0x02
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0B, 0x0092}, //write register 0x0B to sensor (i2c)
+ { 0xA0, 0x02, 0x0093}, //Value 0x02
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0C, 0x0092}, //write register 0x0C to sensor (i2c)
+ { 0xA0, 0x05, 0x0093}, //Value 0x05
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0D, 0x0092}, //write register 0x0D to sensor (i2c)
+ { 0xA0, 0x00, 0x0093}, //Value 0x00
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x0E, 0x0092}, //write register 0x0E to sensor (i2c)
+ { 0xA0, 0x02, 0x0093}, //Value 0x02
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x14, 0x0092}, //write register 0x14 to sensor (i2c)
+ { 0xA0, 0x81, 0x0093}, //Value 0x81
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x07, 0x0092}, //write register 0x07 to sensor (i2c)
+ { 0xA0, 0xB1, 0x0093}, //Value 0xB1
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x05, 0x0092}, //write register 0x05 to sensor (i2c)
+ { 0xA0, 0x03, 0x0093}, //Value 0x03
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x04, 0x0092}, //write register 0x04 to sensor (i2c)
+ { 0xA0, 0x01, 0x0093}, //Value 0x01
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+ { 0xA0, 0x03, 0x0092}, //write register 0x03 to sensor (i2c)
+ { 0xA0, 0x3B, 0x0093}, //Value 0x3B
+ { 0xA0, 0x00, 0x0094},
+ { 0xA0, 0x01, 0x0090},
+ { 0xA1, 0x01, 0x0091}, //end write i2c
+/* Other registors */
+ { 0xA0, 0x37, 0x0101}, //SensorCorrection
+/* Frame retreiving */
+ { 0xA0, 0x00, 0x0019}, //AutoAdjustFPS
+/* Gains */
+ { 0xA0, 0xa0, 0x01A8}, //DigitalGain
+/* Unknown */
+ { 0xA0, 0x00, 0x01Ad},
+/* Sharpness */
+ { 0xA0, 0x03, 0x01C5}, //SharpnessMode
+ { 0xA0, 0x13, 0x01CB}, //Sharpness05
+/* Other registors */
+ { 0xA0, 0x0D, 0x0100}, //OperationMode
+/* Auto exposure and white balance */
+ { 0xA0, 0x06, 0x0189}, // AWBStatus
+/*Dead pixels */
+ { 0xA0, 0x08, 0x0250}, //DeadPixelsMode
+/* EEPROM */
+ { 0xA0, 0x08, 0x0301}, //EEPROMAccess
+/* JPEG control */
+ { 0xA0, 0x03, 0x0008}, //ClockSetting
+/* Unknown */
+ { 0xA0, 0x08, 0x01C6},
+/* Sharpness */
+ { 0xA0, 0x0F, 0x01CB}, //Sharpness05
+/* Other registers */
+ { 0xA0, 0x0D, 0x0100}, //OperationMode
+/* Auto exposure and white balance */
+ { 0xA0, 0x06, 0x0189}, // AWBStatus
+/*Dead pixels */
+ { 0xA0, 0x08, 0x0250}, //DeadPixelsMode
+/* EEPROM */
+ { 0xA0, 0x08, 0x0301}, //EEPROMAccess
+/* JPEG control */
+ { 0xA0, 0x03, 0x0008}, //ClockSetting
+/* Sharpness */
+ { 0xA0, 0x08, 0x01C6}, //Sharpness00
+ { 0xA0, 0x0F, 0x01CB}, //Sharpness05
+/* Gamma matrix */
+ { 0xA0, 0x04, 0x0120},
+ { 0xA0, 0x16, 0x0121},
+ { 0xA0, 0x30, 0x0122},
+ { 0xA0, 0x4E, 0x0123},
+ { 0xA0, 0x68, 0x0124},
+ { 0xA0, 0x81, 0x0125},
+ { 0xA0, 0x98, 0x0126},
+ { 0xA0, 0xAC, 0x0127},
+ { 0xA0, 0xBE, 0x0128},
+ { 0xA0, 0xCD, 0x0129},
+ { 0xA0, 0xDA, 0x012A},
+ { 0xA0, 0xE4, 0x012B},
+ { 0xA0, 0xED, 0x012C},
+ { 0xA0, 0xF5, 0x012D},
+ { 0xA0, 0xFB, 0x012E},
+ { 0xA0, 0xFF, 0x012F},
+ { 0xA0, 0x0C, 0x0130},
+ { 0xA0, 0x16, 0x0131},
+ { 0xA0, 0x1B, 0x0132},
+ { 0xA0, 0x1C, 0x0133},
+ { 0xA0, 0x19, 0x0134},
+ { 0xA0, 0x18, 0x0135},
+ { 0xA0, 0x15, 0x0136},
+ { 0xA0, 0x12, 0x0137},
+ { 0xA0, 0x10, 0x0138},
+ { 0xA0, 0x0D, 0x0139},
+ { 0xA0, 0x0B, 0x013A},
+ { 0xA0, 0x09, 0x013B},
+ { 0xA0, 0x08, 0x013C},
+ { 0xA0, 0x06, 0x013D},
+ { 0xA0, 0x05, 0x013E},
+ { 0xA0, 0x03, 0x013F},
+/* Color matrix */
+ { 0xA0, 0x58, 0x010A},
+ { 0xA0, 0xF4, 0x010B},
+ { 0xA0, 0xF4, 0x010C},
+ { 0xA0, 0xF4, 0x010D},
+ { 0xA0, 0x58, 0x010E},
+ { 0xA0, 0xF4, 0x010F},
+ { 0xA0, 0xF4, 0x0110},
+ { 0xA0, 0xF4, 0x0111},
+ { 0xA0, 0x58, 0x0112},
+/* Auto correction */
+ { 0xA0, 0x03, 0x0181}, //WinXstart
+ { 0xA0, 0x08, 0x0182}, //WinXWidth
+ { 0xA0, 0x16, 0x0183}, //WinXCenter
+ { 0xA0, 0x03, 0x0184}, //WinYStart
+ { 0xA0, 0x05, 0x0185}, //WinYWidth
+ { 0xA0, 0x14, 0x0186}, //WinYCenter
+ { 0xA0, 0x00, 0x0180}, //AutoCorrectEnable
+/* Auto exposure and white balance */
+ { 0xA0, 0x00, 0x0190}, //ExposureLimitHigh
+ { 0xA0, 0x03, 0x0191}, //ExposureLimitMid
+ { 0xA0, 0xB1, 0x0192}, //ExposureLimitLow
+ { 0xA0, 0x00, 0x0195}, //AntiFlickerHigh
+ { 0xA0, 0x00, 0x0196}, //AntiFlickerLow
+ { 0xA0, 0x87, 0x0197}, //AntiFlickerLow
+ { 0xA0, 0x0C, 0x018C}, //AEBFreeze
+ { 0xA0, 0x18, 0x018F}, //AEBUnfreeze
+/* Gains */
+ { 0xA0, 0x20, 0x01A9}, //DigitalLimitDiff
+ { 0xA0, 0x26, 0x01AA}, //DigitalGainStep
+ { 0xA0, 0xA0, 0x011D}, //GlobalGain
+ { 0xA0, 0x60, 0x011D}, //GlobalGain
+/* Auto correction */
+ { 0xA0, 0x40, 0x0180}, //AutoCorrectEnable
+ { 0xa1, 0x01, 0x0180}, //AutoCorrectEnable
+ { 0xA0, 0x42, 0x0180}, //AutoCorrectEnable
+/* Gains */
+ { 0xA0, 0x40, 0x0116}, //RGain
+ { 0xA0, 0x40, 0x0117}, //GGain
+ { 0xA0, 0x40, 0x0118}, //BGain
+ {0,0,0}
+ };
+ 
diff -ruN usb_old/spca5xx/pb0330.h usb/spca5xx/pb0330.h
--- linux-2.4.31/drivers/usb_old/spca5xx/pb0330.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/pb0330.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,463 @@
+  
+/****************************************************************************
+#	 	Photobit Pb0330 library                                     #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 pb0330xx_start_data[][3]=
+{
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x0a, 0x0010},
+ { 0xa0, 0x10, 0x0002},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x07, 0x0012},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x06, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x02, 0x0092},
+ { 0xa0, 0x11, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0xe7, 0x0093},
+ { 0xa0, 0x01, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x87, 0x0093},
+ { 0xa0, 0x02, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x07, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x30, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x11, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x2f, 0x0092},
+ { 0xa0, 0xb0, 0x0093},
+ { 0xa0, 0xf7, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x30, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x31, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x34, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x01, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x35, 0x0092},
+ { 0xa0, 0x60, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x3d, 0x0092},
+ { 0xa0, 0x8f, 0x0093},
+ { 0xa0, 0x06, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x40, 0x0092},
+ { 0xa0, 0xe0, 0x0093},
+ { 0xa0, 0x01, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x58, 0x0092},
+ { 0xa0, 0x78, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x62, 0x0092},
+ { 0xa0, 0x11, 0x0093},
+ { 0xa0, 0x04, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0087},
+ { 0xa0, 0x37, 0x0101},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa0, 0x60, 0x01a8},
+ { 0xa0, 0x6c, 0x018d},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa0, 0x09, 0x01ad},
+ { 0xa0, 0x15, 0x01ae},
+ { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x02, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa1, 0x01, 0x0095},
+ { 0xa1, 0x01, 0x0096},
+ { 0xa0, 0x50, 0x010a},
+ { 0xa0, 0xf8, 0x010b},
+ { 0xa0, 0xf8, 0x010c},
+ { 0xa0, 0xf8, 0x010d},
+ { 0xa0, 0x50, 0x010e},
+ { 0xa0, 0xf8, 0x010f},
+ { 0xa0, 0xf8, 0x0110},
+ { 0xa0, 0xf8, 0x0111},
+ { 0xa0, 0x50, 0x0112},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008}, //00
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x13, 0x0120},
+ { 0xa0, 0x38, 0x0121},
+ { 0xa0, 0x59, 0x0122},
+ { 0xa0, 0x79, 0x0123},
+ { 0xa0, 0x92, 0x0124},
+ { 0xa0, 0xa7, 0x0125},
+ { 0xa0, 0xb9, 0x0126},
+ { 0xa0, 0xc8, 0x0127},
+ { 0xa0, 0xd4, 0x0128},
+ { 0xa0, 0xdf, 0x0129},
+ { 0xa0, 0xe7, 0x012a},
+ { 0xa0, 0xee, 0x012b},
+ { 0xa0, 0xf4, 0x012c},
+ { 0xa0, 0xf9, 0x012d},
+ { 0xa0, 0xfc, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x26, 0x0130},
+ { 0xa0, 0x22, 0x0131},
+ { 0xa0, 0x20, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0d, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x05, 0x013c},
+ { 0xa0, 0x04, 0x013d},
+ { 0xa0, 0x03, 0x013e},
+ { 0xa0, 0x02, 0x013f},
+ { 0xa0, 0x50, 0x010a},
+ { 0xa0, 0xf8, 0x010b},
+ { 0xa0, 0xf8, 0x010c},
+ { 0xa0, 0xf8, 0x010d},
+ { 0xa0, 0x50, 0x010e},
+ { 0xa0, 0xf8, 0x010f},
+ { 0xa0, 0xf8, 0x0110},
+ { 0xa0, 0xf8, 0x0111},
+ { 0xa0, 0x50, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x66, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x09, 0x0092},
+ { 0xa0, 0xb2, 0x0093},
+ { 0xa0, 0x02, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x60, 0x011d},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x07, 0x0191},
+ { 0xa0, 0x8c, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x8a, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x14, 0x01a9},
+ { 0xa0, 0x24, 0x01aa},
+ { 0xa0, 0xd7, 0x001d},
+ { 0xa0, 0xf0, 0x001e},
+ { 0xa0, 0xf8, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x09, 0x01ad},
+ { 0xa0, 0x15, 0x01ae},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0007},
+// { 0xa0, 0x30, 0x0007},
+// { 0xa0, 0x00, 0x0007},
+ {0,0,0}
+ };
+static __u16 pb0330xx_scale_data[][3]=
+{
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x0a, 0x0010},
+ { 0xa0, 0x00, 0x0002}, // 10
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x07, 0x0012},
+ { 0xa0, 0x00, 0x0098},
+ { 0xa0, 0x00, 0x009a},
+ { 0xa0, 0x00, 0x011a},
+ { 0xa0, 0x00, 0x011c},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x01, 0x0092},
+ { 0xa0, 0x06, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x02, 0x0092},
+ { 0xa0, 0x11, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x03, 0x0092},
+ { 0xa0, 0xe7, 0x0093},
+ { 0xa0, 0x01, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x04, 0x0092},
+ { 0xa0, 0x87, 0x0093},
+ { 0xa0, 0x02, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x06, 0x0092},
+ { 0xa0, 0x03, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x07, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x30, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x20, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x11, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x2f, 0x0092},
+ { 0xa0, 0xb0, 0x0093},
+ { 0xa0, 0xf7, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x30, 0x0092},
+ { 0xa0, 0x05, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x31, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x34, 0x0092},
+ { 0xa0, 0x00, 0x0093},
+ { 0xa0, 0x01, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x35, 0x0092},
+ { 0xa0, 0x60, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x3d, 0x0092},
+ { 0xa0, 0x8f, 0x0093},
+ { 0xa0, 0x06, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x40, 0x0092},
+ { 0xa0, 0xe0, 0x0093},
+ { 0xa0, 0x01, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x58, 0x0092},
+ { 0xa0, 0x78, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x62, 0x0092},
+ { 0xa0, 0x11, 0x0093},
+ { 0xa0, 0x04, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0087},
+ { 0xa0, 0x37, 0x0101},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa0, 0x60, 0x01a8},
+ { 0xa0, 0x6c, 0x018d},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa0, 0x09, 0x01ad},
+ { 0xa0, 0x15, 0x01ae},
+ { 0xa0, 0x00, 0x0092},
+ { 0xa0, 0x02, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa1, 0x01, 0x0095},
+ { 0xa1, 0x01, 0x0096},
+ { 0xa0, 0x50, 0x010a},
+ { 0xa0, 0xf8, 0x010b},
+ { 0xa0, 0xf8, 0x010c},
+ { 0xa0, 0xf8, 0x010d},
+ { 0xa0, 0x50, 0x010e},
+ { 0xa0, 0xf8, 0x010f},
+ { 0xa0, 0xf8, 0x0110},
+ { 0xa0, 0xf8, 0x0111},
+ { 0xa0, 0x50, 0x0112},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},//00
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x13, 0x0120},
+ { 0xa0, 0x38, 0x0121},
+ { 0xa0, 0x59, 0x0122},
+ { 0xa0, 0x79, 0x0123},
+ { 0xa0, 0x92, 0x0124},
+ { 0xa0, 0xa7, 0x0125},
+ { 0xa0, 0xb9, 0x0126},
+ { 0xa0, 0xc8, 0x0127},
+ { 0xa0, 0xd4, 0x0128},
+ { 0xa0, 0xdf, 0x0129},
+ { 0xa0, 0xe7, 0x012a},
+ { 0xa0, 0xee, 0x012b},
+ { 0xa0, 0xf4, 0x012c},
+ { 0xa0, 0xf9, 0x012d},
+ { 0xa0, 0xfc, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x26, 0x0130},
+ { 0xa0, 0x22, 0x0131},
+ { 0xa0, 0x20, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x16, 0x0134},
+ { 0xa0, 0x13, 0x0135},
+ { 0xa0, 0x10, 0x0136},
+ { 0xa0, 0x0d, 0x0137},
+ { 0xa0, 0x0b, 0x0138},
+ { 0xa0, 0x09, 0x0139},
+ { 0xa0, 0x07, 0x013a},
+ { 0xa0, 0x06, 0x013b},
+ { 0xa0, 0x05, 0x013c},
+ { 0xa0, 0x04, 0x013d},
+ { 0xa0, 0x03, 0x013e},
+ { 0xa0, 0x02, 0x013f},
+ { 0xa0, 0x50, 0x010a},
+ { 0xa0, 0xf8, 0x010b},
+ { 0xa0, 0xf8, 0x010c},
+ { 0xa0, 0xf8, 0x010d},
+ { 0xa0, 0x50, 0x010e},
+ { 0xa0, 0xf8, 0x010f},
+ { 0xa0, 0xf8, 0x0110},
+ { 0xa0, 0xf8, 0x0111},
+ { 0xa0, 0x50, 0x0112},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0x05, 0x0092},
+ { 0xa0, 0x66, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x09, 0x0092},
+ { 0xa0, 0xb2, 0x0093},
+ { 0xa0, 0x02, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x10, 0x0092},
+ { 0xa0, 0x02, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x60, 0x011d},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x07, 0x0191},
+ { 0xa0, 0x8c, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x8a, 0x0197},
+ { 0xa0, 0x10, 0x018c},
+ { 0xa0, 0x20, 0x018f},
+ { 0xa0, 0x14, 0x01a9},
+ { 0xa0, 0x24, 0x01aa},
+ { 0xa0, 0xd7, 0x001d},
+ { 0xa0, 0xf0, 0x001e},
+ { 0xa0, 0xf8, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x09, 0x01ad},
+ { 0xa0, 0x15, 0x01ae},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa1, 0x01, 0x0007},
+// { 0xa0, 0x30, 0x0007},
+// { 0xa0, 0x00, 0x0007},
+ {0,0,0}
+ };
diff -ruN usb_old/spca5xx/sn9cxxx.h usb/spca5xx/sn9cxxx.h
--- linux-2.4.31/drivers/usb_old/spca5xx/sn9cxxx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/sn9cxxx.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,874 @@
+#ifndef SONIXJPGUSB_H
+#define SONIXJPGUSB_H
+/****************************************************************************
+#	 	Sonix sn9c102p sn9c105 sn9c120 library                      #
+# 		Copyright (C) 2005 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+static int sn9cxxx_init(struct usb_spca50x *spca50x);
+static void sn9cxxx_start(struct usb_spca50x *spca50x);
+static void sn9cxxx_stop(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_setbrightness(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_getbrightness(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_setcontrast(struct usb_spca50x *spca50x);
+static __u16 sn9cxxx_getcontrast(struct usb_spca50x *spca50x);
+static unsigned int sn9cxxx_getexposure(struct usb_spca50x *spca50x);
+static unsigned int sn9cxxx_getexposure(struct usb_spca50x *spca50x);
+//static void sn9cxxx_setAutobright (struct usb_spca50x *spca50x);
+//static void sn9cxxx_shutdown(struct usb_spca50x *spca50x);
+static int sn9cxxx_probesensor(struct usb_spca50x *spca50x);
+static int sonix_config(struct usb_spca50x *spca50x);
+enum {  
+	SN9C101 = 0,
+	SN9C102, 
+	SN9C102P,
+	SN9C103, 
+	SN9C105,
+	SN9C120,
+};
+
+
+static __u8 sn_mi0360[]= {
+  0x00, 0x61, 0x44, 0x00, 0x1A, 0x20, 0x20, 0x20, 0xB1, 0x5D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00,
+//reg0  reg1  reg2  reg3  reg4  reg5  reg6  reg7  reg8  reg9  rega  regb  regc  regd  rege  regf  reg10 reg11
+  0x00, 0x02, 0x0a, 0x28, 0x1e, 0x61, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+//reg12 reg13 reg14 reg15 reg16 reg17 reg18 reg19 reg1a reg1b reg1c reg1d reg1e reg1f reg20 reg21 reg22 reg23
+};
+
+/*Data from sn9c102p+hv71331r */
+static __u8 sn_hv7131[]= {
+  0x00, 0x03, 0x64, 0x00, 0x1A, 0x20, 0x20, 0x20, 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00,//00
+//reg0  reg1  reg2  reg3  reg4  reg5  reg6  reg7  reg8  reg9  rega  regb  regc  regd  rege  regf  reg10 reg11
+  0x00, 0x01, 0x03, 0x28, 0x1e, 0x41, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+//reg12 reg13 reg14 reg15 reg16 reg17 reg18 reg19 reg1a reg1b reg1c reg1d reg1e reg1f reg20 reg21 reg22 reg23
+};
+static __u8 reg9a[] = {
+	0x08, 0x40, 0x20, 0x10, 0x00, 0x04
+};
+
+static __u8 regsn20[] = { 
+	0x00, 0x2D, 0x46, 0x5A, 0x6C, 0x7C, 0x8B, 0x99, 0xA6, 0xB2, 0xBF, 0xCA, 0xD5, 0xE0, 0xEB, 0xF5, 0xFF
+};
+static __u8 reg84[] = {
+	0x14, 0x00, 0x27, 0x00, 0x07, 0x00, 0xE5, 0x0F, 0xE4, 0x0F, 0x38, 0x00, 0x3E, 0x00, 0xC3, 0x0F,
+	0x00, 0x00, 0x00, 0x00, 0x00
+};
+ static __u8 hv7131r_sensor_init[][8]={
+	{ 0xC1, 0x11, 0x01, 0x08, 0x01, 0x00, 0x00, 0x10 },
+	{ 0xB1, 0x11, 0x34, 0x17, 0x7F, 0x00, 0x00, 0x10 },
+	{ 0xD1, 0x11, 0x40, 0xFF, 0x7F, 0x7F, 0x7F, 0x10 },
+	{ 0x91, 0x11, 0x44, 0x00, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xD1, 0x11, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xD1, 0x11, 0x14, 0x01, 0xE2, 0x02, 0x82, 0x10 },
+	{ 0x91, 0x11, 0x18, 0x00, 0x00, 0x00, 0x00, 0x10 },
+//	
+	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xC1, 0x11, 0x25, 0x00, 0x61, 0xA8, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x30, 0x22, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xC1, 0x11, 0x31, 0x20, 0x2E, 0x20, 0x00, 0x10 },
+	{ 0xC1, 0x11, 0x25, 0x00, 0xC3, 0x50, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x30, 0x07, 0x00, 0x00, 0x00, 0x10 },//gain14
+	{ 0xC1, 0x11, 0x31, 0x10, 0x10, 0x10, 0x00, 0x10 },//r g b 101a10	
+//
+	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x21, 0xD0, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x23, 0x09, 0x00, 0x00, 0x00, 0x10 },
+//
+	{ 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x21, 0xD0, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10 },
+	{ 0xA1, 0x11, 0x23, 0x10, 0x00, 0x00, 0x00, 0x10 },
+	{ 0, 0, 0, 0, 0, 0, 0, 0 }
+};	
+static __u8
+mi0360_sensor_init[][8]={
+	{ 0xB1,0x5D,0x07,0x00,0x02,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x0D,0x00,0x01,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x0D,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x01,0x00,0x08,0x00,0x16,0x10 },
+	{ 0xD1,0x5D,0x03,0x01,0xE2,0x02,0x82,0x10 },
+	{ 0xD1,0x5D,0x05,0x00,0x09,0x00,0x53,0x10 },
+	{ 0xB1,0x5D,0x0D,0x00,0x02,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x0A,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x0C,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x0E,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x10,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x12,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x14,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x16,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x18,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x1A,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x1C,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x32,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x20,0x91,0x01,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x22,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x24,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x26,0x00,0x00,0x00,0x24,0x10 },
+	{ 0xD1,0x5D,0x2F,0xF7,0xB0,0x00,0x04,0x10 },
+	{ 0xD1,0x5D,0x31,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x33,0x00,0x00,0x01,0x00,0x10 },
+	{ 0xB1,0x5D,0x3D,0x06,0x8F,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x40,0x01,0xE0,0x00,0xD1,0x10 },
+	{ 0xB1,0x5D,0x44,0x00,0x82,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x58,0x00,0x78,0x00,0x43,0x10 },
+	{ 0xD1,0x5D,0x5A,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x5C,0x00,0x00,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x5E,0x00,0x00,0xA3,0x1D,0x10 },
+	{ 0xB1,0x5D,0x62,0x04,0x11,0x00,0x00,0x10 },
+	
+	{ 0xB1,0x5D,0x20,0x91,0x01,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x20,0x11,0x01,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x09,0x00,0x64,0x00,0x00,0x10 },
+	{ 0xD1,0x5D,0x2B,0x00,0xA0,0x00,0xB0,0x10 },
+	{ 0xD1,0x5D,0x2D,0x00,0xA0,0x00,0xA0,0x10 },
+	
+	
+	
+	{ 0xB1,0x5D,0x0A,0x00,0x02,0x00,0x00,0x10 }, //sensor clck ?2
+	{ 0xB1,0x5D,0x06,0x00,0x30,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x05,0x00,0x0A,0x00,0x00,0x10 },
+	{ 0xB1,0x5D,0x09,0x02,0x35,0x00,0x00,0x10 },// exposure 2
+	//{ 0xD1,0x5D,0x2B,0x00,0xB9,0x00,0xE3,0x10 },
+	//{ 0xD1,0x5D,0x2D,0x00,0xC5,0x00,0xB9,0x10 },
+	
+	{ 0xB1,0x5D,0x35,0x00,0x67,0x00,0x00,0x10 }, //gain 
+	{ 0xB1,0x5D,0x07,0x00,0x03,0x00,0x00,0x10 }, //update
+	{ 0xB1,0x5D,0x07,0x00,0x02,0x00,0x00,0x10 }, //sensor on
+	{ 0, 0, 0, 0, 0, 0, 0, 0 }
+};
+#if 0
+/* Data from sn9c120+hv7131r */
+static __u8
+hv7131r_sensor_init[][8]={
+	{0xc1,0x11,0x01,0x08,0x01,0x00,0x00,0x10},
+	{0xd1,0x11,0x10,0x00,0x00,0x00,0x00,0x10},
+	{0xd1,0x11,0x14,0x01,0xe2,0x02,0x82,0x10},
+	{0xb1,0x11,0x34,0x17,0x7f,0x00,0x00,0x10},
+	{0xd1,0x11,0x40,0xff,0x7f,0x7f,0x7f,0x10},
+
+	{0xa1,0x11,0x01,0x08,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x01,0x08,0x00,0x00,0x00,0x10},
+	{0xc1,0x11,0x25,0x00,0xc3,0x50,0x00,0x10},
+	{0xa1,0x11,0x30,0x20,0x00,0x00,0x00,0x10},
+	{0xc1,0x11,0x31,0x13,0x06,0x12,0x00,0x10},
+
+	{0xa1,0x11,0x01,0x08,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x20,0x00,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x21,0xd0,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x22,0x00,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x23,0x08,0x00,0x00,0x00,0x10},
+	{0xc1,0x11,0x31,0x17,0x06,0x10,0x00,0x10},
+
+	{0xa1,0x11,0x01,0x08,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x20,0x00,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x21,0xd1,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x22,0x00,0x00,0x00,0x00,0x10},
+	{0xa1,0x11,0x23,0x10,0x00,0x00,0x00,0x10},
+	{ 0, 0, 0, 0, 0, 0, 0, 0 }
+};
+static __u8 sn_hv7131[]= {
+  0x00, 0x23, 0x60, 0x00, 0x1A, 0x1f, 0x21, 0x1f, 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00,
+//reg0  reg1  reg2  reg3  reg4  reg5  reg6  reg7  reg8  reg9  rega  regb  regc  regd  rege  regf  reg10 reg11
+  0x00, 0x01, 0x0c, 0x28, 0x1e, 0x60, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+//reg12 reg13 reg14 reg15 reg16 reg17 reg18 reg19 reg1a reg1b reg1c reg1d reg1e reg1f reg20 reg21 reg22 reg23
+};
+static __u8 reg9a[] = {
+//HV7131//0x08, 0x40, 0x20, 0x10, 0x00, 0x04
+	//0x00, 0x40, 0x20, 0x00, 0x00, 0x00 
+	0x07, 0x40, 0x20, 0x00, 0x00, 0x00 //MI0360
+};
+
+static __u8 regsn20[] = {
+//HV7131//0x00, 0x2D, 0x46, 0x5A, 0x6C, 0x7C, 0x8B, 0x99, 0xA6, 0xB2, 0xBF, 0xCA, 0xD5, 0xE0, 0xEB, 0xF5, 0xFF
+	//0x08, 0x3a, 0x52, 0x65, 0x75, 0x83, 0x91, 0x9d, 0xa9, 0xb4, 0xbe, 0xc8, 0xd2, 0xdb, 0xe4, 0xed, 0xf5 //hv7131R
+	0x08, 0x39, 0x51, 0x63, 0x73, 0x82, 0x8f, 0x9b, 0xa7, 0xb1, 0xbc, 0xc6, 0xcf, 0xd8, 0xe1, 0xea, 0xf2 //mi0360
+};
+static __u8 reg84[] = {
+//HV7131//0x14, 0x00, 0x27, 0x00, 0x07, 0x00, 0xE5, 0x0F, 0xE4, 0x0F, 0x38, 0x00, 0x3E, 0x00, 0xC3, 0x0F,
+	//0x00, 0x00, 0x00, 0x00, 0x00
+//HV7131//0x13, 0x00, 0x25, 0x00, 0x07, 0x00, 0xef, 0x0f, 0xdf, 0x0f, 0x33, 0x00, 0x38, 0x00, 0xd1, 0x0f,
+	//0xf7, 0x0f, 0x0f, 0x00, 0x00
+	//MI0360
+	0x13, 0x00, 0x25, 0x00, 0x07, 0x00, 0xee, 0x0f, 0xe5, 0x0f, 0x2e, 0x00, 0x30, 0x00, 0xd4, 0x0f, 
+	0xfc, 0x0f, 0x14, 0x00, 0x00
+};
+#endif
+#if 0
+static __u8 qtable1[] = {
+	0x0B, 0x07, 0x07, 0x0B, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0E, 0x0B, 0x0B, 0x0E, 0x12, 0x1D,
+	0x12, 0x12, 0x0E, 0x0E, 0x12, 0x24, 0x19, 0x19, 0x15, 0x1D, 0x2B, 0x24, 0x2B, 0x2B, 0x27, 0x24,
+	0x27, 0x27, 0x2F, 0x32, 0x40, 0x39, 0x2F, 0x32, 0x3D, 0x32, 0x27, 0x27, 0x39, 0x4F, 0x39, 0x3D,
+	0x44, 0x48, 0x4B, 0x4B, 0x4B, 0x2B, 0x36, 0x52, 0x56, 0x4F, 0x48, 0x56, 0x40, 0x48, 0x4B, 0x48,
+	0x0B, 0x0E, 0x0E, 0x12, 0x0E, 0x12, 0x20, 0x12, 0x12, 0x20, 0x48, 0x2F, 0x27, 0x2F, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48,
+	0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48 
+};
+static __u8 qtable2[] = {	
+	0x09, 0x06, 0x06, 0x09, 0x06, 0x06, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x09, 0x09, 0x0C, 0x0F, 0x18,
+	0x0F, 0x0F, 0x0C, 0x0C, 0x0F, 0x1E, 0x15, 0x15, 0x12, 0x18, 0x24, 0x1E, 0x24, 0x24, 0x21, 0x1E,
+	0x21, 0x21, 0x27, 0x2A, 0x36, 0x30, 0x27, 0x2A, 0x33, 0x2A, 0x21, 0x21, 0x30, 0x42, 0x30, 0x33,
+	0x39, 0x3C, 0x3F, 0x3F, 0x3F, 0x24, 0x2D, 0x45, 0x48, 0x42, 0x3C, 0x48, 0x36, 0x3C, 0x3F, 0x3C,
+	0x09, 0x0C, 0x0C, 0x0F, 0x0C, 0x0F, 0x1B, 0x0F, 0x0F, 0x1B, 0x3C, 0x27, 0x21, 0x27, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
+	0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C 
+};
+#endif
+static __u8 qtable3[] = {	
+	0x07, 0x05, 0x05, 0x07, 0x05, 0x05, 0x07, 0x07, 0x07, 0x07, 0x0A, 0x07, 0x07, 0x0A, 0x0C, 0x14,
+	0x0C, 0x0C, 0x0A, 0x0A, 0x0C, 0x19, 0x11, 0x11, 0x0F, 0x14, 0x1E, 0x19, 0x1E, 0x1E, 0x1B, 0x19,
+	0x1B, 0x1B, 0x20, 0x23, 0x2D, 0x28, 0x20, 0x23, 0x2A, 0x23, 0x1B, 0x1B, 0x28, 0x37, 0x28, 0x2A,
+	0x2F, 0x32, 0x34, 0x34, 0x34, 0x1E, 0x25, 0x39, 0x3C, 0x37, 0x32, 0x3C, 0x2D, 0x32, 0x34, 0x32,
+	0x07, 0x0A, 0x0A, 0x0C, 0x0A, 0x0C, 0x16, 0x0C, 0x0C, 0x16, 0x32, 0x20, 0x1B, 0x20, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
+	0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32
+};
+#if 0
+static __u8 qtable4[] = {	
+	0x06, 0x04, 0x04, 0x06, 0x04, 0x04, 0x06, 0x06, 0x06, 0x06, 0x08, 0x06, 0x06, 0x08, 0x0A, 0x11,
+	0x0A, 0x0A, 0x08, 0x08, 0x0A, 0x15, 0x0F, 0x0F, 0x0C, 0x11, 0x19, 0x15, 0x19, 0x19, 0x17, 0x15,
+	0x17, 0x17, 0x1B, 0x1D, 0x25, 0x21, 0x1B, 0x1D, 0x23, 0x1D, 0x17, 0x17, 0x21, 0x2E, 0x21, 0x23,
+	0x27, 0x29, 0x2C, 0x2C, 0x2C, 0x19, 0x1F, 0x30, 0x32, 0x2E, 0x29, 0x32, 0x25, 0x29, 0x2C, 0x29,
+	0x06, 0x08, 0x08, 0x0A, 0x08, 0x0A, 0x13, 0x0A, 0x0A, 0x13, 0x29, 0x1B, 0x17, 0x1B, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
+	0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29 
+};
+static __u8 qtable5[] = {	
+	0x05, 0x03, 0x03, 0x05, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05, 0x07, 0x05, 0x05, 0x07, 0x09, 0x0E,
+	0x09, 0x09, 0x07, 0x07, 0x09, 0x11, 0x0C, 0x0C, 0x0A, 0x0E, 0x15, 0x11, 0x15, 0x15, 0x13, 0x11,
+	0x13, 0x13, 0x16, 0x18, 0x1F, 0x1C, 0x16, 0x18, 0x1D, 0x18, 0x13, 0x13, 0x1C, 0x26, 0x1C, 0x1D,
+	0x21, 0x23, 0x24, 0x24, 0x24, 0x15, 0x1A, 0x28, 0x29, 0x26, 0x23, 0x29, 0x1F, 0x23, 0x24, 0x23,
+	0x05, 0x07, 0x07, 0x09, 0x07, 0x09, 0x10, 0x09, 0x09, 0x10, 0x23, 0x16, 0x13, 0x16, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
+	0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23 
+};
+static __u8 qtable6[] = {	
+	 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x06, 0x04, 0x04, 0x06, 0x07, 0x0C,
+	 0x07, 0x07, 0x06, 0x06, 0x07, 0x0E, 0x0A, 0x0A, 0x09, 0x0C, 0x11, 0x0E, 0x11, 0x11, 0x10, 0x0E,
+	 0x10, 0x10, 0x13, 0x14, 0x1A, 0x17, 0x13, 0x14, 0x18, 0x14, 0x10, 0x10, 0x17, 0x20, 0x17, 0x18,
+	 0x1B, 0x1D, 0x1E, 0x1E, 0x1E, 0x11, 0x16, 0x21, 0x23, 0x20, 0x1D, 0x23, 0x1A, 0x1D, 0x1E, 0x1D,
+	 0x04, 0x06, 0x06, 0x07, 0x06, 0x07, 0x0D, 0x07, 0x07, 0x0D, 0x1D, 0x13, 0x10, 0x13, 0x1D, 0x1D,
+	 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
+	 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D,
+	 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D 
+};
+static __u8 qtable7[] = {	
+	 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x06, 0x0A,
+	 0x06, 0x06, 0x05, 0x05, 0x06, 0x0C, 0x08, 0x08, 0x07, 0x0A, 0x0E, 0x0C, 0x0E, 0x0E, 0x0D, 0x0C,
+	 0x0D, 0x0D, 0x10, 0x11, 0x16, 0x13, 0x10, 0x11, 0x14, 0x11, 0x0D, 0x0D, 0x13, 0x1A, 0x13, 0x14,
+	 0x17, 0x18, 0x19, 0x19, 0x19, 0x0E, 0x12, 0x1C, 0x1D, 0x1A, 0x18, 0x1D, 0x16, 0x18, 0x19, 0x18,
+	 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x0B, 0x06, 0x06, 0x0B, 0x18, 0x10, 0x0D, 0x10, 0x18, 0x18,
+	 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+	 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 
+};
+static __u8 qtable8[] = {	
+	 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x05, 0x08,
+	 0x05, 0x05, 0x04, 0x04, 0x05, 0x0A, 0x07, 0x07, 0x06, 0x08, 0x0C, 0x0A, 0x0C, 0x0C, 0x0B, 0x0A,
+	 0x0B, 0x0B, 0x0D, 0x0E, 0x12, 0x10, 0x0D, 0x0E, 0x11, 0x0E, 0x0B, 0x0B, 0x10, 0x16, 0x10, 0x11,
+	 0x13, 0x14, 0x15, 0x15, 0x15, 0x0C, 0x0F, 0x17, 0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15, 0x14,
+	 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14, 0x0D, 0x0B, 0x0D, 0x14, 0x14,
+	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
+	 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14 
+};
+#endif
+
+static int sn9c102p_i2cwrite (struct usb_spca50x *spca50x,__u8 *buffer,__u16 length)
+{
+	 struct usb_device *dev = spca50x->dev;
+	__u8 mode[] = {0x81,0x11,0,0,0,0,0,0x10};
+	/* is i2c ready */
+	__u8 i2cbase = spca50x->i2c_base;
+	__u8 i2cCtrl = spca50x->i2c_ctrl_reg;
+	mode[0] =i2cCtrl;
+	mode[1] = i2cbase;
+	if (length > 5 || !buffer) return -1;
+	mode[0] = mode[0] |length << 4 ;
+	memcpy(&mode[2],buffer,length);
+	sonixRegWrite(dev,0x08,0x08,0x0000,mode,8);	
+	return 0;
+}
+static void sn9c102p_i2cwritebuf (struct usb_device *dev,__u8 *buffer )
+{
+	sonixRegWrite(dev,0x08,0x08,0x0000,buffer,8);	
+}
+ static int sn9c102p_i2cread (struct usb_spca50x *spca50x,__u8 reg,__u8 *buffer,__u16 length)
+{
+	 struct usb_device *dev = spca50x->dev;
+	 __u8 i2cbase = spca50x->i2c_base;
+	 __u8 i2cCtrl = spca50x->i2c_ctrl_reg;
+	__u8 mode[] = {0x91,0x11,0,0,0,0,0,0x10};
+	__u8 result[] = {0,0,0,0,0};
+	mode[0] =i2cCtrl | 0x10;
+	mode[1] = i2cbase;
+	if (length > 5 || !buffer) return -1;
+	mode[2] = reg;
+	sonixRegWrite(dev,0x08,0x08,0x0000,mode,8);
+	wait_ms(1);
+	mode[2] = 0;
+	mode[0] = i2cCtrl | length << 4 | 0x02;
+	sonixRegWrite(dev,0x08,0x08,0x0000,mode,8);
+	wait_ms(1);
+	sonixRegRead(dev,0x00,0x0a,0x0000,result,5);
+	memcpy(buffer,result,length);
+	return 0;
+}
+
+
+static int sn9cxxx_probesensor(struct usb_spca50x *spca50x)
+{       struct usb_device *dev = spca50x->dev;
+	int err = 0;
+	__u8 reg02 = 0x66;
+	/* reg val1 val2 val3 val4 */
+	__u8 datasend[] = {0,0,0,0,0};
+	__u8 datarecd[] = {0,0,0,0,0};
+	datasend[0] = 2; //sensor wakeup
+	err = sn9c102p_i2cwrite (spca50x, datasend ,2);
+	//should write 0xa1 0x11 0x02 0x00 0x00 0x00 0x00 the 0x10 is add by i2cw
+	wait_ms(10);
+	sonixRegWrite(dev,0x08,0x02,0x0000,&reg02,1); //Gpio on
+	wait_ms(10);
+	err += sn9c102p_i2cread (spca50x,0, datarecd ,5); //read sensor id
+	if (err) goto errors;
+	if(datarecd[0] == 0x02 && datarecd[1] == 0x09 && datarecd[2] == 0x01 
+		&& datarecd[3] == 0x00 && datarecd[4] == 0x00){
+		PDEBUG(0,"Find Sensor sn9c102P HV7131R");
+		spca50x->sensor = SENSOR_HV7131R;
+		return SENSOR_HV7131R;
+		}
+	PDEBUG(0,"Find Sensor %d %d %d",datarecd[0],datarecd[1],datarecd[2]);
+	PDEBUG(0,"Sensor sn9c102P Not found Contact mxhaard@free.fr ");	
+	return -ENODEV;	
+errors:	PDEBUG(0,"Sensor sn9c102P too many errors Contact mxhaard@free.fr ");
+return -ENODEV;	
+}
+
+static void hv7131R_InitSensor(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	struct usb_device *dev = spca50x->dev;
+	__u8 CtrlA320[] = { 0xA1, 0x11, 0x01, 0x08, 0x00, 0x00, 0x00, 0x10 }; //Mclk
+	//__u8 CtrlA640[] = { 0xA1, 0x11, 0x01, 0x18, 0x00, 0x00, 0x00, 0x10 };//Mclk/2 BOUMM 
+	__u8 CtrlA640[] = { 0xA1, 0x11, 0x01, 0x28, 0x00, 0x00, 0x00, 0x10 }; //Mckl/4
+	while (hv7131r_sensor_init[i][0]){
+	sn9c102p_i2cwritebuf (dev,hv7131r_sensor_init[i]);
+	i++;
+	}
+	if(spca50x->mode)
+	 sn9c102p_i2cwritebuf (dev,CtrlA320);
+	else
+	 sn9c102p_i2cwritebuf (dev,CtrlA640);	
+}
+static void mi0360_InitSensor(struct usb_spca50x *spca50x)
+{
+	int i = 0;
+	struct usb_device *dev = spca50x->dev;
+	
+	while (mi0360_sensor_init[i][0]){
+	sn9c102p_i2cwritebuf (dev,hv7131r_sensor_init[i]);
+	i++;
+	}	
+}
+
+
+ static int sn9cxxx_init(struct usb_spca50x *spca50x)
+{	
+	struct usb_device *dev = spca50x->dev;
+	int err = 0;
+	__u8 *sn9c1xx= NULL;
+	__u8 regF1 = 0x01;
+	__u8 regGpio[] = {0x29,0x74};
+	__u8 data = 0x00;
+	/* setup a selector by customid */
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+	sn9c1xx= sn_hv7131;
+	break;
+	case SENSOR_MI0360:
+	sn9c1xx=sn_mi0360;
+	break;
+	}
+	if (sn9c1xx == NULL) return -ENODEV;
+	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
+	sonixRegRead(dev,0x00,0x00,0x0000,&regF1,1);
+	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
+	sonixRegRead(dev,0x00,0x00,0x0000,&regF1,1);
+	switch (spca50x->customid) {
+	case SN9C102P:
+		if (regF1 != 0x11)
+			return -ENODEV;
+		sonixRegWrite(dev,0x08,0x02,0x0000,&regGpio[1],1);
+	case SN9C105:
+		if (regF1 != 0x11)
+			return -ENODEV;
+		sonixRegWrite(dev,0x08,0x02,0x0000,regGpio,2);
+	break;
+	case SN9C120:
+		if (regF1 != 0x12)
+			return -ENODEV;
+			regGpio[1] = 0x70;
+		sonixRegWrite(dev,0x08,0x02,0x0000,regGpio,2);	
+	break;
+	}
+	
+	
+	
+	regF1 = 0x01;
+	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
+	
+	regF1 = 0x00;
+	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
+	
+	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c1xx[1],1);
+	
+	// configure gpio 
+	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c1xx[1],2);
+	
+	sonixRegWrite(dev,0x08,0x08,0x0000,&sn9c1xx[8],2);
+	
+	sonixRegWrite(dev,0x08,0x017,0x0000,&sn9c1xx[0x17],3);
+	
+	sonixRegWrite(dev,0x08,0x9a,0x0000,reg9a,6);
+	
+	data= 0x60;
+	sonixRegWrite(dev,0x08,0xD4,0x0000,&data,1);
+	
+	sonixRegWrite(dev,0x08,0x03,0x0000,&sn9c1xx[3],0x0f);
+	
+	data= 0x43;
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	
+	data= 0x61;
+	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
+	
+	data= 0x42;
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+	// probe sensor
+	if((err = sn9cxxx_probesensor(spca50x)) < 0)
+		return -ENODEV;			
+		break;
+	}
+	
+		
+return 0;
+}
+static void sn9cxxx_stop(struct usb_spca50x *spca50x)
+{ 
+	struct usb_device *dev = spca50x->dev;
+	__u8 stophv7131[] = { 0xA1, 0x11, 0x02, 0x09, 0x00, 0x00, 0x00, 0x10 };
+	__u8 stopmi0360[] = { 0xB1, 0x5D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10 };
+	__u8 regF1 = 0x01;
+	__u8 data = 0x0b;
+	__u8 *sn9c1xx=NULL;
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+	sn9c1xx= sn_hv7131;
+	data = 0x2b;
+	sn9c102p_i2cwritebuf (dev,stophv7131);
+	break;
+	case SENSOR_MI0360:
+	sn9c1xx=sn_mi0360;
+	data = 0x29;
+	sn9c102p_i2cwritebuf (dev,stopmi0360);
+	break;
+	}
+	if (sn9c1xx == NULL) return;
+	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c1xx[1],1);
+	sonixRegWrite(dev,0x08,0x17,0x0000,&sn9c1xx[0x17],1);
+	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c1xx[1],1);
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
+}
+static void sn9cxxx_start(struct usb_spca50x *spca50x)
+{	
+	struct usb_device *dev = spca50x->dev;
+	int i;
+	__u8 DC29[]={0x6a, 0x50, 0x00, 0x00, 0x50, 0x3c};
+	__u8 C0[]={0x2d, 0x2d, 0x3a, 0x05, 0x04, 0x3f};
+	__u8 CA[]={0x28, 0xd8, 0x14, 0xec };
+	//HV7131 __u8 CE[]={0x28, 0xec, 0x1e, 0xec };
+	__u8 CE[]={0x32, 0xdd, 0x2d, 0xdd };//MI0360
+	__u8 gain[] = { 0xB1,0x5D,0x35,0x00,0x67,0x00,0x00,0x10 }; //gain 
+	__u8 doit[] = { 0xB1,0x5D,0x07,0x00,0x03,0x00,0x00,0x10 }; //update sensor
+	__u8 sensorgo[] ={ 0xB1,0x5D,0x07,0x00,0x02,0x00,0x00,0x10 }; //sensor on
+	//__u8 expo[]={ 0xB1,0x5D,0x09,0x06,0x35,0x00,0x00,0x10 };// exposure 0x0635 -> 4 fp/s
+	__u8 data = 0;
+	__u8 regF1 = 0x00;
+	int err = 0;
+	__u8 *sn9c1xx = NULL;
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+	sn9c1xx= sn_hv7131;
+	break;
+	case SENSOR_MI0360:
+	sn9c1xx=sn_mi0360;
+	break;
+	}
+	if (sn9c1xx == NULL) return;
+	sonixRegWrite(dev,0x08,0xf1,0x0000,&regF1,1);
+	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c1xx[1],1);
+	sonixRegWrite(dev,0x08,0x01,0x0000,&sn9c1xx[1],2);
+	sonixRegWrite(dev,0x08,0x08,0x0000,&sn9c1xx[8],2);
+	sonixRegWrite(dev,0x08,0x17,0x0000,&sn9c1xx[0x17],3);
+	
+	sonixRegWrite(dev,0x08,0x9a,0x0000,reg9a,6);
+	data= 0x60;
+	sonixRegWrite(dev,0x08,0xD4,0x0000,&data,1);
+	
+	sonixRegWrite(dev,0x08,0x03,0x0000,&sn9c1xx[3],0x0f);
+	data= 0x43;
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	data= 0x61;
+	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
+	data= 0x42;
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+		if((err = sn9cxxx_probesensor(spca50x)) < 0)
+			return ;	
+		break;
+	}
+		
+	sonixRegWrite(dev,0x08,0x15,0x0000,&sn9c1xx[0x15],1);
+	sonixRegWrite(dev,0x08,0x16,0x0000,&sn9c1xx[0x16],1);
+	sonixRegWrite(dev,0x08,0x12,0x0000,&sn9c1xx[0x12],1);
+	sonixRegWrite(dev,0x08,0x13,0x0000,&sn9c1xx[0x13],1);
+	sonixRegWrite(dev,0x08,0x18,0x0000,&sn9c1xx[0x18],1);
+	sonixRegWrite(dev,0x08,0xd2,0x0000,&DC29[0],1);
+	sonixRegWrite(dev,0x08,0xd3,0x0000,&DC29[1],1);
+	sonixRegWrite(dev,0x08,0xc6,0x0000,&DC29[2],1);
+	sonixRegWrite(dev,0x08,0xc7,0x0000,&DC29[3],1);
+	sonixRegWrite(dev,0x08,0xc8,0x0000,&DC29[4],1);
+	sonixRegWrite(dev,0x08,0xc9,0x0000,&DC29[5],1);
+	sonixRegWrite(dev,0x08,0x18,0x0000,&sn9c1xx[0x18],1);
+	data = 0x60;
+	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
+	sonixRegWrite(dev,0x08,0x05,0x0000,&sn9c1xx[5],1);
+	sonixRegWrite(dev,0x08,0x07,0x0000,&sn9c1xx[7],1);
+	sonixRegWrite(dev,0x08,0x06,0x0000,&sn9c1xx[6],1);
+	sonixRegWrite(dev,0x08,0x14,0x0000,&sn9c1xx[0x14],1);
+	sonixRegWrite(dev,0x08,0x20,0x0000,regsn20,0x11);
+	for (i=0; i<8;i++)
+		sonixRegWrite(dev,0x08,0x84,0x0000,reg84,0x15);
+	data = 0x08;
+	sonixRegWrite(dev,0x08,0x9a,0x0000,&data,1);
+	data = 0x59;
+	sonixRegWrite(dev,0x08,0x99,0x0000,&data,1);
+	
+	switch(spca50x->sensor){
+		case SENSOR_HV7131R:
+			hv7131R_InitSensor(spca50x);
+		break;
+		case SENSOR_MI0360:
+			mi0360_InitSensor(spca50x);
+		break;
+	}
+	sonixRegWrite(dev,0x08,0xc0,0x0000,C0,6);
+	sonixRegWrite(dev,0x08,0xca,0x0000,CA,4);
+	sonixRegWrite(dev,0x08,0xce,0x0000,CE,4);//?? {0x1e,0xdd,0x2d,0xe7}
+	
+	// here change size mode 0 -> VGA; 1 -> CIF
+	data = 0x40 | sn9c1xx[0x18] | (spca50x->mode << 4 );
+	sonixRegWrite(dev,0x08,0x18,0x0000,&data,1);
+	
+	sonixRegWrite(dev,0x08,0x100,0x0000,qtable3,0x40);
+	sonixRegWrite(dev,0x08,0x140,0x0000,qtable3+0x40,0x40);
+		
+	data = sn9c1xx[0x18] |(spca50x->mode << 4 );
+	sonixRegWrite(dev,0x08,0x18,0x0000,&data,1);
+	data = 0x02;//0x42
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	data = 0x61;//0x61
+	sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
+	if (spca50x->mode)
+		data = 0x06; //320 06clk 12Mhz
+	else {
+		
+		if(spca50x->sensor == SENSOR_MI0360){
+			data = 0x65;//0x61
+			sonixRegWrite(dev,0x08,0x17,0x0000,&data,1);
+		}
+		data = 0x46; //640 clk 24Mz 46
+	}
+		// enable video on
+	sonixRegWrite(dev,0x08,0x01,0x0000,&data,1);
+	
+	 err = sn9cxxx_setbrightness(spca50x);
+	if(spca50x->sensor == SENSOR_MI0360){ 
+	/*FIXME Need to be in the brightness exposure setting */
+	 sn9c102p_i2cwritebuf (dev,gain);
+	 // sn9c102p_i2cwritebuf (dev,expo);
+	 sn9c102p_i2cwritebuf (dev,doit);
+	 sn9c102p_i2cwritebuf (dev,sensorgo);
+	 }
+	
+	 //sn9c102p_i2cwritebuf (dev,PreAInit);
+	 //sn9c102p_i2cwritebuf (dev,RInit);
+}
+
+static unsigned int sn9cxxx_getexposure(struct usb_spca50x *spca50x)
+{	__u8 expo[] = {0,0,0,0,0};
+	int err = 0;
+	switch (spca50x->sensor){
+	case SENSOR_HV7131R:
+	err += sn9c102p_i2cread (spca50x,0x25, expo ,5); //read sensor exposure
+	return (unsigned int) (expo[0] << 16 | expo[1] << 8 | expo[2]);
+	break;
+	case SENSOR_MI0360:
+	err += sn9c102p_i2cread (spca50x,0x09, expo ,5); //read sensor exposure
+	return (unsigned int) (expo[0] << 8 | expo[1] );
+	break;
+	}
+	return 0;
+}
+
+static unsigned int sn9cxxx_setexposure(struct usb_spca50x *spca50x,unsigned int expo)
+{	
+	__u8 Expodoit[] = { 0xc1, 0x11, 0x25, 0x07, 0x27, 0xc0, 0x00, 0x16 };
+	__u8 doit[] = { 0xB1,0x5D,0x07,0x00,0x03,0x00,0x00,0x10 }; //update sensor
+	__u8 sensorgo[] ={ 0xB1,0x5D,0x07,0x00,0x02,0x00,0x00,0x10 }; //sensor on
+	__u8 expoMi[]={ 0xB1,0x5D,0x09,0x06,0x35,0x00,0x00,0x10 };// exposure 0x0635 -> 4 fp/s
+	unsigned int expotimes = expo;
+	unsigned int expotimesret = 0;
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+		Expodoit[3] = (expotimes >> 16) & 0xff;
+		Expodoit[4] = (expotimes >> 8) & 0xff;
+		Expodoit[5] = (expotimes & 0xff) ;
+		sn9c102p_i2cwritebuf (spca50x->dev,Expodoit);
+		wait_ms(10);
+		expotimesret = sn9cxxx_getexposure(spca50x);
+		PDEBUG(3,"Exposure set %d ret %d ", expotimes,expotimesret);
+		return 	expotimesret;
+	break;
+	case SENSOR_MI0360:
+		if ( expo > 0x0635) expo = 0x0635;
+		if ( expo < 0x0100) expo = 0x0100;
+		expoMi[3]= (expo >> 8) & 0xFF;
+		expoMi[4] = expo & 0xff;
+	 	sn9c102p_i2cwritebuf (spca50x->dev,expoMi);
+	 	sn9c102p_i2cwritebuf (spca50x->dev,doit);
+	 	sn9c102p_i2cwritebuf (spca50x->dev,sensorgo);
+	 	expotimesret = sn9cxxx_getexposure(spca50x);
+	 	PDEBUG(3,"Exposure set %d ret %d ", expotimes,expotimesret);
+	 	return 	expotimesret;
+	break;
+	}
+	return 0;
+}
+	
+static __u16 sn9cxxx_setbrightness(struct usb_spca50x *spca50x)
+{	
+	unsigned int expo,expotimesret ;
+	__u8 k2;
+	switch(spca50x->sensor){
+	case SENSOR_HV7131R:
+	expo = spca50x->brightness << 4;
+	if (expo > 0x002dc6c0) expo = 0x002dc6c0;
+	if (expo < 0x02a0) expo = 0x02a0;
+	expotimesret = sn9cxxx_setexposure(spca50x,expo);
+	
+	break;
+	case SENSOR_MI0360:
+	expo = spca50x->brightness >> 4;
+	expotimesret = sn9cxxx_setexposure(spca50x,expo);
+	
+	break;
+	}
+	k2 = spca50x->brightness >> 10;
+	sonixRegWrite(spca50x->dev,0x08,0x96,0x0000,&k2,1);
+return 0;
+}
+
+static __u16 sn9cxxx_getbrightness(struct usb_spca50x *spca50x)
+{	
+	/* hardcoded registers seem not readable */
+		
+return spca50x->brightness = 0x7fff;
+}
+
+static __u16 sn9cxxx_setcontrast(struct usb_spca50x *spca50x)
+{
+	__u8 k2;
+	__u8 contrast[] = {0x14,0x00,0x28,0x00,0x07,0x00};
+	k2 = spca50x->contrast >> 8;
+	if (k2 > 0x7f) k2 = 0x7f;
+	contrast[2] = k2;
+	contrast[0] = (k2+1) >> 1;
+	contrast[4] = (k2+1) / 5 ;
+	sonixRegWrite(spca50x->dev,0x08,0x84,0x0000,contrast,6);
+	
+return 0;
+}
+static __u16 sn9cxxx_getcontrast(struct usb_spca50x *spca50x)
+{	
+	/* hardcoded registers seem not readable */
+	spca50x->contrast = 0x28 << 8;
+return 0;
+}
+static void set_sonixVGA(struct usb_spca50x *spca50x )
+{
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[VGA].width = 640;
+		spca50x->mode_cam[VGA].height = 480;		
+		spca50x->mode_cam[VGA].t_palette =  P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		if(spca50x->customid == SN9C102P || spca50x->customid == SN9C105 || spca50x->customid == SN9C120)
+			spca50x->mode_cam[VGA].t_palette |= P_JPEG;
+		spca50x->mode_cam[VGA].pipe = 1023;
+		spca50x->mode_cam[VGA].method = 0;
+		spca50x->mode_cam[VGA].mode = 0;
+		spca50x->mode_cam[PAL].width = 384;
+		spca50x->mode_cam[PAL].height = 288;
+		spca50x->mode_cam[PAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[PAL].pipe = 1023;
+		spca50x->mode_cam[PAL].method = 1;
+		spca50x->mode_cam[PAL].mode = 0;
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 1;
+		spca50x->mode_cam[SIF].mode = 0;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette =  P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		if(spca50x->customid == SN9C102P || spca50x->customid == SN9C105 || spca50x->customid == SN9C120)
+			spca50x->mode_cam[CIF].t_palette |= P_JPEG;
+		spca50x->mode_cam[CIF].pipe = 1023;
+		spca50x->mode_cam[CIF].method = 0;
+		spca50x->mode_cam[CIF].mode = 1;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 1023;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 1;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 1023;
+		spca50x->mode_cam[QSIF].method = 1;
+		spca50x->mode_cam[QSIF].mode = 1;
+		if(spca50x->customid == SN9C101 || spca50x->customid == SN9C102 || spca50x->customid == SN9C103){
+		spca50x->mode_cam[QCIF].width = 160;
+		spca50x->mode_cam[QCIF].height = 120;
+		spca50x->mode_cam[QCIF].t_palette =  P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QCIF].pipe = 1023;
+		spca50x->mode_cam[QCIF].method = 0;
+		spca50x->mode_cam[QCIF].mode = 2;
+		}
+}
+static void set_sonixSIF(struct usb_spca50x *spca50x )
+{
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette =  P_RAW |P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 0;
+		spca50x->mode_cam[SIF].mode = 0;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CIF].pipe = 1023;
+		spca50x->mode_cam[CIF].method = 1;
+		spca50x->mode_cam[CIF].mode = 0;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 1023;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 0;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_RAW |P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 1023;
+		spca50x->mode_cam[QSIF].method = 0;
+		spca50x->mode_cam[QSIF].mode = 1;
+		spca50x->mode_cam[QCIF].width = 160;
+		spca50x->mode_cam[QCIF].height = 120;
+		spca50x->mode_cam[QCIF].t_palette =  P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QCIF].pipe = 1023;
+		spca50x->mode_cam[QCIF].method = 1;
+		spca50x->mode_cam[QCIF].mode = 1;
+}
+static int sonix_config(struct usb_spca50x *spca50x)
+{
+	switch(spca50x->sensor){
+	case SENSOR_OV7630:
+	case SENSOR_TAS5130C:
+	case SENSOR_HV7131R:
+	case SENSOR_MI0360:
+	case SENSOR_PAS202:
+		set_sonixVGA(spca50x);
+	break;
+	case SENSOR_PAS106:
+	case SENSOR_TAS5110:
+		set_sonixSIF(spca50x);
+	break;
+	default:
+	return -EINVAL;
+	break;
+	}
+return 0;
+}
+#if 0
+static void sn9cxxx_setAutobright (struct usb_spca50x *spca50x)
+{ // GRR avg_lum from the header seem wrong set exposure on brightness instead
+ // FIXME where is the avg luma value ??	
+	unsigned int expotimes=0;
+	unsigned int expotimesret = 0;
+	
+	__u8 luma_mean = 110;
+	__u8 luma_delta = 20;
+	__u8 spring = 4; // 4 choice so the gain registers follow with a little retard
+	int delta;
+	spin_lock_irq(&spca50x->v4l_lock);
+	delta = spca50x->avg_lum ;
+	spin_unlock_irq(&spca50x->v4l_lock);
+	//PDEBUG(0,"Error setting exposure delta %d",delta);
+	
+	if((delta < (luma_mean - luma_delta)) ||
+		(delta > (luma_mean + luma_delta))){
+	expotimes = sn9cxxx_getexposure(spca50x);
+	expotimes += ((luma_mean - delta) >> spring); 
+	expotimesret = sn9cxxx_setexposure(spca50x,expotimes);
+	if (expotimes != expotimesret)
+		PDEBUG(0,"Error setting exposure !");
+	}
+	
+}
+
+static void sn9cxxx_shutdown(struct usb_spca50x *spca50x)
+{
+
+}
+
+#endif
+#endif //SONIXJPGUSB
diff -ruN usb_old/spca5xx/sp5xxfw2.dat usb/spca5xx/sp5xxfw2.dat
--- linux-2.4.31/drivers/usb_old/spca5xx/sp5xxfw2.dat	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/sp5xxfw2.dat	2005-11-21 19:33:02.000000000 +0100
@@ -0,0 +1,307 @@
+ 
+/* Initialisation data for the Creative PC-CAM 600 */
+static __u16 spca504_pccam600_init_data[][3] =
+{
+//	{0xa0, 0x0000, 0x0503}, /* capture mode */
+	{0x00, 0x0000, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+	{0x00, 0x0001, 0x21ac},
+	{0x00, 0x0001, 0x21a6},
+	{0x00, 0x0000, 0x21a7}, /* brightness */
+	{0x00, 0x0020, 0x21a8}, /* contrast */
+	{0x00, 0x0001, 0x21ac}, /* sat/hue */
+	{0x00, 0x0000, 0x21ad}, /* hue */
+	{0x00, 0x001a, 0x21ae}, /* saturation */
+	{0x00, 0x0002, 0x21a3}, /* gamma */
+#if 0	
+	{0xb0, 0x0000, 0x0000},	/* reset auto exposure */
+	{0x0c, 0x0000, 0x0000}, /* reset auto whiteness */
+	{0x0c, 0x0004, 0x0000}, /* enable auto whiteness */ 
+	{0x30, 0x020f, 0x0001}, /* exposure compensation */
+	{0x30, 0x01f7, 0x0002}, /* whiteness balance */
+#endif
+	{0x30, 0x0154, 0x0008},
+	{0x30, 0x0004, 0x0006},
+	{0x30, 0x0258, 0x0009},
+	{0x30, 0x0004, 0x0000},
+	{0x30, 0x0093, 0x0004},
+	{0x30, 0x0066, 0x0005},
+	{0x00, 0x0000, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+
+	{0,0,0}
+};
+
+/* Creative PC-CAM 600 specific open data, sent before using the
+ * generic initialisation data from spca504_open_data.
+ */
+static __u16 spca504_pccam600_open_data[][3] =
+{
+	{0x00, 0x0001, 0x2501},
+	{0x20, 0x0500, 0x0001}, /* snapshot mode */
+	{0x00, 0x0003, 0x2880},
+	{0x00, 0x0001, 0x2881},
+
+	{0,0,0}
+};
+/* Initialisation data for the logitech clicksmart 420 */
+static __u16 spca504A_clicksmart420_init_data[][3] =
+{
+//	{0xa0, 0x0000, 0x0503}, /* capture mode */
+	{0x00, 0x0000, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+	{0x00, 0x0001, 0x21ac},
+	{0x00, 0x0001, 0x21a6},
+	{0x00, 0x0000, 0x21a7}, /* brightness */
+	{0x00, 0x0020, 0x21a8}, /* contrast */
+	{0x00, 0x0001, 0x21ac}, /* sat/hue */
+	{0x00, 0x0000, 0x21ad}, /* hue */
+	{0x00, 0x001a, 0x21ae}, /* saturation */
+	{0x00, 0x0002, 0x21a3}, /* gamma */
+#if 1
+	{0x30, 0x0004, 0x000a},
+	{0xb0, 0x0001, 0x0000},
+#endif
+
+#if 0	
+	{0xb0, 0x0000, 0x0000},	/* reset auto exposure */
+	{0x0c, 0x0000, 0x0000}, /* reset auto whiteness */
+	{0x0c, 0x0004, 0x0000}, /* enable auto whiteness */ 
+	{0x30, 0x020f, 0x0001}, /* exposure compensation */
+	{0x30, 0x01f7, 0x0002}, /* whiteness balance */
+#endif
+
+#if 1
+	{0x0a1, 0x0080, 0x0001},
+	{0x30, 0x0049, 0x0000},
+	{0x30, 0x0060, 0x0005},
+	{0x0c, 0x0004, 0x0000},
+	{0x00, 0x0000, 0x0000},
+	{0x00, 0x0000, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+	{0x00, 0x0000, 0x2000},
+#endif
+
+#if 0	
+	{0x30, 0x0154, 0x0008},
+	{0x30, 0x0004, 0x0006},
+	{0x30, 0x0258, 0x0009},
+	{0x30, 0x0004, 0x0000},
+	{0x30, 0x0093, 0x0004},
+	{0x30, 0x0066, 0x0005},
+	{0x00, 0x0000, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+	{0x00, 0x0013, 0x2301},
+	{0x00, 0x0003, 0x2000},
+#endif
+
+	{0,0,0}
+};
+
+/* clicksmart 420 open data ? */
+static __u16 spca504A_clicksmart420_open_data[][3] =
+{
+	{0x00, 0x0001, 0x2501},
+	{0x20, 0x0502, 0x0000},
+	{0x06, 0x0000, 0x0000},
+	{0x00, 0x0004, 0x2880},
+	{0x00, 0x0001, 0x2881},
+
+	{0x00, 0x0006, 0x2800},
+	{0x00, 0x0004, 0x2801},
+	{0x00, 0x0004, 0x2802},
+	{0x00, 0x0006, 0x2803},
+	{0x00, 0x000a, 0x2804},
+	{0x00, 0x0010, 0x2805},
+	{0x00, 0x0014, 0x2806},
+	{0x00, 0x0018, 0x2807},
+	{0x00, 0x0005, 0x2808},
+	{0x00, 0x0005, 0x2809},
+	{0x00, 0x0006, 0x280a},
+	{0x00, 0x0008, 0x280b},
+	{0x00, 0x000a, 0x280c},
+	{0x00, 0x0017, 0x280d},
+	{0x00, 0x0018, 0x280e},
+	{0x00, 0x0016, 0x280f},
+
+	{0x00, 0x0006, 0x2810},
+	{0x00, 0x0005, 0x2811},
+	{0x00, 0x0006, 0x2812},
+	{0x00, 0x000a, 0x2813},
+	{0x00, 0x0010, 0x2814},
+	{0x00, 0x0017, 0x2815},
+	{0x00, 0x001c, 0x2816},
+	{0x00, 0x0016, 0x2817},
+	{0x00, 0x0006, 0x2818},
+	{0x00, 0x0007, 0x2819},
+	{0x00, 0x0009, 0x281a},
+	{0x00, 0x000c, 0x281b},
+	{0x00, 0x0014, 0x281c},
+	{0x00, 0x0023, 0x281d},
+	{0x00, 0x0020, 0x281e},
+	{0x00, 0x0019, 0x281f},
+
+	{0x00, 0x0007, 0x2820},
+	{0x00, 0x0009, 0x2821},
+	{0x00, 0x000f, 0x2822},
+	{0x00, 0x0016, 0x2823},
+	{0x00, 0x001b, 0x2824},
+	{0x00, 0x002c, 0x2825},
+	{0x00, 0x0029, 0x2826},
+	{0x00, 0x001f, 0x2827},
+	{0x00, 0x000a, 0x2828},
+	{0x00, 0x000e, 0x2829},
+	{0x00, 0x0016, 0x282a},
+	{0x00, 0x001a, 0x282b},
+	{0x00, 0x0020, 0x282c},
+	{0x00, 0x002a, 0x282d},
+	{0x00, 0x002d, 0x282e},
+	{0x00, 0x0025, 0x282f},
+
+	{0x00, 0x0014, 0x2830},
+	{0x00, 0x001a, 0x2831},
+	{0x00, 0x001f, 0x2832},
+	{0x00, 0x0023, 0x2833},
+	{0x00, 0x0029, 0x2834},
+	{0x00, 0x0030, 0x2835},
+	{0x00, 0x0030, 0x2836},
+	{0x00, 0x0028, 0x2837},
+	{0x00, 0x001d, 0x2838},
+	{0x00, 0x0025, 0x2839},
+	{0x00, 0x0026, 0x283a},
+	{0x00, 0x0027, 0x283b},
+	{0x00, 0x002d, 0x283c},
+	{0x00, 0x0028, 0x283d},
+	{0x00, 0x0029, 0x283e},
+	{0x00, 0x0028, 0x283f},
+
+	{0x00, 0x0007, 0x2840},
+	{0x00, 0x0007, 0x2841},
+	{0x00, 0x000a, 0x2842},
+	{0x00, 0x0013, 0x2843},
+	{0x00, 0x0028, 0x2844},
+	{0x00, 0x0028, 0x2845},
+	{0x00, 0x0028, 0x2846},
+	{0x00, 0x0028, 0x2847},
+	{0x00, 0x0007, 0x2848},
+	{0x00, 0x0008, 0x2849},
+	{0x00, 0x000a, 0x284a},
+	{0x00, 0x001a, 0x284b},
+	{0x00, 0x0028, 0x284c},
+	{0x00, 0x0028, 0x284d},
+	{0x00, 0x0028, 0x284e},
+	{0x00, 0x0028, 0x284f},
+
+	{0x00, 0x000a, 0x2850},
+	{0x00, 0x000a, 0x2851},
+	{0x00, 0x0016, 0x2852},
+	{0x00, 0x0028, 0x2853},
+	{0x00, 0x0028, 0x2854},
+	{0x00, 0x0028, 0x2855},
+	{0x00, 0x0028, 0x2856},
+	{0x00, 0x0028, 0x2857},
+	{0x00, 0x0013, 0x2858},
+	{0x00, 0x001a, 0x2859},
+	{0x00, 0x0028, 0x285a},
+	{0x00, 0x0028, 0x285b},
+	{0x00, 0x0028, 0x285c},
+	{0x00, 0x0028, 0x285d},
+	{0x00, 0x0028, 0x285e},
+	{0x00, 0x0028, 0x285f},
+
+	{0x00, 0x0028, 0x2860},
+	{0x00, 0x0028, 0x2861},
+	{0x00, 0x0028, 0x2862},
+	{0x00, 0x0028, 0x2863},
+	{0x00, 0x0028, 0x2864},
+	{0x00, 0x0028, 0x2865},
+	{0x00, 0x0028, 0x2866},
+	{0x00, 0x0028, 0x2867},
+	{0x00, 0x0028, 0x2868},
+	{0x00, 0x0028, 0x2869},
+	{0x00, 0x0028, 0x286a},
+	{0x00, 0x0028, 0x286b},
+	{0x00, 0x0028, 0x286c},
+	{0x00, 0x0028, 0x286d},
+	{0x00, 0x0028, 0x286e},
+	{0x00, 0x0028, 0x286f},
+
+	{0x00, 0x0028, 0x2870},
+	{0x00, 0x0028, 0x2871},
+	{0x00, 0x0028, 0x2872},
+	{0x00, 0x0028, 0x2873},
+	{0x00, 0x0028, 0x2874},
+	{0x00, 0x0028, 0x2875},
+	{0x00, 0x0028, 0x2876},
+	{0x00, 0x0028, 0x2877},
+	{0x00, 0x0028, 0x2878},
+	{0x00, 0x0028, 0x2879},
+	{0x00, 0x0028, 0x287a},
+	{0x00, 0x0028, 0x287b},
+	{0x00, 0x0028, 0x287c},
+	{0x00, 0x0028, 0x287d},
+	{0x00, 0x0028, 0x287e},
+	{0x00, 0x0028, 0x287f},
+
+	{0xa0, 0x0000, 0x0503},
+
+	{0,0,0}
+};
+static unsigned char qtable_creative_pccam[2][64] =
+{
+  { /* Q-table Y-components */
+    0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,
+    0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,
+    0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,
+    0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,
+    0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,
+    0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,
+    0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,
+    0x16, 0x1c, 0x1d, 0x1d, 0x22, 0x1e, 0x1f, 0x1e
+  },
+  { /* Q-table C-components */
+    0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e
+  }
+};
+
+/* FIXME: This Q-table is identical to the Creative PC-CAM one,
+ *        except for one byte. Possibly a typo?
+ *        NWG: 18/05/2003.
+ */
+static unsigned char qtable_spca504_default[2][64] =
+{ 
+  { /* Q-table Y-components */
+    0x05, 0x03, 0x03, 0x05, 0x07, 0x0c, 0x0f, 0x12,
+    0x04, 0x04, 0x04, 0x06, 0x08, 0x11, 0x12, 0x11,
+    0x04, 0x04, 0x05, 0x07, 0x0c, 0x11, 0x15, 0x11,
+    0x04, 0x05, 0x07, 0x09, 0x0f, 0x1a, 0x18, 0x13,
+    0x05, 0x07, 0x0b, 0x11, 0x14, 0x21, 0x1f, 0x17,
+    0x07, 0x0b, 0x11, 0x13, 0x18, 0x1f, 0x22, 0x1c,
+    0x0f, 0x13, 0x17, 0x1a, 0x1f, 0x24, 0x24, 0x1e,
+    0x16, 0x1c, 0x1d, 0x1d, 0x1d /* 0x22 */, 0x1e, 0x1f, 0x1e,
+  },
+  { /* Q-table C-components */
+    0x05, 0x05, 0x07, 0x0e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x05, 0x06, 0x08, 0x14, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x07, 0x08, 0x11, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x0e, 0x14, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
+    0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e
+  }
+};
diff -ruN usb_old/spca5xx/sp5xxfw2.h usb/spca5xx/sp5xxfw2.h
--- linux-2.4.31/drivers/usb_old/spca5xx/sp5xxfw2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/sp5xxfw2.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,733 @@
+#ifndef SP5XXFW2_H
+#define SP5XXFW2_H
+/****************************************************************************
+#	 	Sunplus spca504(abc) spca533 spca536  library               #
+# 		Copyright (C) 2005 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+#define SPCA504_PCCAM600_OFFSET_SNAPSHOT 3
+#define SPCA504_PCCAM600_OFFSET_COMPRESS 4
+#define SPCA504_PCCAM600_OFFSET_MODE	 5
+#define SPCA504_PCCAM600_OFFSET_DATA	 14
+ /* Frame packet header offsets for the spca533 */
+#define SPCA533_OFFSET_DATA      16
+#define SPCA533_OFFSET_FRAMSEQ	15
+/* Frame packet header offsets for the spca536 */
+#define SPCA536_OFFSET_DATA      4
+#define SPCA536_OFFSET_FRAMSEQ	 1
+#include "sp5xxfw2.dat"
+static int sp5xxfw2_init(struct usb_spca50x *spca50x);
+static void sp5xxfw2_start(struct usb_spca50x *spca50x);
+static void sp5xxfw2_stop(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_setbrightness(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_getbrightness(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_setcontrast(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_getcontrast(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_setcolors(struct usb_spca50x *spca50x);
+static __u16 sp5xxfw2_getcolors(struct usb_spca50x *spca50x);
+//static __u16 sp5xxfw2_setexposure(struct usb_spca50x *spca50x);
+//static __u16 sp5xxfw2_getexposure(struct usb_spca50x *spca50x);
+//static void spca5xxx_setAutobright (struct usb_spca50x *spca50x);
+static int sp5xxfw2_config(struct usb_spca50x *spca50x);
+//static void sp5xxfw2_shutdown(struct usb_spca50x *spca50x);
+/************************** Private *************************/ 
+
+static void
+spca504B_SetSizeType(struct usb_spca50x *spca50x );
+
+static void
+spca504_acknowledged_command(struct usb_spca50x *spca50x, 
+                                         __u16               reg,
+                                         __u16               idx,
+                                         __u16               val);
+					 
+static void
+spca504A_acknowledged_command(struct usb_spca50x *spca50x, 
+				 __u16 reg,
+				 __u16 idx,
+				 __u16 val,
+				 __u8 stat,
+				 __u8 count);
+static void
+spca504_wait_status(struct usb_spca50x *spca50x);
+static void
+spca50x_GetFirmware(struct usb_spca50x *spca50x);
+static int
+spca504B_PollingDataReady(struct usb_device *dev);
+static void
+spca504B_WaitCmdStatus(struct usb_spca50x *spca50x);
+static void
+spca504B_setQtable ( struct usb_spca50x *spca50x );
+static void 
+sp5xx_initContBrigHueRegisters (struct usb_spca50x *spca50x);
+/************************************************************/
+static int sp5xxfw2_init(struct usb_spca50x *spca50x)
+{	int rc ;
+	__u8 Data = 0;
+	__u8 i;
+	__u8 info[6];
+	int err_code;	
+	switch (spca50x->bridge){
+	case BRIDGE_SPCA504B:{
+		spca5xxRegWrite(spca50x->dev,0x1d ,0 ,0 ,NULL,0 );	
+		spca5xxRegWrite(spca50x->dev,0,1 ,0x2306 ,NULL ,0 );
+		spca5xxRegWrite(spca50x->dev,0,0 ,0x0d04 ,NULL ,0 );
+		spca5xxRegWrite(spca50x->dev,0,0 ,0x2000 ,NULL ,0 );
+		spca5xxRegWrite(spca50x->dev,0,0x13 ,0x2301 ,NULL ,0 );
+		spca5xxRegWrite(spca50x->dev,0,0 ,0x2306 ,NULL ,0 );
+	} // becare no break here init follow
+	case BRIDGE_SPCA533: 	
+		rc = spca504B_PollingDataReady ( spca50x->dev );
+		spca50x_GetFirmware( spca50x );
+	break;
+	case BRIDGE_SPCA536:
+		spca50x_GetFirmware( spca50x );
+		spca5xxRegRead(spca50x->dev,0x00 ,0 ,0x5002 , &Data ,1);
+		Data = 0;
+		spca5xxRegWrite(spca50x->dev,0x24 ,0 ,0 ,&Data ,1 );
+		spca5xxRegRead(spca50x->dev,0x24 ,0 ,0 , &Data ,1);
+		rc = spca504B_PollingDataReady( spca50x->dev );
+		spca5xxRegWrite(spca50x->dev,0x34 ,0 ,0 ,NULL ,0 );
+		spca504B_WaitCmdStatus(spca50x);	
+	break;
+	case BRIDGE_SPCA504C: //pccam600
+	PDEBUG (2, "Opening SPCA504 (PC-CAM 600)");
+	spca50x_reg_write (spca50x->dev, 0xe0, 0x0000, 0x0000);
+	spca50x_reg_write (spca50x->dev, 0xe0, 0x0000, 0x0001);	// reset
+	spca504_wait_status (spca50x);
+	if (spca50x->desc == LogitechClickSmart420)
+	  {			/* clicksmart 420 */
+	    spca50x_write_vector (spca50x, spca504A_clicksmart420_open_data);
+	  }
+	else
+	  {
+	    spca50x_write_vector (spca50x, spca504_pccam600_open_data);
+	  }
+	err_code = spca50x_setup_qtable (spca50x,
+					 0x00, 0x2800,
+					 0x2840, qtable_creative_pccam);
+	if (err_code < 0)
+	  {
+	    PDEBUG (2, "spca50x_setup_qtable failed");
+	    return err_code;
+	  }
+	break;
+	case BRIDGE_SPCA504:
+	PDEBUG (2, "Opening SPCA504");
+	if (spca50x->desc == AiptekMiniPenCam13)
+	  {
+	  /***************************************************************/
+	  for (i=0; i<6; i++)
+		{
+			info[i]=spca50x_reg_read_with_value(spca50x->dev,
+			                                    0x20, i, 0x0000, 1);
+		}
+		PDEBUG(0, "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
+		       info[0], info[1], info[2], info[3], info[4], info[5]);
+					/* spca504a aiptek */
+			// Set AE AWB Banding Type 3-> 50Hz 2-> 60Hz 	       
+			spca504A_acknowledged_command(spca50x, 0x24, 8, 3,0x9e,1);
+			// Twice sequencial need status 0xff->0x9e->0x9d 
+			spca504A_acknowledged_command(spca50x, 0x24, 8, 3,0x9e,0);
+
+			spca504A_acknowledged_command(spca50x, 0x24, 0, 0,0x9d,1);
+	/**************************************************************/
+	    /* spca504a aiptek */
+spca504A_acknowledged_command (spca50x, 0x08, 6, 0, 0x86, 1);
+	   // spca50x_reg_write (spca50x->dev, 0, 0x2000, 0);
+	   // spca50x_reg_write (spca50x->dev, 0, 0x2883, 1);
+	   // spca504A_acknowledged_command (spca50x, 0x08, 6, 0, 0x86, 1);
+	    //spca504A_acknowledged_command (spca50x, 0x24, 0, 0, 0x9D, 1);
+spca50x_reg_write(spca50x->dev, 0x0, 0x270c, 0x5); // L92 sno1t.txt 
+spca50x_reg_write(spca50x->dev, 0x0, 0x2310, 0x5);
+	    spca504A_acknowledged_command (spca50x, 1, 0x0f, 0, 0xFF, 0);
+	  }
+	/* setup qtable */
+spca50x_reg_write (spca50x->dev, 0, 0x2000, 0);
+spca50x_reg_write (spca50x->dev, 0, 0x2883, 1);
+	err_code = spca50x_setup_qtable (spca50x,
+					 0x00, 0x2800,
+					 0x2840, qtable_spca504_default);
+	if (err_code < 0)
+	  {
+	    PDEBUG (2, "spca50x_setup_qtable failed");
+	    return err_code;
+	  }
+	break;
+	}
+return 0;
+}
+static void sp5xxfw2_start(struct usb_spca50x *spca50x)
+{	
+	int rc;
+	int enable;
+	__u8 i;
+	__u8 info[6];
+	if(spca50x->bridge == BRIDGE_SPCA504B)
+		spca504B_setQtable ( spca50x );
+	spca504B_SetSizeType(spca50x);
+	switch (spca50x->bridge){
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA536:
+	if(spca50x->desc == MegapixV4 ||
+	   spca50x->desc == LogitechClickSmart820){
+		spca5xxRegWrite(spca50x->dev,0xF0 ,0 ,0 ,NULL ,0 );
+		spca504B_WaitCmdStatus( spca50x );
+		spca5xxRegRead(spca50x->dev,0xF0 ,0 ,4 ,NULL ,0 );
+		spca504B_WaitCmdStatus( spca50x );
+	} else {
+		spca5xxRegWrite(spca50x->dev,0x31,0 ,4 ,NULL ,0 );
+		spca504B_WaitCmdStatus( spca50x );
+		rc = spca504B_PollingDataReady(spca50x->dev );
+	}
+	break;
+	case BRIDGE_SPCA504:
+	if (spca50x->desc == AiptekMiniPenCam13){
+		for (i=0; i<6; i++)
+		{
+			info[i]=spca50x_reg_read_with_value(spca50x->dev,
+			                                    0x20, i, 0x0000, 1);
+		}
+		PDEBUG(0, "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
+		       info[0], info[1], info[2], info[3], info[4], info[5]);
+					/* spca504a aiptek */
+			// Set AE AWB Banding Type 3-> 50Hz 2-> 60Hz 	       
+			spca504A_acknowledged_command(spca50x, 0x24, 8, 3,0x9e,1);
+			// Twice sequencial need status 0xff->0x9e->0x9d 
+			spca504A_acknowledged_command(spca50x, 0x24, 8, 3,0x9e,0);
+
+			spca504A_acknowledged_command(spca50x, 0x24, 0, 0,0x9d,1);
+		} else {
+			spca504_acknowledged_command(spca50x, 0x24, 8, 3);
+			for (i=0; i<6; i++)
+			{
+			info[i]=spca50x_reg_read_with_value(spca50x->dev,
+			                                    0x20, i, 0x0000, 1);
+			}
+			PDEBUG(0, "Read info: %d %d %d %d %d %d . Should be 1,0,2,2,0,0\n",
+		       info[0], info[1], info[2], info[3], info[4], info[5]);
+			spca504_acknowledged_command(spca50x, 0x24, 8, 3);
+
+			spca504_acknowledged_command(spca50x, 0x24, 0, 0);
+		}
+		
+		spca504B_SetSizeType(spca50x);
+		spca50x_reg_write(spca50x->dev, 0x0, 0x270c, 0x5); // L92 sno1t.txt 
+
+		spca50x_reg_write(spca50x->dev, 0x0, 0x2310, 0x5);
+	break;
+	case BRIDGE_SPCA504C:
+	if (spca50x->desc == LogitechClickSmart420) {
+			spca50x_write_vector(spca50x, spca504A_clicksmart420_init_data);
+		} else {
+			spca50x_write_vector(spca50x, spca504_pccam600_init_data);
+		}
+		enable = (autoexpo ? 0x4 : 0x1);
+		spca50x_reg_write(spca50x->dev, 0x0c, 0x0000, enable); // auto exposure
+		spca50x_reg_write(spca50x->dev, 0xb0, 0x0000, enable); // auto whiteness
+		
+		/* set default exposure compensation and whiteness balance */
+		spca50x_reg_write(spca50x->dev, 0x30, 0x0001, 800); // ~ 20 fps
+		spca50x_reg_write(spca50x->dev, 0x30, 0x0002, 1600);
+		spca504B_SetSizeType(spca50x);
+	break;
+	}
+	sp5xx_initContBrigHueRegisters (spca50x);	
+}
+static void sp5xxfw2_stop(struct usb_spca50x *spca50x)
+{
+	int rc ;
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA536:
+	case BRIDGE_SPCA504B:
+		spca5xxRegWrite(spca50x->dev,0x31,0 ,0 ,NULL ,0 );
+		spca504B_WaitCmdStatus(spca50x);
+		rc = spca504B_PollingDataReady(spca50x->dev);
+	break;
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	spca50x_reg_write (spca50x->dev, 0x00, 0x2000, 0x0000);
+
+      if (spca50x->desc == AiptekMiniPenCam13)
+	{
+	  /* spca504a aiptek */
+	 // spca504A_acknowledged_command (spca50x, 0x08, 6, 0, 0x86, 1);
+	 spca504A_acknowledged_command (spca50x, 0x24, 0x0000, 0x0000, 0x9d,					 1);
+	 spca504A_acknowledged_command (spca50x, 0x01, 0x000f, 0x0000, 0xFF,
+					 1);
+	}
+      else
+	{
+	  spca504_acknowledged_command (spca50x, 0x24, 0x0000, 0x0000);
+	  spca50x_reg_write (spca50x->dev, 0x01, 0x000f, 0x0);
+	}
+	break;
+	}
+}
+static __u16 sp5xxfw2_setbrightness(struct usb_spca50x *spca50x)
+{
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	spca50x_reg_write (spca50x->dev, 0x0, 0x21a7, (spca50x->brightness >> 8));
+	break;
+	case BRIDGE_SPCA536:
+	spca50x_reg_write (spca50x->dev, 0x0, 0x20f0, (spca50x->brightness >>8));
+	break;
+	}
+	return 0;
+}
+static __u16 sp5xxfw2_getbrightness(struct usb_spca50x *spca50x)
+{
+	__u16 brightness = 0;
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	brightness = spca50x_reg_read (spca50x->dev, 0x0, 0x21a7, 2);
+	spca50x->brightness = (((brightness & 0xFF) - 128) % 255) << 8;	
+	break;
+	case BRIDGE_SPCA536:
+	brightness = spca50x_reg_read (spca50x->dev, 0x0, 0x20f0, 2);
+	spca50x->brightness = (((brightness & 0xFF) - 128) % 255) << 8;
+	break;
+	}
+	return (((brightness & 0xFF) - 128) % 255) << 8;
+}
+static __u16 sp5xxfw2_setcontrast(struct usb_spca50x *spca50x)
+{	
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	spca50x_reg_write (spca50x->dev, 0x0, 0x21a8,
+				     spca50x->contrast >> 8);
+	break;
+	case BRIDGE_SPCA536:
+	spca50x_reg_write (spca50x->dev, 0x0, 0x20f1,
+				     spca50x->contrast >> 8);
+	break;
+	}
+	return 0;
+}
+static __u16 sp5xxfw2_getcontrast(struct usb_spca50x *spca50x)
+{
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	spca50x->contrast =
+		    spca50x_reg_read (spca50x->dev, 0x0, 0x21a8, 2) << 8;
+	break;
+	case BRIDGE_SPCA536:
+	spca50x->contrast =
+		    spca50x_reg_read (spca50x->dev, 0x0, 0x20f1, 2) << 8;
+	break;
+	}
+	return spca50x->contrast;
+}
+static __u16 sp5xxfw2_setcolors(struct usb_spca50x *spca50x)
+{
+switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	spca50x_reg_write (spca50x->dev, 0x0, 0x21ae,
+				     spca50x->colour >> 8);
+	break;
+	case BRIDGE_SPCA536:
+	spca50x_reg_write(spca50x->dev, 0x0, 0x20f6,
+				     spca50x->colour >> 8);
+	break;
+	}
+return 0;
+}
+
+
+static __u16 sp5xxfw2_getcolors(struct usb_spca50x *spca50x)
+{
+switch (spca50x->bridge) {
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+	spca50x->colour =
+		    spca50x_reg_read (spca50x->dev, 0x0, 0x21ae, 2) << 7;
+	break;
+	case BRIDGE_SPCA536:
+	spca50x->colour =
+		    spca50x_reg_read (spca50x->dev, 0x0, 0x20f6, 2) << 7;
+	break;
+	}
+return spca50x->colour;
+}
+static int sp5xxfw2_config(struct usb_spca50x *spca50x)
+{
+	switch (spca50x->bridge){
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA536:
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[VGA].width = 640;
+		spca50x->mode_cam[VGA].height = 480;
+		spca50x->mode_cam[VGA].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[VGA].pipe = 1023;
+		spca50x->mode_cam[VGA].method = 0;
+		spca50x->mode_cam[VGA].mode = 1;
+		spca50x->mode_cam[PAL].width = 384;
+		spca50x->mode_cam[PAL].height = 288;
+		spca50x->mode_cam[PAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[PAL].pipe = 1023;
+		spca50x->mode_cam[PAL].method = 1;
+		spca50x->mode_cam[PAL].mode = 1;
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 1;
+		spca50x->mode_cam[SIF].mode = 1;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CIF].pipe = 896;
+		spca50x->mode_cam[CIF].method = 0;
+		spca50x->mode_cam[CIF].mode = 2;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 896;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 2;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 896;
+		spca50x->mode_cam[QSIF].method = 1;
+		spca50x->mode_cam[QSIF].mode = 2;
+	break;
+	case BRIDGE_SPCA533:
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[CUSTOM].width = 464;
+		spca50x->mode_cam[CUSTOM].height = 480;
+		spca50x->mode_cam[CUSTOM].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CUSTOM].pipe = 1023;
+		spca50x->mode_cam[CUSTOM].method = 0;
+		spca50x->mode_cam[CUSTOM].mode = 1;
+		spca50x->mode_cam[PAL].width = 384;
+		spca50x->mode_cam[PAL].height = 288;
+		spca50x->mode_cam[PAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[PAL].pipe = 1023;
+		spca50x->mode_cam[PAL].method = 1;
+		spca50x->mode_cam[PAL].mode = 1;
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 1;
+		spca50x->mode_cam[SIF].mode = 1;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CIF].pipe = 1023;
+		spca50x->mode_cam[CIF].method = 0;
+		spca50x->mode_cam[CIF].mode = 2;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 1023;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 2;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 1023;
+		spca50x->mode_cam[QSIF].method = 1;
+		spca50x->mode_cam[QSIF].mode = 2;
+	break;
+	case BRIDGE_SPCA504C:
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[VGA].width = 640;
+		spca50x->mode_cam[VGA].height = 480;
+		spca50x->mode_cam[VGA].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[VGA].pipe = 1023;
+		spca50x->mode_cam[VGA].method = 0;
+		spca50x->mode_cam[VGA].mode = 1;
+		spca50x->mode_cam[PAL].width = 384;
+		spca50x->mode_cam[PAL].height = 288;
+		spca50x->mode_cam[PAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[PAL].pipe = 1023;
+		spca50x->mode_cam[PAL].method = 1;
+		spca50x->mode_cam[PAL].mode = 1;
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 0;
+		spca50x->mode_cam[SIF].mode = 2;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CIF].pipe = 896;
+		spca50x->mode_cam[CIF].method = 0;
+		spca50x->mode_cam[CIF].mode = 3;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 896;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 3;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 768;
+		spca50x->mode_cam[QSIF].method = 0;
+		spca50x->mode_cam[QSIF].mode = 4;
+	break;
+	}
+return 0;
+}
+/****************************************************************************************/
+static void
+spca504B_SetSizeType(struct usb_spca50x *spca50x )
+{
+	__u8 Size ;
+	__u8 Type ;
+	int rc;
+	Size = spca50x->mode;
+	Type = 0;
+	switch (spca50x->bridge) {
+	case BRIDGE_SPCA533: {
+		spca5xxRegWrite(spca50x->dev,0x31,0 ,0 ,NULL ,0 );
+		spca504B_WaitCmdStatus(spca50x);
+		rc = spca504B_PollingDataReady(spca50x->dev);
+		spca50x_GetFirmware( spca50x );
+		
+		Type = 2;
+		spca5xxRegWrite(spca50x->dev,0x24,0 ,8 ,&Type ,1 );
+		spca5xxRegRead(spca50x->dev,0x24,0 ,8 ,&Type ,1 );
+	
+		spca5xxRegWrite(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
+		spca5xxRegRead(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
+		rc = spca504B_PollingDataReady(spca50x->dev );	
+	
+		/* Init the cam width height with some values get on init ?*/
+		spca5xxRegWrite(spca50x->dev,0x31,0 ,4 ,NULL ,0 );
+		spca504B_WaitCmdStatus( spca50x );
+		rc = spca504B_PollingDataReady(spca50x->dev );	
+	
+	}
+	break;
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA536:
+	{
+		Type = 6;
+		spca5xxRegWrite(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
+		spca5xxRegRead(spca50x->dev,0x25,0 ,4 ,&Size ,1 );
+		spca5xxRegWrite(spca50x->dev,0x27,0 ,0 ,&Type ,1 );
+		spca5xxRegRead(spca50x->dev,0x27,0 ,0 ,&Type ,1 );
+		
+		rc = spca504B_PollingDataReady ( spca50x->dev );
+	}
+	break;
+	case BRIDGE_SPCA504:
+	Size += 3;
+	if (spca50x->desc == AiptekMiniPenCam13)
+	{
+	  /* spca504a aiptek */
+	  spca504A_acknowledged_command (spca50x, 0x8, Size, 0,
+					 (0x80 | (Size & 0x0F)), 1);
+	  spca504A_acknowledged_command (spca50x, 1, 3, 0, 0x9F, 0);
+	}
+      else
+	{
+	  spca504_acknowledged_command (spca50x, 0x8, Size, 0);
+	}
+	break;
+	case BRIDGE_SPCA504C:
+		spca50x_reg_write (spca50x->dev, 0xa0, (0x0500 | (Size & 0x0F)), 0x0);	// capture mode
+      		spca50x_reg_write (spca50x->dev, 0x20, 0x1, (0x0500 | (Size & 0x0F)));
+	break;
+	}
+	return ;
+}
+static void
+spca504_acknowledged_command(struct usb_spca50x *spca50x, 
+				 __u16 reg,
+				 __u16 idx,
+				 __u16 val) 
+{ 
+	__u8 notdone = 0;
+
+	spca50x_reg_write(spca50x->dev,reg,idx,val);
+	notdone=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+	spca50x_reg_write(spca50x->dev,reg,idx,val);
+
+	PDEBUG(5,"before wait 0x%x",notdone);
+
+	wait_ms(200);
+	notdone=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+	PDEBUG(5,"after wait 0x%x",notdone);
+	
+	return;
+}
+
+static void
+spca504A_acknowledged_command(struct usb_spca50x *spca50x, 
+				 __u16 reg,
+				 __u16 idx,
+				 __u16 val,
+				 __u8 stat,
+				 __u8 count) 
+{ 
+	__u8  status ;
+	__u8  endcode;
+	
+
+	spca50x_reg_write(spca50x->dev,reg,idx,val);
+	status=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+	endcode = stat ;
+	PDEBUG(5,"Status 0x%x Need 0x%x",status, stat);
+	if (count) {
+		while (1){
+			wait_ms(10);
+			/* gsmart mini2 write a each wait setting 1 ms is enought*/
+			//spca50x_reg_write(spca50x->dev,reg,idx,val);
+			status=spca50x_reg_read(spca50x->dev, 0x01, 0x0001, 1);
+			if (status == endcode) {
+				 PDEBUG(5,"status 0x%x after wait 0x%x",status,count);
+				break;
+			}
+			count++;
+			if(count > 200) break;
+		
+		}
+	}
+	return;
+}
+static void
+spca504_wait_status(struct usb_spca50x *spca50x)
+{
+	int ret = 256;
+	do {
+		/* With this we get the status, when return 0 it's all ok */
+		ret = spca50x_reg_read(spca50x->dev, 0x06, 0x00, 1);
+	} while(ret--);
+}
+static void
+spca50x_GetFirmware(struct usb_spca50x *spca50x)
+{	__u8 FW[5] = {0,0,0,0,0};
+	__u8 ProductInfo[64];
+	
+	spca5xxRegRead(spca50x->dev,0x20 ,0 ,0 ,FW ,5);
+	PDEBUG(0, "FirmWare : %d %d %d %d %d ", FW[0],FW[1],FW[2],FW[3],FW[4] );
+	spca5xxRegRead(spca50x->dev,0x23 ,0 ,0 ,ProductInfo ,64);
+	spca5xxRegRead(spca50x->dev,0x23 ,0 ,1 ,ProductInfo ,64);
+	return ;
+}
+
+
+static int
+spca504B_PollingDataReady(struct usb_device *dev)		            
+{	
+	__u8 DataReady = 0 ;
+	int count = 0;
+	while(1) {
+		spca5xxRegRead(dev,0x21,0, 0, &DataReady,1);
+		if ( (DataReady & 0x01) == 0) break;
+		wait_ms(10);
+		count++;
+		if (count > 10) break;
+		
+	}
+	return DataReady;
+}
+
+
+static void
+spca504B_WaitCmdStatus(struct usb_spca50x *spca50x)
+{	
+	__u8 DataReady = 0;
+	int ReqDone;
+	int count = 0;
+	while (1) {
+		spca5xxRegRead(spca50x->dev,0x21,0, 1, &DataReady,1);
+
+		if ( DataReady ) {
+			DataReady = 0;
+			spca5xxRegWrite(spca50x->dev,0x21,0, 1, &DataReady, 1);		
+			spca5xxRegRead(spca50x->dev,0x21,0, 1, &DataReady, 1);
+			ReqDone = spca504B_PollingDataReady(spca50x->dev);
+			break ;           
+		}
+		wait_ms (10);	
+		count++;
+		if (count > 50) break;
+		
+	} 
+	return ;
+}
+
+
+static void
+spca504B_setQtable ( struct usb_spca50x *spca50x )
+{
+	__u8 Data = 3 ;
+	int rc ;
+	spca5xxRegWrite(spca50x->dev,0x26,0 ,0 ,&Data ,1 );
+	spca5xxRegRead(spca50x->dev,0x26 ,0 ,0 , &Data ,1);
+	rc = spca504B_PollingDataReady ( spca50x->dev );
+	return ;
+}
+static void sp5xx_initContBrigHueRegisters (struct usb_spca50x *spca50x)
+{	
+	int rc;
+	int pollreg =1;
+	switch (spca50x->bridge){
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504C:
+		pollreg = 0;
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504B:
+	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x21a7 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0x20 ,0x21a8 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x21ad ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,1 ,0x21ac ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0x20 ,0x21ae ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x21a3 ,NULL ,0 );
+	break;
+	case BRIDGE_SPCA536:
+	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x20f0 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0x21 ,0x20f1 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0x40 ,0x20f5 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,1 ,0x20f4 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0x40 ,0x20f6 ,NULL ,0 );
+	spca5xxRegWrite(spca50x->dev,0 ,0 ,0x2089 ,NULL ,0 );
+	break;
+	}
+	if (pollreg)
+		rc = spca504B_PollingDataReady( spca50x->dev );
+	return ;
+}
+#endif //SP5XXFW2
diff -ruN usb_old/spca5xx/spca5xx.h usb/spca5xx/spca5xx.h
--- linux-2.4.31/drivers/usb_old/spca5xx/spca5xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/spca5xx.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,319 @@
+#ifndef SPCA50X_H
+#define SPCA50X_H
+
+/*
+ * Header file for SPCA50x based camera driver. Originally copied from ov511 driver.
+ * Originally by Mark W. McClelland
+ * SPCA50x version by Joel Crisp; all bugs are mine, all nice features are his.
+ */
+
+#ifdef __KERNEL__
+#include <asm/uaccess.h>
+#include <linux/videodev.h>
+#include <linux/smp_lock.h>
+#include <linux/usb.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) && LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+#define urb_t struct urb
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20) */
+
+//static const char SPCA50X_H_CVS_VERSION[]="$Id: spca50x.h,v 1.28 2004/01/10 21:37:40 mxhaard Exp $";
+
+/* V4L API extension for raw JPEG (=JPEG without header) and JPEG with header   
+ */
+#define VIDEO_PALETTE_RAW_JPEG  20
+#define VIDEO_PALETTE_JPEG 21
+
+#ifdef SPCA50X_ENABLE_DEBUG
+
+#  define PDEBUG(level, fmt, args...) \
+if (debug >= level) info("[%s:%d] " fmt, __PRETTY_FUNCTION__, __LINE__ , ## args)
+#else /* SPCA50X_ENABLE_DEBUG */
+#  define PDEBUG(level, fmt, args...) do {} while(0)
+#endif /* SPCA50X_ENABLE_DEBUG */
+
+//#define FRAMES_PER_DESC		10	/* Default value, should be reasonable */
+#define FRAMES_PER_DESC		16	/* Default value, should be reasonable */
+#define MAX_FRAME_SIZE_PER_DESC 1024
+
+#define SPCA50X_MAX_WIDTH 640
+#define SPCA50X_MAX_HEIGHT 480
+
+#define SPCA50X_ENDPOINT_ADDRESS 1	/* Isoc endpoint number */
+
+/* only 2 or 4 frames are allowed here !!! */
+#define SPCA50X_NUMFRAMES	2
+#define SPCA50X_NUMSBUF	2
+
+
+#define BRIDGE_SPCA504 0 //4
+#define BRIDGE_SPCA504B 1 //6
+#define BRIDGE_SPCA533 2 //7
+#define BRIDGE_SPCA504C 3 //8
+#define BRIDGE_SPCA536 4 //10
+#define BRIDGE_ZC3XX 5 //12
+#define BRIDGE_SN9CXXX 6 //16
+
+
+
+#define SENSOR_INTERNAL 1
+#define SENSOR_HV7131B  2
+#define SENSOR_HDCS1020 3
+#define SENSOR_PB100_BA 4
+#define SENSOR_PB100_92	5
+#define SENSOR_PAS106_80 6
+#define SENSOR_TAS5130C 7
+#define SENSOR_ICM105A 8
+#define SENSOR_HDCS2020 9
+#define SENSOR_PAS106 10
+#define SENSOR_PB0330 11
+#define SENSOR_HV7131C 12
+#define SENSOR_CS2102 13
+#define SENSOR_HDCS2020b 14
+#define SENSOR_HV7131R 15
+#define SENSOR_OV7630 16
+#define SENSOR_MI0360 17
+#define SENSOR_TAS5110 18
+#define SENSOR_PAS202 19
+
+
+/* Alternate interface transfer sizes */
+#define SPCA50X_ALT_SIZE_0       0
+#define SPCA50X_ALT_SIZE_128     1
+#define SPCA50X_ALT_SIZE_256     1
+#define SPCA50X_ALT_SIZE_384     2
+#define SPCA50X_ALT_SIZE_512     3
+#define SPCA50X_ALT_SIZE_640     4
+#define SPCA50X_ALT_SIZE_768     5
+#define SPCA50X_ALT_SIZE_896     6
+#define SPCA50X_ALT_SIZE_1023    7
+
+/* Sequence packet identifier for a dropped packet */
+#define SPCA50X_SEQUENCE_DROP 0xFF
+
+/* Type bit for 10 byte header snapshot flag */
+#define SPCA50X_SNAPBIT 0x40
+#define SPCA50X_SNAPCTRL 0x80
+
+/* Offsets into the 10 byte header on the first ISO packet */
+#define SPCA50X_OFFSET_SEQUENCE 0
+
+/* Generic frame packet header offsets */
+#define SPCA50X_OFFSET_TYPE     1
+#define SPCA50X_OFFSET_COMPRESS 2
+#define SPCA50X_OFFSET_THRESHOLD 3
+#define SPCA50X_OFFSET_QUANT 4
+#define SPCA50X_OFFSET_QUANT2 5
+#define SPCA50X_OFFSET_FRAMSEQ 6
+#define SPCA50X_OFFSET_EDGE_AUDIO 7
+#define SPCA50X_OFFSET_GPIO 8
+#define SPCA50X_OFFSET_RESERVED 9
+#define SPCA50X_OFFSET_DATA 10
+
+/* Camera type jpeg yuvy yyuv yuyv grey gbrg*/
+enum {  
+	JPEG = 0, //Jpeg 4.1.1 Sunplus
+	JPGH, //jpeg 4.2.2 Zstar
+	JPGC, //jpeg 4.2.2 Conexant
+	JPGS, //jpeg 4.2.2 Sonix
+	JPGM, //jpeg 4.2.2 Mars-Semi
+};
+
+enum { QCIF = 1,
+       QSIF,
+       QPAL,
+       CIF,
+       SIF,
+       PAL,
+       VGA,
+       CUSTOM,
+       TOTMODE,
+};
+       
+/* available palette */       
+#define P_RGB16  1
+#define P_RGB24  (1 << 1)
+#define P_RGB32  (1 << 2)
+#define P_YUV420  (1 << 3)
+#define P_YUV422 ( 1 << 4)
+#define P_RAW  (1 << 5)
+#define P_JPEG  (1 << 6)
+
+struct mwebcam {
+	int width;
+	int height;
+	__u16 t_palette;
+	__u16 pipe;
+	int method;
+	int mode;
+};
+
+/* State machine for each frame in the frame buffer during capture */
+enum {
+	STATE_SCANNING,		/* Scanning for start */
+	STATE_HEADER,		/* Parsing header */
+	STATE_LINES,		/* Parsing lines */
+};
+
+/* Buffer states */
+enum {
+	BUF_NOT_ALLOCATED,
+	BUF_ALLOCATED,
+	BUF_PEND_DEALLOC,	/* spca50x->buf_timer is set */
+};
+
+struct usb_device;
+
+/* One buffer for the USB ISO transfers */
+struct spca50x_sbuf {
+	char       *data;
+	struct urb *urb;
+};
+
+/* States for each frame buffer. */
+enum {
+	FRAME_UNUSED,		/* Unused (no MCAPTURE) */
+	FRAME_READY,		/* Ready to start grabbing */
+	FRAME_GRABBING,		/* In the process of being grabbed into */
+	FRAME_DONE,		/* Finished grabbing, but not been synced yet */
+	FRAME_ERROR,		/* Something bad happened while processing */
+	FRAME_ABORTING,         /* Aborting everything. Caused by hot unplugging.*/
+
+};
+/************************ decoding data  **************************/
+struct dec_data {	
+	unsigned char quant[3][64];
+};
+/*************************End decoding data ********************************/	
+struct spca50x_frame {
+	unsigned char *data;		/* Frame buffer */
+	unsigned char *tmpbuffer;	/* temporary buffer spca50x->tmpbuffer need for decoding*/
+	struct dec_data *decoder;
+	/*******************************************/
+	int seq;                /* Frame sequence number */
+	int depth;		/* Bytes per pixel */
+	int width;		/* Width application is expecting */
+	int height;		/* Height */
+
+	int hdrwidth;		/* Width the frame actually is */
+	int hdrheight;		/* Height */
+	int method;		/* The decoding method for that frame 0 nothing 1 crop 2 div 4 mult */
+	int cropx1;		/* value to be send with the frame for decoding feature */
+	int cropx2;
+	int cropy1;
+	int cropy2;
+	int x;
+	int y;
+	
+	unsigned int format;	/* Format asked by apps for this frame */
+	int cameratype;		/* native in frame format */
+	volatile int grabstate;	/* State of grabbing */
+	int scanstate;		/* State of scanning */	
+	long scanlength;	/* uncompressed, raw data length of frame */
+	int totlength;		/* length of the current reading byte in the Iso stream */
+	wait_queue_head_t wq;	/* Processes waiting */
+	int last_packet;        /* sequence number for last packet */
+	unsigned char *highwater; /* used for debugging */
+	
+};
+
+
+struct usb_spca50x {
+	struct video_device *vdev;
+	struct usb_device *dev;/* Device structure */
+	struct tasklet_struct spca5xx_tasklet; /* use a tasklet per device */
+	struct dec_data maindecode;
+	unsigned char iface; /* interface in use */
+	int alt; /* current alternate setting */
+	int customid; /* product id get by probe */
+	int desc; /* enum camera name */
+	int ccd; /* If true, using the CCD otherwise the external input */
+	int chip_revision; /* set when probe the camera spca561 */
+	struct mwebcam mode_cam[TOTMODE]; /* all available mode registers by probe */	
+	int bridge;		/* Type of bridge (BRIDGE_SPCA505 or BRIDGE_SPCA506) */
+	int sensor;		/* Type of image sensor chip */
+	int packet_size;	/* Frame size per isoc desc */
+	int header_len;
+	/* Determined by sensor type */
+	int maxwidth;
+	int maxheight;
+	int minwidth;
+	int minheight;
+	/* What we think the hardware is currently set to */
+	int brightness;
+	int colour;
+	int contrast;
+	int hue;
+	int whiteness;
+	int exposure ;
+	int width; /* use here for the init of each frame */
+	int height;
+	int hdrwidth;
+	int hdrheight;
+	unsigned int format;
+	int method; /* method ask for output pict */
+	int mode; /* requested frame size */
+	int pipe_size; // requested pipe size set according to mode
+	__u16 norme; /* norme in use Pal Ntsc Secam */
+	__u16 channel; /* input composite video1 or svideo */
+	int cameratype;	/* native in frame format */
+	/* Statistics variables */
+	spinlock_t v4l_lock; /* lock to protect shared data between isoc and process context */
+	int avg_lum; //The average luminance (if available from theframe header)
+	int avg_bg, avg_rg; //The average B-G and R-G for white balancing 
+	struct semaphore lock;
+	int user;		/* user count for exclusive use */
+	int present;		/* driver loaded */
+	
+	int streaming;		/* Are we streaming Isochronous? */
+	int grabbing;		/* Are we grabbing? */
+	int packet;
+	int compress;		/* Should the next frame be compressed? */
+	
+	char *fbuf;		/* Videodev buffer area */	
+	int curframe;		/* Current receiving frame buffer */
+	struct spca50x_frame frame[SPCA50X_NUMFRAMES];	
+	int cursbuf;		/* Current receiving sbuf */
+	struct spca50x_sbuf sbuf[SPCA50X_NUMSBUF];
+	/* Temporary jpeg decoder workspace */
+	char   *tmpBuffer;
+	/* Framebuffer/sbuf management */
+	int buf_state;
+	struct semaphore buf_lock;
+	
+	wait_queue_head_t wq;	/* Processes waiting */		
+	/* proc interface */
+	struct semaphore param_lock;	/* params lock for this camera */
+
+		
+	int lastFrameRead;	
+	uint i2c_ctrl_reg; // Camera I2C control register
+	uint i2c_base;     // Camera I2C address base
+	char i2c_trigger_on_write; //do trigger bit on write
+	
+	__u8 force_rgb; //Read RGB instead of BGR
+	__u8 min_bpp; //The minimal color depth that may be set
+	__u8 lum_level; //Luminance level for brightness autoadjustment
+};
+
+struct cam_list {
+	int id;
+	const char *description;
+};
+
+struct palette_list {
+	int num;
+	const char *name;
+};
+
+struct bridge_list {
+	int num;
+	const char *name;
+};
+
+#endif /* __KERNEL__ */
+
+
+#endif /* SPCA50X_H */
diff -ruN usb_old/spca5xx/spcaCompat.h usb/spca5xx/spcaCompat.h
--- linux-2.4.31/drivers/usb_old/spca5xx/spcaCompat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/spcaCompat.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,33 @@
+ 
+#ifndef SPCA_COMPAT_H
+#define SPCA_COMPAT_H
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 24)
+static inline void * video_get_drvdata(struct video_device *vdev)
+{
+        return vdev->priv;
+}
+
+static inline void video_set_drvdata(struct video_device *vdev, void *data)
+{
+        vdev->priv = data;
+}
+
+static inline struct video_device *video_device_alloc(void)
+{
+	struct video_device *vdev;
+
+	vdev = kmalloc(sizeof(*vdev),GFP_KERNEL);
+	if (NULL == vdev)
+		return NULL;
+	memset(vdev,0,sizeof(*vdev));
+	return vdev;
+}
+
+static inline void video_device_release(struct video_device *vdev)
+{
+	kfree(vdev);
+}
+#endif
+
+#endif
diff -ruN usb_old/spca5xx/spca_core.c usb/spca5xx/spca_core.c
--- linux-2.4.31/drivers/usb_old/spca5xx/spca_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/spca_core.c	2005-11-25 20:59:39.000000000 +0100
@@ -0,0 +1,4437 @@
+/*
+ * SPCA5xx based usb camera driver (currently supports
+ * yuv native stream spca501a, spca501c, spca505, spca508, spca506
+ * jpeg native stream spca500, spca551, spca504a, spca504b, spca533a, spca536a, zc0301, zc0302, cx11646, sn9c102p
+ * bayer native stream spca561a, sn9c101, sn9c102, tv8532 ).
+ * Z-star Vimicro chips zc0301 zc0301P zc0302
+ * Sunplus spca501a, spca501c, spca505, spca508, spca506, spca500, spca551, spca504a, spca504b, spca533a, spca536a
+ * Sonix sn9c101, sn9c102, sn9c102p sn9c105 sn9c120
+ * Conexant cx11646
+ * Transvision tv_8532 
+ * Etoms Et61x151 Et61x251
+ * Pixat Pac207-BCA-32
+ * SPCA5xx version by Michel Xhaard <mxhaard@users.sourceforge.net>
+ * Based on :
+ * SPCA50x version by Joel Crisp <cydergoth@users.sourceforge.net>
+ * OmniVision OV511 Camera-to-USB Bridge Driver
+ * Copyright (c) 1999-2000 Mark W. McClelland
+ * Kernel 2.6.x port Michel Xhaard && Reza Jelveh (feb 2004)
+ * Based on the Linux CPiA driver written by Peter Pregler,
+ * Scott J. Bertin and Johannes Erdfelt.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#define SPCA5XX_VERSION "00.57.06LE"
+#define VID_HARDWARE_SPCA5XX 0xFF
+
+
+static const char version[] = SPCA5XX_VERSION;
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+
+
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/usb.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+#include <linux/videodev.h>
+
+#include <asm/page.h>
+#include <asm/uaccess.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#include <linux/wrapper.h>
+#endif
+#include <linux/param.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
+#include <linux/moduleparam.h>
+#endif
+
+#include "spca5xx.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+#  undef CONFIG_VIDEO_PROC_FS
+#	 undef CONFIG_PROC_FS
+#endif
+
+//#define RH9_REMAP 1
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#include "spcaCompat.h"
+#ifndef pte_offset_kernel
+# define pte_offset_kernel(dir, address)	pte_offset(dir, address)
+#endif
+#endif
+
+
+#include "spcadecoder.h"
+
+
+#define PROC_NAME_LEN 10	//length of the proc name
+
+
+
+/* Video Size 640 x 480 jpeg only */
+#define MAX_FRAME_SIZE (640 * 480)
+#define MAX_DATA_SIZE (MAX_FRAME_SIZE + sizeof(struct timeval))
+
+
+
+/* Hardware auto exposure / whiteness (PC-CAM 600) */
+static int autoexpo = 1;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5)
+/* Video device number (-1 is first available) */
+static int video_nr = -1;
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5) */
+#ifdef SPCA50X_ENABLE_DEBUG
+/* 0=no debug messages
+ * 1=init/detection/unload and other significant messages,
+ * 2=some warning messages
+ * 3=config/control function calls
+ * 4=most function calls and data parsing messages
+ * 5=highly repetitive mesgs
+ * NOTE: This should be changed to 0, 1, or 2 for production kernels
+ */
+ 
+static int debug = 0;
+#endif
+/* Force image to be read in RGB instead of BGR. This option allow
+ * programs that expect RGB data (e.g. gqcam) to work with this driver. */
+
+
+/* Enable compression. This is for experimentation only; compressed images
+ * still cannot be decoded yet. */
+static int compress = 0;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
+
+module_param (autoexpo, int, 0644);
+#ifdef SPCA50X_ENABLE_DEBUG
+module_param (debug, int, 0644);
+#endif
+
+#ifdef SPCA50X_ENABLE_COMPRESSION
+module_param (compress, int, 0644);
+#endif /* SPCA50X_ENABLE_COMPRESSION */
+
+
+
+#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9) */
+
+
+MODULE_PARM (autoexpo, "i");
+#ifdef SPCA50X_ENABLE_DEBUG
+MODULE_PARM (debug, "i");
+#endif
+
+#ifdef SPCA50X_ENABLE_COMPRESSION
+MODULE_PARM (compress, "i");
+#endif /* SPCA50X_ENABLE_COMPRESSION */
+
+#endif
+/***************/
+
+
+MODULE_PARM_DESC (autoexpo,
+		  "Enable/Disable hardware auto exposure / whiteness (default: enabled) (PC-CAM 600 only !!)");
+#ifdef SPCA50X_ENABLE_DEBUG
+MODULE_PARM_DESC (debug,
+		  "Debug level: 0=none, 1=init/detection, 2=warning, 3=config/control, 4=function call, 5=max");
+#endif
+
+#ifdef SPCA50X_ENABLE_COMPRESSION
+MODULE_PARM_DESC (compress, "Turn on/off compression (not functional yet)");
+#endif /* SPCA50X_ENABLE_COMPRESSION */
+
+/****************/
+MODULE_AUTHOR
+  ("Michel Xhaard <mxhaard@users.sourceforge.net> based on spca50x driver by Joel Crisp <cydergoth@users.sourceforge.net>,ov511 driver by Mark McClelland <mwm@i.am>");
+MODULE_DESCRIPTION ("SPCA5LE USB Camera Driver");
+MODULE_LICENSE ("GPL");
+
+
+
+static int spca50x_move_data (struct usb_spca50x *spca50x, struct urb *urb);
+
+
+
+static struct usb_driver spca5xx_driver;
+
+#ifndef max
+static inline int
+max (int a, int b)
+{
+  return (a > b) ? a : b;
+}
+#endif /* max */
+
+/**********************************************************************
+ * List of known SPCA50X-based cameras
+ **********************************************************************/
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+/* Camera type jpeg yuvy yyuv yuyv grey gbrg*/
+static struct palette_list Plist[] = {
+  {JPEG, "JPEG"},
+  {JPGH, "JPEG"},
+  {JPGC, "JPEG"},
+  {JPGS, "JPEG"},
+  {JPGM, "JPEG"},
+  {-1, NULL}
+};
+#endif
+
+static struct bridge_list Blist[] = {
+  {BRIDGE_SPCA504, "SPCA504"},
+  {BRIDGE_SPCA504B, "SPCA504B"},
+  {BRIDGE_SPCA533, "SPCA533"},
+  {BRIDGE_SPCA504C, "SPCA504C"},
+  {BRIDGE_SPCA536, "SPCA536"},
+  {BRIDGE_ZC3XX, "ZC301-2"},
+  {BRIDGE_SN9CXXX,"SN9CXXX"},
+  {-1, NULL}
+};
+enum
+{
+  UnknownCamera = 0,		// 0
+  MustekGsmartMini2,
+  MustekGsmartMini3,
+  CreativePCCam600,
+  MaxellMaxPocket,
+  AiptekMiniPenCam2,
+  AiptekPocketDVII,
+  AiptekPenCamSD,
+  AiptekMiniPenCam13,
+  MustekGsmartLCD3,
+  MustekMDC5500Z, //10
+  MegapixV4,
+  AiptekPocketDV3100,
+  AiptekPocketCam3M,
+  MustekGsmartLCD2,
+  PureDigitalDakota,
+  BenqDC1500,
+  LogitechClickSmart420,
+  BenqDC1300,
+  MustekDV3000,
+  CreativePccam750,//20
+  BenqDC3410,
+  Jenoptikjdc21lcd,
+  Terratec2move13,
+  MustekDV4000,
+  AiptekDV3500,
+  LogitechClickSmart820,
+  Enigma13,
+  Epsilon13,
+  AiptekPocketCam2M,
+  PolaroidPDC2030,//30
+  CreativeNotebook,
+  CreativeMobile,
+  LabtecPro,
+  MustekWcam300A,
+  GeniusVideoCamV2,
+  GeniusVideoCamV3,
+  GeniusVideoCamExpressV2b,
+  CreativeNxPro,
+  Vimicro,
+  Digitrex2110,//40
+  GsmartD30,
+  CreativeNxPro2,
+  Bs888e,
+  Zc302,
+  AiptekSlim3200,
+  CreativeLive,	
+  MercuryDigital,
+  Wcam300A,
+  TyphoonWebshotIIUSB300k,//50
+  PolaroidPDC3070,
+  QCim,
+  WebCam320,
+  AiptekPocketCam4M,
+  AiptekPocketDV5100,
+  AiptekPocketDV5300,
+  SunplusGeneric536,
+  QCimA1,
+  QCchat,
+  QCimB9,//60
+  SonixWC311P,
+  Concord3045,
+  Mercury21,
+  CreativeNX,
+  CreativeInstant1,
+  CreativeInstant2,
+  QuickCamNB,
+  WCam300AN,
+  GeniusDsc13,
+  MustekMDC4000,//70
+  LogitechQCCommunicateSTX,
+  Pccam168,
+  Sn535,
+  Pccam,
+  Lic300,
+  PolaroidIon80,
+  Zc0305b,
+  LogitechNotebookDeluxe,
+  LabtecNotebook,
+  JvcGcA50,//80
+  PcCam350,
+  Vimicro303b,
+  CyberpixS550V,
+  LastCamera
+};
+
+static struct cam_list clist[] = {
+  {UnknownCamera, "Unknown"},
+  {MustekGsmartMini2, "Mustek gSmart mini 2"},
+  {MustekGsmartMini3, "Mustek gSmart mini 3"},
+  {CreativePCCam600, "Creative PC-CAM 600"},
+  {MaxellMaxPocket, "Maxell Max Pocket LEdit. 1.3 MPixels"},
+  {AiptekMiniPenCam2, "Aiptek Mini PenCam  2 MPixels"},
+  {AiptekPocketDVII, "Aiptek PocketDVII  1.3 MPixels"},
+  {AiptekPenCamSD, "Aiptek Pencam SD  2 MPixels"},
+  {AiptekMiniPenCam13, "Aiptek mini PenCam 1.3 MPixels"},
+  {MustekGsmartLCD3, "Mustek Gsmart LCD 3"},
+  {MustekMDC5500Z, "Mustek MDC5500Z"},
+  {MegapixV4, "Megapix V4"},
+  {AiptekPocketDV3100, "Aiptek PocketDV3100+ "},
+  {AiptekPocketCam3M, "Aiptek PocketCam  3 M "},
+  {MustekGsmartLCD2, "Mustek Gsmart LCD 2"},
+  {PureDigitalDakota, "Pure Digital Dakota"},
+  {BenqDC1500, "Benq DC1500"},
+  {LogitechClickSmart420, "Logitech Inc. ClickSmart 420"},
+  {BenqDC1300, "Benq DC1300"}, 
+  {MustekDV3000, "Mustek DV 3000"},
+  {CreativePccam750, "Creative PCcam750"}, 
+  {BenqDC3410, "Benq DC3410"}, 
+  {Jenoptikjdc21lcd, "Jenoptik DC 21 LCD"}, 
+  {Terratec2move13, "Terratec 2 move 1.3"},
+  {MustekDV4000, "Mustek DV4000 Mpeg4"},
+  {AiptekDV3500, "Aiptek DV3500 Mpeg4"},
+  {LogitechClickSmart820, "Logitech ClickSmart 820"},
+  {Enigma13, "Digital Dream Enigma 1.3"},
+  {Epsilon13, "Digital Dream Epsilon 1.3"},
+  {AiptekPocketCam2M, "Aiptek PocketCam 2Mega"},
+  {PolaroidPDC2030, "Polaroid PDC2030"},
+  {CreativeNotebook, "Creative Notebook PD1171"},
+  {CreativeMobile, "Creative Mobile PD1090"},
+  {LabtecPro, "Labtec Webcam Pro"},
+  {MustekWcam300A, "Mustek Wcam300A"},
+  {GeniusVideoCamV2, "Genius Videocam V2"},
+  {GeniusVideoCamV3, "Genius Videocam V3"},
+  {GeniusVideoCamExpressV2b, "Genius Videocam Express V2 Firmware 2"},
+  {CreativeNxPro, "Creative Nx Pro"}, 
+  {Vimicro, "Z-star Vimicro zc0301p"},
+  {Digitrex2110, "ApexDigital Digitrex2110 spca533"},
+  {GsmartD30, "Mustek Gsmart D30 spca533"},
+  {CreativeNxPro2, "Creative NX Pro FW2"},
+  {Bs888e, "Kowa Bs888e MicroCamera"},
+  {Zc302, "Z-star Vimicro zc0302"},
+  {AiptekSlim3200, "Aiptek Slim 3200"},
+  {CreativeLive, "Creative Live! "},
+  {MercuryDigital, "Mercury Digital Pro 3.1Mp"},
+  {Wcam300A, "Mustek Wcamm300A 2"},
+  {TyphoonWebshotIIUSB300k, " Typhoon Webshot II"},
+  {PolaroidPDC3070, " Polaroid PDC3070"}, 
+  {QCim,"Logitech QuickCam IM"},
+  {WebCam320,"Micro Innovation WebCam 320"},
+  {AiptekPocketCam4M,"Aiptek Pocket Cam 4M"},
+  {AiptekPocketDV5100,"Aiptek Pocket DV5100"},
+  {AiptekPocketDV5300,"Aiptek Pocket DV5300"},
+  {SunplusGeneric536,"Sunplus Generic spca536a"},
+  {QCimA1,"Logitech QuickCam IM + sound"},
+  {QCchat,"Logitech QuickCam chat"},
+  {QCimB9,"Logitech QuickCam IM ???"}, 
+  {SonixWC311P,"Sonix sn9c102P Hv7131R"},
+  {Concord3045,"Concord 3045 spca536a"},
+  {Mercury21,"Mercury Peripherals Inc."},
+  {CreativeNX,"Creative NX"},
+  {CreativeInstant1,"Creative Instant P0620"},
+  {CreativeInstant2,"Creative Instant P0620D"},
+  {QuickCamNB,"Logitech QuickCam for Notebooks"},
+  {WCam300AN,"Mustek WCam300AN "},
+  {GeniusDsc13,"Genius Dsc 1.3 Smart spca504B-P3"},
+  {MustekMDC4000, "Mustek MDC4000"},
+  {LogitechQCCommunicateSTX,"Logitech QuickCam Communicate STX"}, 
+  {Pccam168,"Sonix PcCam"},
+  {Sn535,"Sangha 350k"},
+  {Pccam,"Sonix Pccam +"},
+  {Lic300,"LG Lic-300"},
+  {PolaroidIon80,"Polaroid Ion 80"},
+  {Zc0305b,"Generic Zc0305b"},
+  {LogitechNotebookDeluxe,"Logitech Notebook Deluxe"},
+  {LabtecNotebook,"Labtec Webcam Notebook"},
+  {JvcGcA50,"JVC GC-A50"}, 
+  {PcCam350,"PC-Cam350"}, 
+  {Vimicro303b,"Generic Vimicro 303b"},
+  {CyberpixS550V,"Mercury Cyberpix S550V"},
+  {-1, NULL}
+};
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+static __devinitdata struct usb_device_id device_table[] = {
+  {USB_DEVICE (0x055f, 0xc420)},	/* Mustek gSmart Mini 2 */
+  {USB_DEVICE (0x055f, 0xc520)},	/* Mustek gSmart Mini 3 */
+  {USB_DEVICE (0x041E, 0x400B)},	/* Creative PC-CAM 600 */
+  {USB_DEVICE (0x04fc, 0x504b)},	/* Maxell MaxPocket LE 1.3 */
+  {USB_DEVICE (0x08ca, 0x2008)},	/* Aiptek Mini PenCam 2 M */
+  {USB_DEVICE (0x08ca, 0x0104)},	/* Aiptek PocketDVII 1.3 */
+  {USB_DEVICE (0x08ca, 0x2018)},	/* Aiptek Pencam SD 2M */
+  {USB_DEVICE (0x04fc, 0x504a)},	/* Aiptek Mini PenCam 1.3 */
+  {USB_DEVICE (0x055f, 0xc530)},	/* Mustek Gsmart LCD 3 */
+  {USB_DEVICE (0x055f, 0xc650)},	/* Mustek MDC5500Z */
+  {USB_DEVICE (0x052b, 0x1513)},	/* Megapix V4 */
+  {USB_DEVICE (0x08ca, 0x0106)},	/* Aiptek Pocket DV3100+ */
+  {USB_DEVICE (0x08ca, 0x2010)},	/* Aiptek PocketCam 3M */
+  {USB_DEVICE (0x055f, 0xc430)},	/* Mustek Gsmart LCD 2 */
+  {USB_DEVICE (0x04fc, 0xffff)},	/* Pure DigitalDakota */
+  {USB_DEVICE (0x04a5, 0x3008)},	/* Benq DC 1500 */
+  {USB_DEVICE (0x046d, 0x0960)},	/* Logitech Inc. ClickSmart 420 */
+  {USB_DEVICE (0x04a5, 0x3003)},	/* Benq DC 1300 */
+  {USB_DEVICE (0x055f, 0xc440)},	/* Mustek DV 3000 */
+  {USB_DEVICE (0x041e, 0x4013)},	/* Creative Pccam750 */
+  {USB_DEVICE (0x04a5, 0x300a)},	/* Benq DC3410 */
+  {USB_DEVICE (0x055f, 0xc220)},	/* Gsmart Mini */
+  {USB_DEVICE (0x0733, 0x2211)},	/* Jenoptik jdc 21 LCD */
+  {USB_DEVICE (0x055f, 0xc360)},	/* Mustek DV4000 Mpeg4  */
+  {USB_DEVICE (0x08ca, 0x2024)},	/* Aiptek DV3500 Mpeg4  */
+  {USB_DEVICE (0x046d, 0x0905)},	/* Logitech ClickSmart820  */
+  {USB_DEVICE (0x05da, 0x1018)},	/* Digital Dream Enigma 1.3 */
+  {USB_DEVICE (0x0733, 0x1311)},	/* Digital Dream Epsilon 1.3 */
+  {USB_DEVICE (0x041e, 0x401d)},	/* Creative Webcam NX ULTRA */
+  {USB_DEVICE (0x08ca, 0x2016)},	/* Aiptek PocketCam 2 Mega */
+  {USB_DEVICE (0x0546, 0x3273)},	/* Polaroid PDC2030 */
+  {USB_DEVICE (0x041e, 0x401f)},	/* Creative Webcam Notebook PD1171 */
+  {USB_DEVICE (0x041e, 0x4017)},	/* Creative Webcam Mobile PD1090 */
+  {USB_DEVICE (0x046d, 0x08a2)},	/* Labtec Webcam Pro */
+  {USB_DEVICE (0x055f, 0xd003)},	/* Mustek WCam300A */
+  {USB_DEVICE (0x0458, 0x7007)},	/* Genius VideoCam V2 */
+  {USB_DEVICE (0x0458, 0x700c)},	/* Genius VideoCam V3 */
+  {USB_DEVICE (0x0458, 0x7029)},	/* Genius VideoCam Web V2 */
+  {USB_DEVICE (0x041e, 0x401e)},	/* Creative Nx Pro */
+  {USB_DEVICE (0x04fc, 0x5330)},	/* Digitrex 2110 */
+  {USB_DEVICE (0x055f, 0xc540)},	/* Gsmart D30 */
+  {USB_DEVICE (0x0ac8, 0x301b)},	/* Asam Vimicro */
+  {USB_DEVICE (0x041e, 0x403a)},	/* Creative Nx Pro 2 */
+  {USB_DEVICE (0x055f, 0xc211)},	/* Kowa Bs888e Microcamera */
+  {USB_DEVICE (0x0ac8, 0x0302)},	/* Z-star Vimicro zc0302 */
+  {USB_DEVICE (0x08ca, 0x2022)},	/* Aiptek Slim 3200 */
+  {USB_DEVICE (0x0733, 0x2221)},	/* Mercury Digital Pro 3.1p */
+  {USB_DEVICE (0x041e, 0x4036)},	/* Creative Live ! */
+  {USB_DEVICE (0x055f, 0xc005)},	/* Mustek Wcam300A */
+  {USB_DEVICE (0x10fd, 0x8050)},	/* Typhoon Webshot II USB 300k */
+  {USB_DEVICE (0x0546, 0x3155)},	/* Polaroid PDC3070 */
+  {USB_DEVICE (0x046d, 0x08a0)},	/* Logitech QC IM */
+  {USB_DEVICE (0x0461, 0x0a00)},	/* MicroInnovation WebCam320 */
+  {USB_DEVICE (0x08ca, 0x2028)},	/* Aiptek PocketCam4M */
+  {USB_DEVICE (0x08ca, 0x2042)},	/* Aiptek PocketDV5100 */
+  {USB_DEVICE (0x08ca, 0x2060)},	/* Aiptek PocketDV5300 */
+  {USB_DEVICE (0x04fc, 0x5360)},	/* Sunplus Generic */
+  {USB_DEVICE (0x046d, 0x08a1)},	/* Logitech QC IM 0x08A1 +sound*/
+  {USB_DEVICE (0x046d, 0x08a3)},	/* Logitech QC Chat */
+  {USB_DEVICE (0x046d, 0x08b9)},	/* Logitech QC IM ??? */
+  {USB_DEVICE (0x10fd, 0x0128)},	/* Typhoon Webshot II USB 300k 0x0128 */
+  {USB_DEVICE (0x0c45, 0x607c)},	/* Sonix sn9c102p Hv7131R*/
+  {USB_DEVICE (0x0733, 0x3261)},	/* Concord 3045 spca536a*/
+  {USB_DEVICE (0x0733, 0x1314)},        /* Mercury 2.1MEG Deluxe Classic Cam*/
+  {USB_DEVICE (0x041e, 0x401c)},	/* Creative NX */
+  {USB_DEVICE (0x041e, 0x4034)},	/* Creative Instant P0620 */
+  {USB_DEVICE (0x041e, 0x4035)},	/* Creative Instant P0620D */
+  {USB_DEVICE (0x046d, 0x08ae)},	/* Logitech QuickCam for Notebooks */
+  {USB_DEVICE (0x055f, 0xd004)},	/* Mustek WCam300 AN */
+  {USB_DEVICE (0x0458, 0x7006)},	/* Genius Dsc 1.3 Smart */
+  {USB_DEVICE (0x055f, 0xc630)},	/* Mustek MDC4000 */
+  {USB_DEVICE (0x046d, 0x08ad)},	/* Logitech QCCommunicate STX*/
+  {USB_DEVICE (0x0c45, 0x613c)},	/* Sonix Pccam168 */
+  {USB_DEVICE (0x0c45, 0x6130)},	/* Sonix Pccam */
+  {USB_DEVICE (0x0c45, 0x60c0)},	/* Sangha Sn535 */
+  {USB_DEVICE (0x0c45, 0x6007)},	/* LG-LIC300 */
+  {USB_DEVICE (0x0546, 0x3191)},	/* Polaroid Ion 80 */
+  {USB_DEVICE (0x0ac8, 0x305b)},	/* Z-star Vimicro zc0305b */
+  {USB_DEVICE (0x046d, 0x08a9)},	/* Logitech Notebook Deluxe*/
+  {USB_DEVICE (0x046d, 0x08aa)},	/* Labtec Webcam  Notebook */
+  {USB_DEVICE (0x04f1, 0x1001)},	/* JVC GC A50*/
+  {USB_DEVICE (0x041e, 0x4012)},	/* PC-Cam350*/
+  {USB_DEVICE (0x0ac8, 0x303b)},	/* Vimicro 0x303b*/
+  {USB_DEVICE (0x0733, 0x3281)},	/* Cyberpix S550V*/
+  {}				/* Terminating entry */
+};
+
+
+MODULE_DEVICE_TABLE (usb, device_table);
+/* 
+ We also setup the function for getting 
+ page number from the virtual address 
+*/
+#define VIRT_TO_PAGE virt_to_page
+#else /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+#define VIRT_TO_PAGE MAP_NR
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0) */
+/*
+ * Let's include the initialization data for each camera type
+ */
+#include "spcausb.h"
+#include "sp5xxfw2.h"
+#include "zc3xx.h"
+#include "sn9cxxx.h"
+
+/* function for the tasklet */
+
+void outpict_do_tasklet (unsigned long ptr);
+
+/**********************************************************************
+ *
+ * Memory management
+ *
+ * This is a shameless copy from the USB-cpia driver (linux kernel
+ * version 2.3.29 or so, I have no idea what this code actually does ;).
+ * Actually it seems to be a copy of a shameless copy of the bttv-driver.
+ * Or that is a copy of a shameless copy of ... (To the powers: is there
+ * no generic kernel-function to do this sort of stuff?)
+ *
+ * Yes, it was a shameless copy from the bttv-driver. IIRC, Alan says
+ * there will be one, but apparentely not yet -jerdfelt
+ *
+ * So I copied it again for the ov511 driver -claudio
+ * And again for the spca50x driver -jcrisp
+ **********************************************************************/
+
+/* Given PGD from the address space's page table, return the kernel
+ * virtual mapping of the physical memory mapped at ADR.
+ */
+#ifndef RH9_REMAP
+static inline unsigned long
+uvirt_to_kva (pgd_t * pgd, unsigned long adr)
+{
+  unsigned long ret = 0UL;
+  pmd_t *pmd;
+  pte_t *ptep, pte;
+
+  if (!pgd_none (*pgd))
+    {
+#if PUD_SHIFT
+      pud_t *pud = pud_offset (pgd, adr);
+      if (!pud_none (*pud))
+	{
+	  pmd = pmd_offset (pud, adr);
+#else
+      pmd = pmd_offset (pgd, adr);
+#endif
+      if (!pmd_none (*pmd))
+	{
+	  ptep = pte_offset_kernel (pmd, adr);
+	  pte = *ptep;
+	  if (pte_present (pte))
+	    {
+	      ret = (unsigned long) page_address (pte_page (pte));
+	      ret |= (adr & (PAGE_SIZE - 1));
+	    }
+#if PUD_SHIFT
+	}
+#endif
+    }
+}
+
+return ret;
+}
+#endif /* RH9_REMAP */
+/* Here we want the physical address of the memory.
+ * This is used when initializing the contents of the
+ * area and marking the pages as reserved.
+ */
+#ifdef RH9_REMAP
+static inline unsigned long
+kvirt_to_pa (unsigned long adr)
+{
+  unsigned long kva, ret;
+
+  kva = (unsigned long) page_address (vmalloc_to_page ((void *) adr));
+  kva |= adr & (PAGE_SIZE - 1);	/* restore the offset */
+  ret = __pa (kva);
+  return ret;
+}
+
+#else /* RH9_REMAP */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+static inline unsigned long
+kvirt_to_pa (unsigned long adr)
+{
+  unsigned long kva, ret;
+
+  kva = (unsigned long) page_address (vmalloc_to_page ((void *) adr));
+  kva |= adr & (PAGE_SIZE - 1);
+  ret = __pa (kva);
+  return ret;
+}
+#else
+static inline unsigned long
+kvirt_to_pa (unsigned long adr)
+{
+  unsigned long va, kva, ret;
+
+  va = VMALLOC_VMADDR (adr);
+  kva = uvirt_to_kva (pgd_offset_k (va), va);
+  ret = __pa (kva);
+  return ret;
+}
+#endif
+#endif /* RH9_REMAP */
+
+
+static void *
+rvmalloc (unsigned long size)
+{
+  void *mem;
+  unsigned long adr;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 23)
+unsigned long page;
+#endif
+  size = PAGE_ALIGN (size);
+  mem = vmalloc_32 (size);
+  if (!mem)
+    return NULL;
+
+  memset (mem, 0, size);	/* Clear the ram out, no junk to the user */
+  adr = (unsigned long) mem;
+  while ((long) size > 0)
+    {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 68)
+      SetPageReserved (vmalloc_to_page ((void *) adr));
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 23)
+      mem_map_reserve (vmalloc_to_page ((void *) adr));
+#else
+	page = kvirt_to_pa (adr);
+	mem_map_reserve(VIRT_TO_PAGE(__va (page)));
+#endif
+#endif
+      adr += PAGE_SIZE;
+      size -= PAGE_SIZE;
+    }
+
+  return mem;
+}
+
+static void
+rvfree (void *mem, unsigned long size)
+{
+  unsigned long adr;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 23)
+unsigned long page;
+#endif
+  if (!mem)
+    return;
+
+  adr = (unsigned long) mem;
+  while ((long) size > 0)
+    {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 68)
+      ClearPageReserved (vmalloc_to_page ((void *) adr));
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 23)
+      mem_map_unreserve (vmalloc_to_page ((void *) adr));
+#else
+	page = kvirt_to_pa (adr);
+	mem_map_unreserve(VIRT_TO_PAGE(__va (page)));
+#endif
+#endif
+      adr += PAGE_SIZE;
+      size -= PAGE_SIZE;
+    }
+  vfree (mem);
+}
+
+
+
+static int
+spca50x_set_packet_size (struct usb_spca50x *spca50x, int size)
+{
+  int alt;
+	/**********************************************************************/
+	/******** Try to find real Packet size from usb struct ****************/
+  struct usb_device *dev = spca50x->dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  struct usb_interface_descriptor *interface = NULL;
+
+  struct usb_config_descriptor *config = dev->actconfig;
+#else
+  struct usb_host_interface *interface = NULL;
+  struct usb_interface *intf;
+#endif
+  int mysize = 0;
+  int ep = 0;
+  
+
+	/**********************************************************************/
+
+  if (size == 0)
+    alt = SPCA50X_ALT_SIZE_0;
+  else if (size == 128)
+    alt = SPCA50X_ALT_SIZE_128;
+  else if (size == 256)
+    alt = SPCA50X_ALT_SIZE_256;
+  else if (size == 384)
+    alt = SPCA50X_ALT_SIZE_384;
+  else if (size == 512)
+    alt = SPCA50X_ALT_SIZE_512;
+  else if (size == 640)
+    alt = SPCA50X_ALT_SIZE_640;
+  else if (size == 768)
+    alt = SPCA50X_ALT_SIZE_768;
+  else if (size == 896)
+    alt = SPCA50X_ALT_SIZE_896;
+  else if (size == 1023)
+    if (spca50x->bridge == BRIDGE_SN9CXXX )
+      {
+	alt = 8;
+      }
+    else
+      {
+	alt = SPCA50X_ALT_SIZE_1023;
+      }
+  else
+    {
+      /* if an unrecognised size, default to the minimum */
+      PDEBUG (5, "Set packet size: invalid size (%d), defaulting to %d",
+	      size, SPCA50X_ALT_SIZE_128);
+      alt = SPCA50X_ALT_SIZE_128;
+    }
+
+
+  PDEBUG (5, "iface alt size: %d %d %d", spca50x->iface, alt, size);
+  if (usb_set_interface (spca50x->dev, spca50x->iface, alt) < 0)
+    {
+      err ("Set packet size: set interface error");
+      return -EBUSY;
+    }
+
+   ep = SPCA50X_ENDPOINT_ADDRESS - 1;
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,3)
+  intf = usb_ifnum_to_if (dev, spca50x->iface);
+  if (intf)
+    {
+      interface = usb_altnum_to_altsetting (intf, alt);
+    }
+  else
+    {
+      PDEBUG (0, "intf not found");
+      return -ENXIO;
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+   mysize = le16_to_cpu(interface->endpoint[ep].desc.wMaxPacketSize);
+#else   
+	mysize = (interface->endpoint[ep].desc.wMaxPacketSize);  
+#endif
+#else
+  interface = &config->interface[spca50x->iface].altsetting[alt];
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+  mysize = le16_to_cpu(interface->endpoint[ep].wMaxPacketSize);
+#else
+  mysize = (interface->endpoint[ep].wMaxPacketSize);
+#endif  
+#endif
+  
+  spca50x->packet_size = mysize & 0x03ff;
+  spca50x->alt = alt;
+  PDEBUG (1, "set real packet size: %d, alt=%d", mysize, alt);
+  return 0;
+}
+
+/* Returns number of bits per pixel (regardless of where they are located; planar or
+ * not), or zero for unsupported format.
+ */
+static int
+spca5xx_get_depth (struct usb_spca50x *spca50x, int palette)
+{
+  switch (palette)
+    {
+
+    case VIDEO_PALETTE_RAW_JPEG:
+      return 8;		/* raw jpeg. what should we return ?? */
+    case VIDEO_PALETTE_JPEG:
+      if (spca50x->cameratype == JPEG ||
+	  spca50x->cameratype == JPGH ||
+	  spca50x->cameratype == JPGC ||
+	  spca50x->cameratype == JPGS ||
+	  spca50x->cameratype == JPGM )
+	{
+	  return 8;
+	}
+      else
+	return 0;
+    default:
+      return 0;			/* Invalid format */
+    }
+}
+
+/**********************************************************************
+* spca50x_isoc_irq
+* Function processes the finish of the USB transfer by calling 
+* spca50x_move_data function to move data from USB buffer to internal
+* driver structures 
+***********************************************************************/
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+static void
+spca50x_isoc_irq (struct urb *urb, struct pt_regs *regs)
+{
+  int i;
+#else
+static void
+spca50x_isoc_irq (struct urb *urb)
+{
+#endif
+  int len;
+  struct usb_spca50x *spca50x;
+
+  if (!urb->context)
+    {
+      PDEBUG (4, "no context");
+      return;
+    }
+
+  spca50x = (struct usb_spca50x *) urb->context;
+
+  if (!spca50x->dev)
+    {
+      PDEBUG (4, "no device ");
+      return;
+    }
+  if (!spca50x->user)
+    {
+      PDEBUG (4, "device not open");
+      return;
+    }
+  if (!spca50x->streaming)
+    {
+      /* Always get some of these after close but before packet engine stops */
+      PDEBUG (4, "hmmm... not streaming, but got interrupt");
+      return;
+    }
+  if (!spca50x->present)
+    {
+      /*  */
+      PDEBUG (4, "device disconnected ..., but got interrupt !!");
+      return;
+    }
+  /* Copy the data received into our scratch buffer */
+  if (spca50x->curframe >= 0)
+    {
+      len = spca50x_move_data (spca50x, urb);
+    }
+  else if (waitqueue_active (&spca50x->wq))
+    {
+      wake_up_interruptible (&spca50x->wq);
+    }
+
+  /* Move to the next sbuf */
+  spca50x->cursbuf = (spca50x->cursbuf + 1) % SPCA50X_NUMSBUF;
+
+  urb->dev = spca50x->dev;
+  urb->status = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 4)
+  if ((i = usb_submit_urb (urb, GFP_ATOMIC)) != 0)
+    err ("usb_submit_urb() ret %d", i);
+#else
+/* If we use urb->next usb_submit_urb() is not need in 2.4.x */
+  //if ((i = usb_submit_urb(urb)) != 0)
+  //err("usb_submit_urb() ret %d", i);
+#endif
+
+  return;
+}
+
+
+/**********************************************************************
+* spca50x_init_isoc
+* Function starts the ISO USB transfer by enabling this process
+* from USB side and enabling ISO machine from the chip side
+***********************************************************************/
+static inline void
+spcaCameraStart (struct usb_spca50x *spca50x)
+{
+  switch (spca50x->bridge)
+    {
+    case BRIDGE_SN9CXXX:
+      sn9cxxx_start(spca50x);
+       break;
+    case BRIDGE_ZC3XX:
+      zc3xx_start (spca50x);
+      break;
+    case BRIDGE_SPCA504:      
+    case BRIDGE_SPCA504C:      
+    case BRIDGE_SPCA536:      
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+      {
+	sp5xxfw2_start(spca50x);
+	break;
+      }
+
+    }
+
+}
+
+static inline void
+spcaCameraStop (struct usb_spca50x *spca50x)
+{
+
+  switch (spca50x->bridge)
+    {
+    case BRIDGE_SN9CXXX:
+      sn9cxxx_stop (spca50x);
+      break;
+
+
+    case BRIDGE_ZC3XX:
+      zc3xx_stop (spca50x);
+      break;
+
+    case BRIDGE_SPCA504C:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA536:
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+      {
+	sp5xxfw2_stop (spca50x);
+	break;
+      }
+
+    }
+
+}
+static int
+spca50x_init_isoc (struct usb_spca50x *spca50x)
+{
+
+  struct urb *urb;
+  int fx, err, n;
+
+  PDEBUG (3, "*** Initializing capture ***");
+/* reset iso context */
+  spca50x->compress = compress;
+  spca50x->curframe = 0;
+  spca50x->cursbuf = 0;
+  spca50x->frame[0].seq = -1;
+  spca50x->lastFrameRead = -1;
+  
+  spca50x_set_packet_size (spca50x, spca50x->pipe_size);
+  PDEBUG (2, "setpacketsize %d", spca50x->pipe_size);
+
+  for (n = 0; n < SPCA50X_NUMSBUF; n++)
+    {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+      urb = usb_alloc_urb (FRAMES_PER_DESC, GFP_KERNEL);
+#else
+      urb = usb_alloc_urb (FRAMES_PER_DESC);
+#endif
+      if (!urb)
+	{
+	  err ("init isoc: usb_alloc_urb ret. NULL");
+	  return -ENOMEM;
+	}
+      spca50x->sbuf[n].urb = urb;
+      urb->dev = spca50x->dev;
+      urb->context = spca50x;
+
+	urb->pipe = usb_rcvisocpipe (spca50x->dev, SPCA50X_ENDPOINT_ADDRESS);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+      urb->transfer_flags = URB_ISO_ASAP;
+      urb->interval = 1;
+#else
+      urb->transfer_flags = USB_ISO_ASAP;
+#endif
+      urb->transfer_buffer = spca50x->sbuf[n].data;
+      urb->complete = spca50x_isoc_irq;
+      urb->number_of_packets = FRAMES_PER_DESC;
+      urb->transfer_buffer_length = spca50x->packet_size * FRAMES_PER_DESC;
+      for (fx = 0; fx < FRAMES_PER_DESC; fx++)
+	{
+	  urb->iso_frame_desc[fx].offset = spca50x->packet_size * fx;
+	  urb->iso_frame_desc[fx].length = spca50x->packet_size;
+	}
+    }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,41)
+  spca50x->sbuf[SPCA50X_NUMSBUF - 1].urb->next = spca50x->sbuf[0].urb;
+  for (n = 0; n < SPCA50X_NUMSBUF - 1; n++)
+    spca50x->sbuf[n].urb->next = spca50x->sbuf[n + 1].urb;
+#endif
+  spcaCameraStart (spca50x);
+  PDEBUG (5, "init isoc int %d altsetting %d", spca50x->iface, spca50x->alt);
+  for (n = 0; n < SPCA50X_NUMSBUF; n++)
+    {
+      spca50x->sbuf[n].urb->dev = spca50x->dev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,41)
+      err = usb_submit_urb (spca50x->sbuf[n].urb, GFP_KERNEL);
+#else
+      err = usb_submit_urb (spca50x->sbuf[n].urb);
+#endif
+      if (err){
+	err ("init isoc: usb_submit_urb(%d) ret %d", n, err);
+	return err;
+	}
+    }
+
+  for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+    {
+      spca50x->frame[n].grabstate = FRAME_UNUSED;
+      spca50x->frame[n].scanstate = STATE_SCANNING;
+    }
+
+  spca50x->streaming = 1;
+
+  return 0;
+
+}
+
+
+/**********************************************************************
+* spca50x_stop_isoc
+* Function stops the USB ISO pipe by stopping the chip ISO machine
+* and stopping USB transfer
+***********************************************************************/
+static void
+spca5xx_kill_isoc (struct usb_spca50x *spca50x)
+{
+  int n;
+
+  if (!spca50x)
+    return;
+
+  PDEBUG (3, "*** killing capture ***");
+  spca50x->streaming = 0;
+
+  /* Unschedule all of the iso td's */
+  for (n = SPCA50X_NUMSBUF - 1; n >= 0; n--)
+    {
+      if (spca50x->sbuf[n].urb)
+	{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
+	  usb_kill_urb (spca50x->sbuf[n].urb);
+#else
+	  usb_unlink_urb (spca50x->sbuf[n].urb);
+#endif
+	  usb_free_urb (spca50x->sbuf[n].urb);
+	  spca50x->sbuf[n].urb = NULL;
+	}
+    }
+
+  PDEBUG (3, "*** Isoc killed ***");
+}
+
+static void
+spca50x_stop_isoc (struct usb_spca50x *spca50x)
+{
+
+  if (!spca50x->streaming || !spca50x->dev)
+    return;
+
+  PDEBUG (3, "*** Stopping capture ***");
+  spcaCameraStop (spca50x);
+  spca5xx_kill_isoc(spca50x);
+  spca50x_set_packet_size (spca50x, 0);
+
+  PDEBUG (3, "*** Capture stopped ***");
+}
+
+/**********************************************************************
+* spca50x_smallest_mode_index
+* Function finds the mode index in the modes table of the smallest
+* available mode.
+***********************************************************************/
+static int spca5xx_getDefaultMode(struct usb_spca50x *spca50x)
+{
+  int i;
+  for (i = QCIF;i < TOTMODE; i++){
+  if(spca50x->mode_cam[i].method == 0 && spca50x->mode_cam[i].width){
+		spca50x->width = spca50x->mode_cam[i].width;
+		spca50x->height = spca50x->mode_cam[i].height;
+		spca50x->method = 0;
+		spca50x->pipe_size = spca50x->mode_cam[i].pipe ;
+		spca50x->mode = spca50x->mode_cam[i].mode;
+		return 0;
+		}
+  }
+return -EINVAL;
+}
+
+
+/**********************************************************************
+* spca50x_set_mode
+* Function sets up the resolution directly. 
+* Attention!!! index, the index in modes array is NOT checked. 
+***********************************************************************/
+static int spca5xx_getcapability(struct usb_spca50x *spca50x )
+{
+	
+	int maxw,maxh,minw,minh;
+	int i;
+	minw = minh = 255*255;
+	maxw = maxh = 0;
+	for (i = QCIF; i < TOTMODE; i++){
+	if( spca50x->mode_cam[i].width){
+	  if (maxw < spca50x->mode_cam[i].width || maxh < spca50x->mode_cam[i].height){
+	    maxw = spca50x->mode_cam[i].width;
+	    maxh = spca50x->mode_cam[i].height;
+	  }
+	  if (minw > spca50x->mode_cam[i].width || minh > spca50x->mode_cam[i].height){
+	    minw = spca50x->mode_cam[i].width;
+	    minh = spca50x->mode_cam[i].height;
+	  }
+	 }
+	}
+	spca50x->maxwidth = maxw;
+	spca50x->maxheight = maxh;
+	spca50x->minwidth = minw;
+	spca50x->minheight = minh;
+	PDEBUG(0,"maxw %d maxh %d minw %d minh %d",maxw,maxh,minw,minh);	
+return 0;
+}
+static inline int v4l_to_spca5xx(int format)
+{switch(format){
+    case VIDEO_PALETTE_RGB565: return P_RGB16;
+    case VIDEO_PALETTE_RGB24: return P_RGB24;
+    case VIDEO_PALETTE_RGB32: return P_RGB32;
+    case VIDEO_PALETTE_YUV422P: return P_YUV422;
+    case VIDEO_PALETTE_YUV420P: return P_YUV420;
+    case VIDEO_PALETTE_RAW_JPEG: return P_RAW;
+    case VIDEO_PALETTE_JPEG: return P_JPEG;
+    default: return -EINVAL;
+   }
+} 
+static inline int spca5xx_setMode(struct usb_spca50x *spca50x,int width,int height,int format)
+{
+  int i,j;
+  int formatIn;
+  int crop = 0, cropx1 = 0, cropx2 = 0, cropy1 = 0, cropy2 = 0, x = 0, y = 0;
+   /* Avoid changing to already selected mode */
+   /* convert V4l format to our internal format */
+   PDEBUG(2,"Set mode asked w %d h %d p %d",width,height,format);
+  
+  if ((formatIn = v4l_to_spca5xx(format)) < 0) 
+    return -EINVAL;
+  for (i = QCIF; i< TOTMODE; i++){
+    if((spca50x->mode_cam[i].width == width) &&
+     (spca50x->mode_cam[i].height == height) &&
+     (spca50x->mode_cam[i].t_palette & formatIn)){
+        spca50x->width = spca50x->mode_cam[i].width;
+        spca50x->height = spca50x->mode_cam[i].height;
+        spca50x->pipe_size = spca50x->mode_cam[i].pipe ;
+        spca50x->mode = spca50x->mode_cam[i].mode;
+	spca50x->method = spca50x->mode_cam[i].method;
+	spca50x->format = format; //palette in use
+     if(spca50x->method){
+     if (spca50x->method == 1){
+      for (j = i; j < TOTMODE ; j++){
+       if(spca50x->mode_cam[j].method == 0 && spca50x->mode_cam[j].width){
+        spca50x->hdrwidth = spca50x->mode_cam[j].width;
+        spca50x->hdrheight = spca50x->mode_cam[j].height;
+	spca50x->mode = spca50x->mode_cam[j].mode; // overwrite by the hardware mode
+        break;
+       }
+      } // end match hardware mode
+      if (!spca50x->hdrwidth && !spca50x->hdrheight)
+          return -EINVAL;  
+     } 
+     }
+    /* match found */
+    break;
+    }
+   } // end match mode
+  /* initialize the hdrwidth and hdrheight for the first init_source */
+  /* precompute the crop x y value for each frame */
+  if (!spca50x->method)
+    {
+      /* nothing todo hardware found stream */
+      cropx1 = cropx2 = cropy1 = cropy2 = x = y = 0;
+      spca50x->hdrwidth = spca50x->width;
+      spca50x->hdrheight = spca50x->height;
+    }
+  if (spca50x->method & 0x01)
+    {
+      /* cropping method */
+      if (spca50x->hdrwidth > spca50x->width)
+	{
+
+	  crop = (spca50x->hdrwidth - spca50x->width);
+	  if (spca50x->cameratype == JPEG || spca50x->cameratype == JPGH || spca50x->cameratype == JPGS)
+	    crop = crop >> 4;
+	  cropx1 = crop >> 1;
+	  cropx2 = cropx1 + (crop % 2);
+	}
+      else
+	{
+	  cropx1 = cropx2 = 0;
+	}
+      if (spca50x->hdrheight > spca50x->height)
+	{
+	  crop = (spca50x->hdrheight - spca50x->height);
+	  if (spca50x->cameratype == JPEG)
+	    crop = crop >> 4;
+	  if (spca50x->cameratype == JPGH || spca50x->cameratype == JPGS)
+	    crop = crop >> 3;
+	  cropy1 = crop >> 1;
+	  cropy2 = cropy1 + (crop % 2);
+	}
+      else
+	{
+	  cropy1 = cropy2 = 0;
+	}
+    }
+  if (spca50x->method & 0x02)
+    {
+      /* what can put here for div method */
+    }
+  if (spca50x->method & 0x04)
+    {
+      /* and here for mult */
+    }
+  PDEBUG (2, "Found code %d method %d", spca50x->mode, spca50x->method);
+  PDEBUG (2, "Soft Win width height %d x %d", spca50x->width,
+	  spca50x->height);
+  PDEBUG (2, "Hard Win width height %d x %d", spca50x->hdrwidth,
+	  spca50x->hdrheight);
+
+  for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+    {
+      spca50x->frame[i].method = spca50x->method;
+      spca50x->frame[i].cameratype = spca50x->cameratype;
+      spca50x->frame[i].cropx1 = cropx1;
+      spca50x->frame[i].cropx2 = cropx2;
+      spca50x->frame[i].cropy1 = cropy1;
+      spca50x->frame[i].cropy2 = cropy2;
+      spca50x->frame[i].x = x;
+      spca50x->frame[i].y = y;
+      spca50x->frame[i].hdrwidth = spca50x->hdrwidth;
+      spca50x->frame[i].hdrheight = spca50x->hdrheight;
+      spca50x->frame[i].width = spca50x->width;
+      spca50x->frame[i].height = spca50x->height;
+       spca50x->frame[i].format = spca50x->format;
+      spca50x->frame[i].scanlength = spca50x->width * spca50x->height * 3 / 2;
+      // ?? assumes 4:2:0 data
+    }
+
+  return 0;  
+}
+
+/**********************************************************************
+* spca50x_mode_init_regs
+* Function sets up the resolution with checking if it's necessary 
+***********************************************************************/
+static int 
+spca5xx_restartMode (struct usb_spca50x *spca50x, int width, int height, int format)
+{
+ int was_streaming;
+ int r;
+ /* Avoid changing to already selected mode */
+  if (spca50x->width == width && spca50x->height == height)
+    return 0;
+PDEBUG (1, "Mode changing to %d,%d", width, height);
+
+  was_streaming = spca50x->streaming;
+  if (was_streaming)    
+	spca50x_stop_isoc (spca50x);
+    
+  r = spca5xx_setMode(spca50x,width,height,format);
+  if (r < 0)
+       goto out;
+  if (was_streaming)
+	  r = spca50x_init_isoc (spca50x);
+out:    
+  return r;
+}
+
+/**********************************************************************
+* spca50x_get_brightness
+* Function reads the brightness from the camera
+* Receives the pointer to the description structure
+* returns the value of brightness
+**********************************************************************/
+static inline __u16
+spca50x_get_brightness (struct usb_spca50x *spca50x)
+{
+  __u16 brightness = 0;		// value of the brightness
+  
+      switch (spca50x->bridge)
+	{
+
+	case BRIDGE_SN9CXXX:
+	  brightness = sn9cxxx_getbrightness (spca50x);
+	  break;
+
+	case BRIDGE_ZC3XX:
+	  brightness = zc3xx_getbrightness (spca50x);
+	  break;
+
+
+
+	case BRIDGE_SPCA536:
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504C:
+	 brightness = sp5xxfw2_getbrightness (spca50x);
+	break;
+	default:
+	  {
+	    brightness = 0;
+	    break;
+	  }
+	}
+    
+  return brightness;
+}
+
+/**********************************************************************
+* spca50x_set_brightness
+* Function sets the brightness to the camera
+* Receives the pointer to the description structure 
+* and brightness value
+**********************************************************************/
+static inline void
+spca50x_set_brightness (struct usb_spca50x *spca50x, __u8 brightness)
+{
+      switch (spca50x->bridge)
+	{
+
+	case BRIDGE_SN9CXXX:
+	spca50x->brightness = brightness << 8;
+	  sn9cxxx_setbrightness (spca50x);
+	break;
+
+	case BRIDGE_ZC3XX:
+	  spca50x->brightness = brightness << 8;
+	  zc3xx_setbrightness (spca50x);
+	  break;
+
+
+	case BRIDGE_SPCA536:
+	case BRIDGE_SPCA533:
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504C:
+	  {
+	  spca50x->brightness = brightness << 8;
+	  sp5xxfw2_setbrightness (spca50x);
+	   
+	    break;
+	  }
+
+	default:
+	  {
+	    break;
+	  }
+	}
+    
+}
+
+
+/**********************************************************************
+ *
+ * SPCA50X data transfer, IRQ handler
+ *
+ **********************************************************************/
+static struct spca50x_frame *
+spca50x_next_frame (struct usb_spca50x *spca50x, unsigned char *cdata)
+{
+  int iFrameNext;
+  struct spca50x_frame *frame = NULL;
+
+  /* Cycle through the frame buffer looking for a free frame to overwrite */
+  iFrameNext = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+  while (frame == NULL && iFrameNext != (spca50x->curframe))
+    {
+      if (spca50x->frame[iFrameNext].grabstate == FRAME_READY ||
+	  spca50x->frame[iFrameNext].grabstate == FRAME_UNUSED ||
+	  spca50x->frame[iFrameNext].grabstate == FRAME_ERROR)
+	{
+	  spca50x->curframe = iFrameNext;
+	  frame = &spca50x->frame[iFrameNext];
+	  break;
+	}
+      else
+	{
+	  iFrameNext = (iFrameNext + 1) % SPCA50X_NUMFRAMES;
+	}
+    }
+
+  if (frame == NULL)
+    {
+      PDEBUG (3, "Can't find a free frame to grab into...using next. "
+	      "This is caused by the application not reading fast enough.");
+      spca50x->curframe = (spca50x->curframe + 1) % SPCA50X_NUMFRAMES;
+      frame = &spca50x->frame[spca50x->curframe];
+    }
+
+  frame->grabstate = FRAME_GRABBING;
+
+  /* Record the frame sequence number the camera has told us */
+  if (cdata)
+    {
+      switch (spca50x->bridge)
+	{
+	case BRIDGE_SPCA504:
+	  frame->seq = cdata[SPCA50X_OFFSET_FRAMSEQ];
+	  break;
+	case BRIDGE_SPCA504C:
+	  frame->seq = cdata[SPCA50X_OFFSET_FRAMSEQ];
+	  break;
+	case BRIDGE_SPCA504B:
+	  frame->seq = cdata[SPCA50X_OFFSET_FRAMSEQ];
+	  break;
+	case BRIDGE_SPCA533:
+	  frame->seq = cdata[SPCA533_OFFSET_FRAMSEQ];
+	  break;
+	case BRIDGE_SPCA536:
+	  frame->seq = cdata[SPCA536_OFFSET_FRAMSEQ];
+	  break;
+	case BRIDGE_ZC3XX: 
+	case BRIDGE_SN9CXXX:
+	 frame->seq=00;
+	 break;
+	}
+    }
+
+  /* Reset some per-frame variables */
+  frame->highwater = frame->data;
+  frame->scanstate = STATE_LINES;
+  frame->scanlength = 0;
+  frame->last_packet = -1;
+  frame->totlength = 0;
+  spca50x->packet = 0;
+  return frame;
+}
+
+/* Tasklet function to decode */
+
+void
+outpict_do_tasklet (unsigned long ptr)
+{
+  int err;
+  struct spca50x_frame *taskletframe = (struct spca50x_frame *) ptr;
+
+  taskletframe->scanlength = taskletframe->highwater - taskletframe->data;
+
+  PDEBUG (2, "Tasklet ask spcadecoder hdrwidth %d hdrheight %d method %d",
+	  taskletframe->hdrwidth, taskletframe->hdrheight,
+	  taskletframe->method);
+  err = spca50x_outpicture (taskletframe);
+  if (err != 0)
+    {
+      PDEBUG (2, "frame decoder failed (%d)", err);
+      taskletframe->grabstate = FRAME_ERROR;
+    }
+  else
+    {
+      taskletframe->grabstate = FRAME_DONE;
+    }
+  if (waitqueue_active (&taskletframe->wq))
+    wake_up_interruptible (&taskletframe->wq);
+
+}
+
+/* ******************************************************************
+* spca50x_move_data
+* Function serves for moving data from USB transfer buffers
+* to internal driver frame buffers.
+******************************************************************* */
+static int
+spca50x_move_data (struct usb_spca50x *spca50x, struct urb *urb)
+{
+  unsigned char *cdata;		//Pointer to buffer where we do store next packet
+  unsigned char *pData;		//Pointer to buffer where we do store next packet
+  int i;
+  struct spca50x_frame *frame;	//Pointer to frame data
+  int iPix;			//Offset of pixel data in the ISO packet
+
+  int totlen = 0;
+  int tv8532 = 0;
+
+  for (i = 0; i < urb->number_of_packets; i++)
+    {
+      int datalength = urb->iso_frame_desc[i].actual_length;
+      int st = urb->iso_frame_desc[i].status;
+      int sequenceNumber;
+      int sof;
+
+      /* PDEBUG(5,"Packet data [%d,%d,%d]", datalength, st,
+         urb->iso_frame_desc[i].offset); */
+
+      urb->iso_frame_desc[i].actual_length = 0;
+      urb->iso_frame_desc[i].status = 0;
+
+      cdata = ((unsigned char *) urb->transfer_buffer) +
+	urb->iso_frame_desc[i].offset;
+      /* Check for zero length block or no selected frame buffer */
+      if (!datalength || spca50x->curframe == -1)
+	{
+	  tv8532 = 0;
+	  continue;
+	}
+
+      PDEBUG (5, "Packet data [%d,%d,%d] Status: %d", datalength, st,
+	      urb->iso_frame_desc[i].offset, st);
+
+      if (st)
+	PDEBUG (2, "data error: [%d] len=%d, status=%d", i, datalength, st);
+
+      frame = &spca50x->frame[spca50x->curframe];
+      totlen = frame->totlength;
+
+      /* read the sequence number */
+      if (spca50x->bridge == BRIDGE_ZC3XX ||
+	  spca50x->bridge == BRIDGE_SN9CXXX )
+	{
+	  if (frame->last_packet == -1)
+	    {
+	      /*initialize a new frame */
+	      sequenceNumber = 0;
+	    }
+	  else
+	    {
+	      sequenceNumber = frame->last_packet;
+	    }
+	}
+      else
+	{
+	  sequenceNumber = cdata[SPCA50X_OFFSET_SEQUENCE];
+	  PDEBUG (4, "Packet start  %x %x %x %x %x", cdata[0], cdata[1],
+		  cdata[2], cdata[3], cdata[4]);
+	}
+      /* check frame start */
+      switch (spca50x->bridge)
+	{
+	case BRIDGE_SN9CXXX:
+		iPix = 0;
+		sof = datalength - 64;
+		if (sof < 0)
+			sequenceNumber++;
+		else if(cdata[sof] == 0xff && cdata[sof +1] == 0xd9){
+			 sequenceNumber = 0; //start of frame
+			 // copy the end of data frame
+	  		memcpy (frame->highwater, cdata, sof+2);
+      			frame->highwater += (sof+2);
+      			totlen += (sof+2);
+#if 0
+			spin_lock(&spca50x->v4l_lock);
+			spca50x->avg_lum = (cdata[sof+24] + cdata[sof+26]) >> 1 ;
+			spin_unlock(&spca50x->v4l_lock);
+			PDEBUG (5,"mean luma %d",spca50x->avg_lum );
+#endif
+			PDEBUG (5,
+			"Sonix header packet found datalength %d totlength %d!!",
+			  datalength, totlen);
+			  PDEBUG(5,"%03d %03d %03d %03d %03d %03d %03d %03d",cdata[sof+24], cdata[sof+25],
+			  cdata[sof+26] , cdata[sof+27], cdata[sof+28], cdata[sof+29],
+			  cdata[sof+30], cdata[sof+31]);	
+			// setting to skip the rest of the packet
+			spca50x->header_len = datalength;
+			} else
+				sequenceNumber++;
+	break;
+	case BRIDGE_ZC3XX:
+	  {
+	    iPix = 0;
+	    if (cdata[0] == 0xFF && cdata[1] == 0xD8)
+	      {
+		sequenceNumber = 0;
+		spca50x->header_len = 2;	//18 remove 0xff 0xd8;
+		PDEBUG (5,
+			"Zc301 header packet found datalength %d totlength %d!!",
+			datalength, totlen);
+	      }
+	    else
+	      {
+		sequenceNumber++;
+	      }
+
+	  }
+	  break;
+	case BRIDGE_SPCA533:
+	  {
+	    iPix = 1;
+	    if (sequenceNumber == SPCA50X_SEQUENCE_DROP)
+	      {
+		if (cdata[1] == 0x01)
+		  {
+		    sequenceNumber = 0;
+		  }
+		else
+		  {
+		    /* drop packet */
+		    PDEBUG (5, "Dropped packet (expected seq 0x%02x)",
+			    frame->last_packet + 1);
+		    continue;
+		  }
+	      }
+	    else
+	      {
+		sequenceNumber++;
+	      }
+	  }
+	  break;
+	case BRIDGE_SPCA536:
+	  {
+	    iPix = 2;
+	    if (sequenceNumber == SPCA50X_SEQUENCE_DROP)
+	      {
+		sequenceNumber = 0;
+	      }
+	    else
+	      {
+		sequenceNumber++;
+	      }
+	  }
+	  break;
+	case BRIDGE_SPCA504:
+	case BRIDGE_SPCA504B:
+	case BRIDGE_SPCA504C:
+	  {
+	    iPix = 1;
+	    switch (sequenceNumber)
+	      {
+	      case 0xfe:
+		sequenceNumber = 0;
+		break;
+	      case SPCA50X_SEQUENCE_DROP:
+		/* drop packet */
+		PDEBUG (5, "Dropped packet (expected seq 0x%02x)",
+			frame->last_packet + 1);
+		continue;
+	      default:
+		sequenceNumber++;
+		break;
+	      }
+	  }
+	  break;
+
+	default:
+	  {
+	    iPix = 1;
+	    /* check if this is a drop packet */
+	    if (sequenceNumber == SPCA50X_SEQUENCE_DROP)
+	      {
+		PDEBUG (3, "Dropped packet (expected seq 0x%02x)",
+			frame->last_packet + 1);
+		continue;
+	      }
+	  }
+	  break;
+	}
+
+      PDEBUG (3, "spca50x: Packet seqnum = 0x%02x.  curframe=%2d",
+	      sequenceNumber, spca50x->curframe);
+      pData = cdata;
+
+      /* Can we find a frame start */
+      if (sequenceNumber == 0)
+	{
+	  totlen = 0;
+	  iPix = spca50x->header_len;
+	  PDEBUG (3, "spca50x: Found Frame Start!, framenum = %d",
+		  spca50x->curframe);
+	  // Start of frame is implicit end of previous frame
+	  // Check for a previous frame and finish it off if one exists
+	  if (frame->scanstate == STATE_LINES){
+
+	      if (frame->format != VIDEO_PALETTE_RAW_JPEG)
+		{
+		  /* Decode the frame */
+		 
+		tasklet_init (&spca50x->spca5xx_tasklet, outpict_do_tasklet,
+				(unsigned long) frame);
+		tasklet_schedule (&spca50x->spca5xx_tasklet);
+		}
+	      else
+		{
+		  /* RAW DATA stream */
+		  frame->grabstate = FRAME_DONE;
+		  if (waitqueue_active (&frame->wq))
+		    wake_up_interruptible (&frame->wq);
+		}
+	      // If someone decided to wait for ANY frame - wake him up 
+	      if (waitqueue_active (&spca50x->wq))
+		wake_up_interruptible (&spca50x->wq);
+	      frame = spca50x_next_frame (spca50x, cdata);
+	    }
+	  else
+	    frame->scanstate = STATE_LINES;
+	}
+
+      /* Are we in a frame? */
+      if (frame == NULL || frame->scanstate != STATE_LINES)
+	continue;
+      if (sequenceNumber != frame->last_packet + 1 &&
+	  frame->last_packet != -1)
+	{
+	  /* Note, may get one of these for the first packet after opening */
+	  PDEBUG (2, "Out of order packet, last = %d, this = %d",
+		  frame->last_packet, sequenceNumber);
+
+	}
+      frame->last_packet = sequenceNumber;
+
+      /* This is the real conversion of the raw camera data to BGR for V4L */
+      datalength -= iPix;	// correct length for packet header
+      pData = cdata + iPix;	// Skip packet header (1 or 10 bytes)
+
+      // Consume data
+      PDEBUG (5, "Processing packet seq  %d,length %d,totlength %d",
+	      frame->last_packet, datalength, frame->totlength);
+      /* this copy consume input data from the isoc stream */
+      if ((datalength > 0) && (datalength <= 0x3ff)){
+      memcpy (frame->highwater, pData, datalength);
+      frame->highwater += datalength;
+      totlen += datalength;
+      }
+      	
+      frame->totlength = totlen;
+#ifdef SPCA50X_ENABLE_EXP_BRIGHTNESS
+      /* autoadjust is set to 1 to so now autobrightness will be
+         calculated frome this frame. autoadjust will be set to 0 when
+         autobrightness has been corrected if needed. */
+      autoadjust = 1;
+#endif /* SPCA50X_ENABLE_EXP_BRIGHTNESS */
+
+
+    }
+  return totlen;
+}
+
+
+/****************************************************************************
+ *
+ * Buffer management
+ *
+ ***************************************************************************/
+static int
+spca50x_alloc (struct usb_spca50x *spca50x)
+{
+  int i;
+
+  PDEBUG (4, "entered");
+  down (&spca50x->buf_lock);
+  spca50x->tmpBuffer = rvmalloc (MAX_FRAME_SIZE);
+  if (spca50x->buf_state == BUF_ALLOCATED)
+    goto out;
+
+  spca50x->fbuf = rvmalloc (SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+  if (!spca50x->fbuf)
+    goto error;
+
+  for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+    {
+      spca50x->frame[i].tmpbuffer = spca50x->tmpBuffer;
+      spca50x->frame[i].decoder = &spca50x->maindecode; //connect each frame to the main data decoding 
+      spca50x->frame[i].grabstate = FRAME_UNUSED;
+      spca50x->frame[i].scanstate = STATE_SCANNING;
+      spca50x->frame[i].data = spca50x->fbuf + i * MAX_DATA_SIZE;
+      spca50x->frame[i].highwater = spca50x->frame[i].data;
+      PDEBUG (4, "frame[%d] @ %p", i, spca50x->frame[i].data);
+    }
+
+  for (i = 0; i < SPCA50X_NUMSBUF; i++)
+    {
+      spca50x->sbuf[i].data = kmalloc (FRAMES_PER_DESC *
+				       MAX_FRAME_SIZE_PER_DESC, GFP_KERNEL);
+      if (!spca50x->sbuf[i].data)
+	goto error;
+      PDEBUG (4, "sbuf[%d] @ %p", i, spca50x->sbuf[i].data);
+    }
+  spca50x->buf_state = BUF_ALLOCATED;
+out:
+  up (&spca50x->buf_lock);
+  PDEBUG (4, "leaving");
+  return 0;
+error:
+  /* FIXME: IMHO, it's better to move error deallocation code here. */
+
+  for (i = 0; i < SPCA50X_NUMSBUF; i++)
+    {
+
+      if (spca50x->sbuf[i].data)
+	{
+	  kfree (spca50x->sbuf[i].data);
+	  spca50x->sbuf[i].data = NULL;
+	}
+    }
+  if (spca50x->fbuf)
+    {
+      rvfree (spca50x->fbuf, SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+      spca50x->fbuf = NULL;
+    }
+  if (spca50x->tmpBuffer)
+    {
+      rvfree (spca50x->tmpBuffer, MAX_FRAME_SIZE);
+      spca50x->tmpBuffer = NULL;
+    }
+
+  spca50x->buf_state = BUF_NOT_ALLOCATED;
+  up (&spca50x->buf_lock);
+  PDEBUG (1, "errored");
+  return -ENOMEM;
+}
+
+static void
+spca5xx_dealloc (struct usb_spca50x *spca50x )
+{
+  int i;
+  PDEBUG (2, "entered dealloc");
+  down (&spca50x->buf_lock);
+  if (spca50x->fbuf)
+    {
+      rvfree (spca50x->fbuf, SPCA50X_NUMFRAMES * MAX_DATA_SIZE);
+      spca50x->fbuf = NULL;
+      for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+	spca50x->frame[i].data = NULL;
+    }
+
+  if (spca50x->tmpBuffer)
+    {
+      rvfree (spca50x->tmpBuffer, MAX_FRAME_SIZE);
+      spca50x->tmpBuffer = NULL;
+    }
+
+  for (i = 0; i < SPCA50X_NUMSBUF; i++)
+    {
+      if (spca50x->sbuf[i].data)
+	{
+	  kfree (spca50x->sbuf[i].data);
+	  spca50x->sbuf[i].data = NULL;
+	}
+    }
+
+  PDEBUG (2, "buffer memory deallocated");
+  spca50x->buf_state = BUF_NOT_ALLOCATED;
+  up (&spca50x->buf_lock);
+  PDEBUG (2, "leaving dealloc");
+}
+/**
+ * Reset the camera and send the correct initialization sequence for the
+ * currently selected source
+ */
+static int
+spca50x_init_source (struct usb_spca50x *spca50x)
+{
+  int err_code;
+
+  switch (spca50x->bridge)
+    {
+    case BRIDGE_SN9CXXX:
+      err_code = sn9cxxx_init (spca50x);
+      PDEBUG (2, "Initializing Sonix finished %d",err_code);
+      if (err_code < 0) return err_code;
+      break;
+
+    case BRIDGE_ZC3XX:
+      err_code = zc3xx_init (spca50x);
+      break;
+
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504C:
+    case BRIDGE_SPCA536:
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504B:
+      {
+	PDEBUG (2, "Opening SPCA5xx FW2");
+	sp5xxfw2_init (spca50x);
+	break;
+      }
+
+    default:
+      {
+	err ("Unimplemented bridge type");
+	return -EINVAL;
+      }
+    }
+  spca50x->norme = 0;
+  spca50x->channel = 0;
+
+     err_code =spca5xx_setMode(spca50x,spca50x->width,spca50x->height,VIDEO_PALETTE_JPEG);
+     PDEBUG(2,"set Mode return %d ", err_code);
+     if (err_code < 0) return -EINVAL;
+
+  return 0;
+}
+
+
+/****************************************************************************
+ *
+ * V4L API
+ *
+ ***************************************************************************/
+static inline void spca5xx_setFrameDecoder(struct usb_spca50x *spca50x)
+{ int i;
+  /* Set default sizes in case IOCTL (VIDIOCMCAPTURE) is not used
+   * (using read() instead). */
+  for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+    {
+      spca50x->frame[i].width = spca50x->width;
+      spca50x->frame[i].height = spca50x->height;
+      spca50x->frame[i].cameratype = spca50x->cameratype;
+      spca50x->frame[i].scanlength = 0;
+      spca50x->frame[i].depth = 8;
+      spca50x->frame[i].format = VIDEO_PALETTE_JPEG;
+    }
+}
+
+static inline void spca5xx_initDecoder(struct usb_spca50x *spca50x)
+{
+  if (spca50x->cameratype == JPEG)
+    init_jpeg_decoder (spca50x,2);
+  if (spca50x->cameratype == JPGH 
+     || spca50x->cameratype == JPGC
+     || spca50x->cameratype == JPGS)
+    init_jpeg_decoder (spca50x,1);
+  if (spca50x->cameratype == JPGM)
+    init_jpeg_decoder (spca50x,0);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+static int
+spca5xx_open (struct inode *inode, struct file *file)
+{
+  struct video_device *vdev = video_devdata (file);
+#else
+static int
+spca5xx_open(struct video_device *vdev, int flags)
+{
+#endif
+  struct usb_spca50x *spca50x = video_get_drvdata (vdev);
+
+  int err;
+  
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  MOD_INC_USE_COUNT;
+#endif
+  PDEBUG (2, "opening");
+
+  down (&spca50x->lock);
+  /* sanity check disconnect, in use, no memory available */
+  err = -ENODEV;
+  if (!spca50x->present)
+    goto out;
+  err = -EBUSY;
+  if (spca50x->user)
+    goto out;
+  err = -ENOMEM;
+  if (spca50x_alloc (spca50x))
+    goto out;
+ /* initialize sensor and decoding */
+  err = spca50x_init_source (spca50x);
+  if (err != 0){
+  	PDEBUG (0, "DEALLOC error on spca50x_init_source\n");
+	up (&spca50x->lock);
+  	spca5xx_dealloc (spca50x);
+    goto out2;
+    }
+  spca5xx_initDecoder(spca50x);
+   /* open always start in rgb24 a bug in gqcam 
+    did not select the palette nor the size  
+    v4l spec need that the camera always start on the last setting*/ 
+  spca5xx_setFrameDecoder(spca50x);
+ 
+  spca50x->user++;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22) 
+  file->private_data = vdev;
+#endif 
+  err = spca50x_init_isoc (spca50x);
+  if (err)
+    {
+      PDEBUG (0, " DEALLOC error on init_Isoc\n");
+      spca50x->user--;
+      spca5xx_kill_isoc (spca50x);
+      up (&spca50x->lock);
+      spca5xx_dealloc (spca50x);
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22) 
+      file->private_data = NULL;
+#endif      
+      goto out2;
+    }
+
+  /* Now, let's get brightness from the camera */
+  spca50x->brightness = spca50x_get_brightness (spca50x) << 8;
+
+
+out:
+  up (&spca50x->lock);
+out2:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  if (err)
+    MOD_DEC_USE_COUNT;
+#endif
+
+  if (err)
+    {
+      PDEBUG (2, "Open failed");
+    }
+  else
+    {
+      PDEBUG (2, "Open done");
+    }
+
+  return err;
+}
+
+static void inline
+spcaCameraShutDown (struct usb_spca50x *spca50x)
+{
+  if (spca50x->dev)
+    {
+      if (spca50x->bridge == BRIDGE_ZC3XX)
+	
+	  zc3xx_shutdown (spca50x);
+	
+    }
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+static int
+spca5xx_close (struct inode *inode, struct file *file)
+{
+
+  struct video_device *vdev = file->private_data;
+#else
+static void 
+spca5xx_close( struct video_device *vdev)
+{
+#endif
+  struct usb_spca50x *spca50x = video_get_drvdata (vdev);
+  int i;
+  PDEBUG (2, "spca50x_close");
+
+  down (&spca50x->lock);
+
+  spca50x->user--;
+  spca50x->curframe = -1;
+  if (spca50x->present)
+    {
+      spca50x_stop_isoc (spca50x);
+      spcaCameraShutDown (spca50x);
+    
+
+  for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+    {
+      if (waitqueue_active (&spca50x->frame[i].wq))
+	wake_up_interruptible (&spca50x->frame[i].wq);
+    }
+  if (waitqueue_active (&spca50x->wq))
+    wake_up_interruptible (&spca50x->wq);
+
+  }  
+  /* times to dealloc ressource */
+   up (&spca50x->lock);
+  spca5xx_dealloc (spca50x);
+  PDEBUG(2,"Release ressources done");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  MOD_DEC_USE_COUNT;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+  file->private_data = NULL;
+  return 0;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+static int
+spca5xx_do_ioctl (struct inode *inode, struct file *file, unsigned int cmd,
+		  void *arg)
+{
+  struct video_device *vdev = file->private_data;
+#else
+static int 
+spca5xx_ioctl (struct video_device *vdev, unsigned int cmd, void *arg)
+{
+#endif
+  struct usb_spca50x *spca50x = video_get_drvdata (vdev);
+
+  PDEBUG (2, "do_IOCtl: 0x%X", cmd);
+
+  if (!spca50x->dev)
+    return -EIO;
+
+  switch (cmd)
+    {
+    case VIDIOCGCAP:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	 struct video_capability *b = arg;
+#else
+	 struct video_capability j ;
+	 struct video_capability *b = &j;
+#endif	
+	PDEBUG (2, "VIDIOCGCAP %p :", b);
+
+	memset (b, 0, sizeof (struct video_capability));
+	snprintf (b->name, 32, "%s", clist[spca50x->desc].description);
+	b->type = VID_TYPE_CAPTURE;
+	b->channels = 1;
+	b->audios = 0;
+	b->maxwidth = spca50x->maxwidth;
+	b->maxheight = spca50x->maxheight;
+
+	b->minwidth = spca50x->minwidth;
+	b->minheight = spca50x->minheight;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+	if(copy_to_user(arg,b,sizeof(struct video_capability)))
+	return -EFAULT;
+#endif
+
+	return 0;
+      }
+    case VIDIOCGCHAN:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	 struct video_channel *v = arg;
+#else
+	 struct video_channel k ;
+	 struct video_channel *v = &k;
+	 if(copy_from_user(v,arg,sizeof(struct video_channel)))
+	 return -EFAULT;
+#endif	 	
+	switch (spca50x->bridge)
+	  {
+	  case BRIDGE_SPCA504:
+	  case BRIDGE_SPCA504B:
+	  case BRIDGE_SPCA504C:
+	  case BRIDGE_SPCA533:
+	  case BRIDGE_SPCA536:
+	  case BRIDGE_ZC3XX:
+	  case BRIDGE_SN9CXXX:
+	    {
+	      snprintf (v->name, 32, "%s", Blist[spca50x->bridge].name);
+	      break;
+	    }
+	  }
+
+	v->flags = 0;
+	v->tuners = 0;
+	v->type = VIDEO_TYPE_CAMERA;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+	if(copy_to_user(arg,v,sizeof(struct video_channel)))
+	return -EFAULT;
+#endif	
+
+	return 0;
+      }
+    case VIDIOCSCHAN:
+      {
+	/* 
+	   There seems to be some confusion as to whether this is a struct 
+	   video_channel or an int. This should be safe as the first element 
+	   of video_channel is an int channel number
+	   and we just ignore the rest 
+	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_channel *v = arg;
+#else
+	 struct video_channel k ;
+	 struct video_channel *v = &k;
+	 if(copy_from_user(v,arg,sizeof(struct video_channel)))
+	 return -EFAULT;
+#endif	
+/* make compiler happy i Hope */
+	v->flags = 0;
+	v->tuners = 0;
+	v->type = VIDEO_TYPE_CAMERA;
+	return 0;
+      }
+    case VIDIOCGPICT:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_picture *p = arg;
+#else	
+	struct video_picture p1 ;
+	struct video_picture *p = &p1;
+#endif	
+
+	p->depth = spca50x->frame[0].depth;
+	p->palette = spca50x->format;
+
+	PDEBUG (4, "VIDIOCGPICT: depth=%d, palette=%d", p->depth, p->palette);
+
+	    switch (spca50x->bridge)
+	      {
+		case BRIDGE_ZC3XX:
+		spca50x->brightness =zc3xx_getbrightness (spca50x);
+		p->brightness = spca50x->brightness;
+		p->contrast = spca50x->contrast;
+		p->colour = spca50x->colour;
+		break;
+	      case BRIDGE_SN9CXXX:	
+		spca50x->brightness = sn9cxxx_getbrightness(spca50x);
+		sn9cxxx_getcontrast(spca50x);
+		//spca50x->colour = sn9cxxx_getcolors(spca50x);
+		p->brightness = spca50x->brightness;
+		p->contrast = spca50x->contrast;
+		p->colour = spca50x->colour;
+		break;
+
+	      case BRIDGE_SPCA536:
+	      case BRIDGE_SPCA533:
+	      case BRIDGE_SPCA504:
+	      case BRIDGE_SPCA504B:
+	      case BRIDGE_SPCA504C:
+		{		
+		  p->colour = sp5xxfw2_getcolors(spca50x);		  
+		  p->whiteness = 0;
+		  p->contrast = sp5xxfw2_getcontrast(spca50x);
+		  p->brightness = spca50x_get_brightness (spca50x);
+		  p->hue = 0;		 
+		  PDEBUG (0,
+			  "color: 0x%02x contrast: 0x%02x brightness: 0x%02x hue: 0x%02x",
+			  p->colour, p->contrast, p->brightness, p->hue);
+		  break;
+		}
+	      default:
+		{
+		  /* default to not allowing any settings to change */
+		  p->colour = spca50x->colour;
+		  p->whiteness = spca50x->whiteness;
+		  p->contrast = spca50x->contrast;
+		  p->brightness = spca50x->brightness;
+		  p->hue = spca50x->hue;
+		  break;
+		}
+	      }
+	  
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+	if(copy_to_user(arg,p,sizeof(struct video_picture)))
+	return -EFAULT;
+#endif	
+
+	return 0;
+      }
+    case VIDIOCSPICT:
+      {
+      	int i;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_picture *p = arg;
+#else	
+	struct video_picture p1 ;
+	struct video_picture *p = &p1;
+	if(copy_from_user(p,arg,sizeof(struct video_picture)))
+	 return -EFAULT;
+#endif	
+	
+
+	PDEBUG (4, "VIDIOCSPICT");
+
+
+	if (!spca5xx_get_depth (spca50x, p->palette))
+	  return -EINVAL;
+
+if(spca50x->format != p->palette){
+/* FIXME test if the palette is available */
+	PDEBUG (4, "Setting depth=%d, palette=%d", p->depth, p->palette);
+	/* change the output palette the input stream is the same*/
+	/* no need to stop the camera streaming and restart */
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+	  {
+	    spca50x->frame[i].depth = p->depth;
+	    spca50x->frame[i].format = p->palette;
+	  }
+	spca50x->format = p->palette;
+}
+
+	    switch (spca50x->bridge)
+	      {
+
+	      case BRIDGE_SN9CXXX:
+	        spca50x->contrast = p->contrast;
+		spca50x->brightness = p->brightness;		
+		sn9cxxx_setbrightness(spca50x);
+		sn9cxxx_setcontrast(spca50x);		
+	        break;
+
+	      case BRIDGE_ZC3XX:
+		spca50x->contrast = p->contrast;
+		spca50x->brightness = p->brightness;
+		zc3xx_setbrightness (spca50x);
+		break;
+
+	      case BRIDGE_SPCA536:
+	      case BRIDGE_SPCA533:
+	      case BRIDGE_SPCA504:
+	      case BRIDGE_SPCA504B:
+	      case BRIDGE_SPCA504C:
+		{		
+		spca50x_set_brightness (spca50x, ((p->brightness >> 8) + 128) % 255);
+		spca50x->contrast = p->contrast;
+		spca50x->colour = p->colour;
+		sp5xxfw2_setcolors(spca50x);
+		sp5xxfw2_setcontrast(spca50x);
+		p->whiteness = 0;
+		
+		  break;
+		}
+
+	      default:
+		{
+		  /* default to not allowing any settings to change ?? */
+		  p->colour = spca50x->colour;
+		  p->whiteness = spca50x->whiteness;
+		  p->contrast = spca50x->contrast;
+		  p->brightness = spca50x->brightness;
+		  p->hue = spca50x->hue;
+		  break;
+		}
+	      }
+	  
+	spca50x->contrast = p->contrast;
+	spca50x->brightness = p->brightness;
+	spca50x->colour = p->colour;
+	spca50x->hue = p->hue;
+	spca50x->whiteness = p->whiteness;
+#ifdef SPCA50X_ENABLE_EXPERIMENTAL
+	spca50x->nstable = 0;
+	spca50x->nunstable = 0;
+#endif /* SPCA50X_ENABLE_EXPERIMENTAL */
+
+	return 0;
+      }
+    case VIDIOCGCAPTURE:
+      {
+	int *vf = arg;
+
+	PDEBUG (4, "VIDIOCGCAPTURE");
+	*vf = 0;
+	// no subcapture
+	return -EINVAL;
+      }
+    case VIDIOCSCAPTURE:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_capture *vc = arg;
+#else	
+	struct video_capture vc1 ;
+	struct video_capture *vc = &vc1;
+	if(copy_from_user(vc,arg,sizeof(struct video_capture)))
+	 return -EFAULT;
+#endif	
+
+	if (vc->flags)
+	  return -EINVAL;
+	if (vc->decimation)
+	  return -EINVAL;
+
+	return -EINVAL;
+      }
+    case VIDIOCSWIN:
+      {
+      	int result;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_window *vw = arg;
+#else	
+	struct video_window vw1 ;
+	struct video_window *vw = &vw1;
+	if(copy_from_user(vw,arg,sizeof(struct video_window)))
+	 return -EFAULT;
+#endif	
+	
+	PDEBUG (3, "VIDIOCSWIN: width=%d, height=%d, flags=%d",
+		vw->width, vw->height, vw->flags);
+	if (vw->x)
+	  return -EINVAL;
+	if (vw->y)
+	  return -EINVAL;
+	if (vw->width > (unsigned int) spca50x->maxwidth)
+	  return -EINVAL;
+	if (vw->height > (unsigned int) spca50x->maxheight)
+	  return -EINVAL;
+	if (vw->width < (unsigned int) spca50x->minwidth)
+	  return -EINVAL;
+	if (vw->height < (unsigned int) spca50x->minheight)
+	  return -EINVAL;
+
+
+	 result = spca5xx_restartMode(spca50x,vw->width,vw->height,spca50x->frame[0].format);
+
+	if (result == 0)
+	  {
+	    spca50x->frame[0].width = vw->width;
+	    spca50x->frame[0].height = vw->height;
+	  }
+
+	return result;
+      }
+    case VIDIOCGWIN:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_window *vw = arg;
+#else	
+	struct video_window vw1 ;
+	struct video_window *vw = &vw1;
+#endif		
+
+	memset (vw, 0, sizeof (struct video_window));
+	vw->x = 0;
+	vw->y = 0;
+	vw->width = spca50x->frame[0].width;
+	vw->height = spca50x->frame[0].height;
+	vw->flags = 0;
+
+	PDEBUG (4, "VIDIOCGWIN: %dx%d", vw->width, vw->height);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+	if(copy_to_user(arg,vw,sizeof(struct video_capture)))
+	return -EFAULT;
+#endif	
+
+	return 0;
+      }
+    case VIDIOCGMBUF:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_mbuf *vm=arg;
+#else	
+	struct video_mbuf vm1;
+	struct video_mbuf *vm = &vm1;
+#endif		
+	int i;
+	PDEBUG (2, "VIDIOCGMBUF: %p ", vm);
+	memset (vm, 0, sizeof (struct video_mbuf));
+	vm->size = SPCA50X_NUMFRAMES * MAX_DATA_SIZE;
+	vm->frames = SPCA50X_NUMFRAMES;
+
+	for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+	  {
+	    vm->offsets[i] = MAX_DATA_SIZE * i;
+	  }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+	if(copy_to_user(arg,vm,sizeof(struct video_mbuf)))
+	return -EFAULT;
+#endif	
+
+	return 0;
+      }
+    case VIDIOCMCAPTURE:
+      {
+      	int ret, depth;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+	struct video_mmap *vm = arg;
+#else	
+	struct video_mmap vm1;
+	struct video_mmap *vm = &vm1;
+	if(copy_from_user(vm,arg,sizeof(struct video_mmap)))
+	 return -EFAULT;
+#endif	
+	
+
+	PDEBUG (2, "CMCAPTURE");
+	PDEBUG (2, "frame: %d, size: %dx%d, format: %d",
+		vm->frame, vm->width, vm->height, vm->format);
+	depth = spca5xx_get_depth (spca50x, vm->format);
+	if (!depth || depth < spca50x->min_bpp)
+	  {
+	    err ("VIDIOCMCAPTURE: invalid format (%d)", vm->format);
+	    return -EINVAL;
+	  }
+
+	if ((vm->frame < 0) || (vm->frame > 3))
+	  {
+	    err ("VIDIOCMCAPTURE: invalid frame (%d)", vm->frame);
+	    return -EINVAL;
+	  }
+
+	if (vm->width > spca50x->maxwidth || vm->height > spca50x->maxheight)
+	  {
+	    err ("VIDIOCMCAPTURE: requested dimensions too big");
+	    return -EINVAL;
+	  }
+	if (vm->width < spca50x->minwidth || vm->height < spca50x->minheight)
+	  {
+	    err ("VIDIOCMCAPTURE: requested dimensions too small");
+	    return -EINVAL;
+	  }
+	/* 
+	 * If we are grabbing the current frame, let it pass
+	 */
+	if (spca50x->frame[vm->frame].grabstate == FRAME_GRABBING)
+	  {
+	    PDEBUG (4, "MCAPTURE: already grabbing");
+	    ret = wait_event_interruptible (spca50x->wq,
+					    (spca50x->frame[vm->frame].
+					     grabstate != FRAME_GRABBING));
+	    if (ret)
+	      return -EINTR;
+
+	  }
+	if ((spca50x->frame[vm->frame].width != vm->width) ||
+	    (spca50x->frame[vm->frame].height != vm->height) ||
+	    (spca50x->frame[vm->frame].format != vm->format))
+	  {
+
+	     ret = spca5xx_restartMode(spca50x,vm->width,vm->height,vm->format);
+
+	    if (ret < 0)
+	      return ret;
+	    spca50x->frame[vm->frame].width = vm->width;
+	    spca50x->frame[vm->frame].height = vm->height;
+	    spca50x->frame[vm->frame].format = vm->format;
+	    spca50x->frame[vm->frame].depth = depth;
+
+	  }
+
+	/* Mark it as ready */
+	spca50x->frame[vm->frame].grabstate = FRAME_READY;
+	return 0;
+      }
+    case VIDIOCSYNC:
+      {
+      	int ret;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+		 unsigned int frame = *((unsigned int *) arg);
+#else	
+		 unsigned int frame ;
+		if(copy_from_user((void*)&frame,arg,sizeof(int)))
+	 return -EFAULT;
+#endif	
+	
+
+	PDEBUG (3, "syncing to frame %d, grabstate = %d", frame,
+		spca50x->frame[frame].grabstate);
+
+	switch (spca50x->frame[frame].grabstate)
+	  {
+	  case FRAME_UNUSED:
+	    return -EINVAL;
+	  case FRAME_ABORTING:
+	    return -ENODEV;
+	  case FRAME_READY:
+	  case FRAME_GRABBING:
+	  case FRAME_ERROR:
+	  redo:
+	    if (!spca50x->dev)
+	      return -EIO;
+
+
+	    ret = wait_event_interruptible (spca50x->wq,
+					    (spca50x->frame[frame].
+					     grabstate == FRAME_DONE));
+	    if (ret)
+	      return -EINTR;
+
+	    PDEBUG (5, "Synched on frame %d, grabstate = %d",
+		    frame, spca50x->frame[frame].grabstate);
+
+	    if (spca50x->frame[frame].grabstate == FRAME_ERROR)
+	      {
+		goto redo;
+	      }
+	    /* Fallthrough.
+	     * We have waited in state FRAME_GRABBING until it
+	     * becomes FRAME_DONE, so now we can move along.
+	     */
+	  case FRAME_DONE:
+
+	    PDEBUG (3, "Already synched %d\n", frame);
+
+	    /* Release the current frame. This means that it
+	     * will be reused as soon as all other frames are
+	     * full, so the app better be done with it quickly.
+	     * Can this be avoided somehow?
+	     */
+	    spca50x->frame[frame].grabstate = FRAME_UNUSED;
+
+	    break;
+	  }			/* end switch */
+
+	return 0;
+      }
+    case VIDIOCGFBUF:
+      {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+		struct video_buffer *vb=arg;
+#else	
+		struct video_buffer vb1;
+		struct video_buffer *vb= &vb1;
+#endif	
+	memset (vb, 0, sizeof (struct video_buffer));
+	vb->base = NULL;	/* frame buffer not supported, not used */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22)
+	if(copy_to_user(arg,vb,sizeof(struct video_buffer)))
+	return -EFAULT;
+#endif	
+
+	return 0;
+      }
+    case VIDIOCKEY:
+      return 0;
+    case VIDIOCCAPTURE:
+      return -EINVAL;
+    case VIDIOCSFBUF:
+      return -EINVAL;
+    case VIDIOCGTUNER:
+    case VIDIOCSTUNER:
+      return -EINVAL;
+    case VIDIOCGFREQ:
+    case VIDIOCSFREQ:
+      return -EINVAL;
+    case VIDIOCGAUDIO:
+    case VIDIOCSAUDIO:
+      return -EINVAL;
+    default:
+      return -ENOIOCTLCMD;
+    }				/* end switch */
+
+  return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+static int
+spca5xx_ioctl (struct inode *inode, struct file *file, unsigned int cmd,
+	       unsigned long arg)
+{
+	int rc;
+#if 0	
+	struct video_device *vdev = file->private_data;
+	struct usb_spca50x *spca50x = video_get_drvdata(vdev);
+	
+
+/* lock the device here is dramatic for latencies */
+	if (down_interruptible(&spca50x->lock))
+		return -EINTR;
+#endif
+  rc = video_usercopy (inode, file, cmd, arg, spca5xx_do_ioctl);
+#if 0
+/* see 7 lines up */ */
+	up(&spca50x->lock);
+#endif
+  return rc;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+static ssize_t
+spca5xx_read (struct file *file, char *buf, size_t cnt, loff_t * ppos)
+{
+
+  struct video_device *dev = file->private_data;
+  int noblock = file->f_flags & O_NONBLOCK;
+  unsigned long count = cnt;
+#else
+static long 
+spca5xx_read(struct video_device *dev, char * buf, unsigned long
+	count,int noblock)
+{
+#endif
+  struct usb_spca50x *spca50x = video_get_drvdata (dev);
+
+  int i;
+  int frmx = -1;
+  int rc;
+  volatile struct spca50x_frame *frame;
+
+  PDEBUG (4, "%ld bytes, noblock=%d", count, noblock);
+if (down_interruptible(&spca50x->lock))
+		return -ERESTARTSYS;
+
+  if (!dev || !buf){
+   	up(&spca50x->lock);
+    return -EFAULT;
+}
+  if (!spca50x->dev){
+   	up(&spca50x->lock);
+    return -EIO;
+}
+  if (!spca50x->streaming){
+   	up(&spca50x->lock);
+    return -EIO;
+}
+/* what noblock can do ?? */
+/* FIXME make compiler happy */
+noblock += 1;
+  /* Wait while we're grabbing the image */
+	PDEBUG(4, "Waiting for a frame done");
+#if (SPCA50X_NUMFRAMES == 4)	
+	if((rc = wait_event_interruptible(spca50x->wq,
+		spca50x->frame[0].grabstate == FRAME_DONE ||
+		spca50x->frame[1].grabstate == FRAME_DONE ||
+		spca50x->frame[2].grabstate == FRAME_DONE ||
+		spca50x->frame[3].grabstate == FRAME_DONE ))){
+	 	up(&spca50x->lock);
+		return rc;
+	}
+#else // should be two 
+	if((rc = wait_event_interruptible(spca50x->wq,
+		spca50x->frame[0].grabstate == FRAME_DONE ||
+		spca50x->frame[1].grabstate == FRAME_DONE ))){
+	 	up(&spca50x->lock);
+		return rc;
+	}
+#endif
+
+  /* One frame has just been set to DONE. Find it. */
+  for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+    if (spca50x->frame[i].grabstate == FRAME_DONE)
+      frmx = i;
+
+  PDEBUG (4, "Frame number: %d", frmx);
+  if (frmx < 0)
+    {
+      /* We havent found a frame that is DONE. Damn. Should
+       * not happen. */
+      PDEBUG (2, "Couldnt find a frame ready to be read.");
+      	up(&spca50x->lock);
+      return -EFAULT;
+    }
+  frame = &spca50x->frame[frmx];
+  PDEBUG (2, "count asked: %d available: %d", (int) count,
+	  (int) frame->scanlength);
+
+  if (count > frame->scanlength)
+    count = frame->scanlength;
+
+  if ((i = copy_to_user (buf, frame->data, count)))
+    {
+      PDEBUG (2, "Copy failed! %d bytes not copied", i);
+      	up(&spca50x->lock);
+      return -EFAULT;
+    }
+  /* Release the frame */
+  frame->grabstate = FRAME_READY;
+
+up(&spca50x->lock);
+  return count;
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,22)
+static int
+spca5xx_mmap (struct file *file, struct vm_area_struct *vma)
+{
+
+  struct video_device *dev = file->private_data;
+  unsigned long start = vma->vm_start;
+  unsigned long size = vma->vm_end - vma->vm_start;
+#else
+static int 
+spca5xx_mmap(struct video_device *dev,const char *adr, unsigned long size)
+{
+  unsigned long start=(unsigned long) adr;
+#endif  
+  struct usb_spca50x *spca50x = video_get_drvdata (dev);
+  unsigned long page, pos;
+
+  if (spca50x->dev == NULL)
+    return -EIO;
+
+  PDEBUG (4, "mmap: %ld (%lX) bytes", size, size);
+
+  if (size >
+      (((SPCA50X_NUMFRAMES * MAX_DATA_SIZE) + PAGE_SIZE - 1) & ~(PAGE_SIZE -
+								 1)))
+    return -EINVAL;
+	if (down_interruptible(&spca50x->lock))
+		return -EINTR;
+
+  pos = (unsigned long) spca50x->fbuf;
+  while (size > 0)
+    {
+      page = kvirt_to_pa (pos);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined (RH9_REMAP)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+      if (remap_pfn_range
+	  (vma, start, page >> PAGE_SHIFT, PAGE_SIZE, PAGE_SHARED)){
+#else
+      if (remap_page_range (vma, start, page, PAGE_SIZE, PAGE_SHARED)){
+#endif /* KERNEL 2.6.9 */
+#else /* RH9_REMAP */
+      if (remap_page_range (start, page, PAGE_SIZE, PAGE_SHARED)){
+#endif /* RH9_REMAP */
+	up(&spca50x->lock);
+	return -EAGAIN;
+	}
+      start += PAGE_SIZE;
+      pos += PAGE_SIZE;
+      if (size > PAGE_SIZE)
+	size -= PAGE_SIZE;
+      else
+	size = 0;
+    }
+up(&spca50x->lock);
+  return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (2,4,22)
+static struct file_operations spca5xx_fops = {
+  .owner = THIS_MODULE,
+  .open = spca5xx_open,
+  .release = spca5xx_close,
+  .read = spca5xx_read,
+  .mmap = spca5xx_mmap,
+  .ioctl = spca5xx_ioctl,
+  .llseek = no_llseek,
+};
+static struct video_device spca50x_template = {
+  .owner = THIS_MODULE,
+  .name = "SPCA5XX USB Camera",
+  .type = VID_TYPE_CAPTURE,
+  .hardware = VID_HARDWARE_SPCA5XX,
+  .fops = &spca5xx_fops,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+  .release = video_device_release,
+#endif
+  .minor = -1,
+};
+#else
+static struct video_device spca50x_template = {
+	name: "SPCA5XX USB Camera",
+	type:	VID_TYPE_CAPTURE,
+	hardware:VID_HARDWARE_SPCA5XX,
+	open:   spca5xx_open,
+	close:  spca5xx_close,
+  	read:   spca5xx_read,
+  	mmap:   spca5xx_mmap,
+  	ioctl:  spca5xx_ioctl
+};
+#endif //KERNEL VERSION 2,4,22
+/****************************************************************************
+ *
+ * SPCA50X configuration
+ *
+ ***************************************************************************/
+
+static int
+spca50x_configure_sensor (struct usb_spca50x *spca50x)
+{
+ 
+ int err;
+  PDEBUG (4, "starting configuration");
+  /* Set sensor-specific vars */
+     err = spca5xx_getcapability(spca50x);
+  return 0;
+}
+
+
+static int
+spca50x_configure (struct usb_spca50x *spca50x)
+{
+int i;
+  PDEBUG (2, "video_register_device succeeded");
+  /* Initialise the camera bridge */
+  switch (spca50x->bridge)
+    {
+    
+    case BRIDGE_SN9CXXX:   
+      if(sonix_config(spca50x) < 0)
+      	goto error;
+    break;
+    case BRIDGE_ZC3XX:
+    
+      if(zc3xx_config(spca50x) < 0)
+      	goto error;
+    break;
+
+    case BRIDGE_SPCA536:
+    case BRIDGE_SPCA533:
+    case BRIDGE_SPCA504:
+    case BRIDGE_SPCA504B:
+    case BRIDGE_SPCA504C:
+   
+      if (sp5xxfw2_config (spca50x) < 0)
+	  goto error;
+    break;
+
+    default:
+      {
+	err ("Unknown bridge type");
+	goto error;
+      }
+    }
+
+  spca50x_set_packet_size (spca50x, 0);
+
+      i = spca5xx_getDefaultMode(spca50x);
+      if (i < 0) return i;
+  
+  if (spca50x_configure_sensor (spca50x) < 0)
+    {
+      err ("failed to configure");
+      goto error;
+    }
+  /* configure the frame detector with default parameters */
+  
+  spca5xx_setFrameDecoder(spca50x);
+  
+  PDEBUG (2, "Spca5xx Configure done !!");
+  return 0;
+
+error:
+
+  return -EBUSY;
+}
+
+
+/************************************************************************************/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+/****************************************************************************
+ *  sysfs
+ ***************************************************************************/
+
+static inline struct usb_spca50x *
+cd_to_spca50x (struct class_device *cd)
+{
+  struct video_device *vdev = to_video_device (cd);
+  return video_get_drvdata (vdev);
+}
+
+static ssize_t
+show_stream_id (struct class_device *cd, char *buf)
+{
+  struct usb_spca50x *spca50x = cd_to_spca50x (cd);
+  return snprintf (buf, 5, "%s\n", Plist[spca50x->cameratype].name);
+}
+
+static CLASS_DEVICE_ATTR (stream_id, S_IRUGO, show_stream_id, NULL);
+
+static ssize_t
+show_model (struct class_device *cd, char *buf)
+{
+  struct usb_spca50x *spca50x = cd_to_spca50x (cd);
+  return snprintf (buf, 32, "%s\n", (spca50x->desc) ?
+		   clist[spca50x->desc].description : " Unknow ");
+}
+
+static CLASS_DEVICE_ATTR (model, S_IRUGO, show_model, NULL);
+
+/*
+
+static ssize_t show_brightness(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	unsigned short x;
+
+	if (!spca50x->dev)
+		return -ENODEV;
+	sensor_get_brightness(spca50x, &x);
+	return sprintf(buf, "%d\n", x >> 8);
+} 
+static CLASS_DEVICE_ATTR(brightness, S_IRUGO, show_brightness, NULL);
+
+static ssize_t show_saturation(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	unsigned short x;
+
+	if (!spca50x->dev)
+		return -ENODEV;
+	sensor_get_saturation(spca50x, &x);
+	return sprintf(buf, "%d\n", x >> 8);
+} 
+static CLASS_DEVICE_ATTR(saturation, S_IRUGO, show_saturation, NULL);
+
+static ssize_t show_contrast(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	unsigned short x;
+
+	if (!spca50x->dev)
+		return -ENODEV;
+	sensor_get_contrast(spca50x, &x);
+	return sprintf(buf, "%d\n", x >> 8);
+} 
+static CLASS_DEVICE_ATTR(contrast, S_IRUGO, show_contrast, NULL);
+
+static ssize_t show_hue(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	unsigned short x;
+
+	if (!spca50x->dev)
+		return -ENODEV;
+	sensor_get_hue(spca50x, &x);
+	return sprintf(buf, "%d\n", x >> 8);
+} 
+static CLASS_DEVICE_ATTR(hue, S_IRUGO, show_hue, NULL);
+
+static ssize_t show_exposure(struct class_device *cd, char *buf)
+{
+	struct usb_spca50x *spca50x = cd_to_spca50x(cd);
+	unsigned char exp;
+
+	if (!spca50x->dev)
+		return -ENODEV;
+	sensor_get_exposure(spca50x, &exp);
+	return sprintf(buf, "%d\n", exp >> 8);
+} 
+static CLASS_DEVICE_ATTR(exposure, S_IRUGO, show_exposure, NULL);
+*/
+
+static void
+spca50x_create_sysfs (struct video_device *vdev)
+{
+
+  video_device_create_file (vdev, &class_device_attr_stream_id);
+  video_device_create_file (vdev, &class_device_attr_model);
+/*	
+	video_device_create_file(vdev, &class_device_attr_RGB);
+
+	video_device_create_file(vdev, &class_device_attr_brightness);
+	video_device_create_file(vdev, &class_device_attr_saturation);
+	video_device_create_file(vdev, &class_device_attr_contrast);
+	video_device_create_file(vdev, &class_device_attr_hue);
+	video_device_create_file(vdev, &class_device_attr_exposure);
+*/
+}
+#endif
+/****************************************************************************
+ *
+ *  USB routines
+ *
+ ***************************************************************************/
+static int
+spcaDetectCamera (struct usb_spca50x *spca50x)
+{
+  struct usb_device *dev = spca50x->dev;
+  __u8 fw = 0;
+  __u16 vendor;
+  __u16 product;
+  /* Is it a recognised camera ? */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+vendor = le16_to_cpu(dev->descriptor.idVendor);
+product = le16_to_cpu(dev->descriptor.idProduct);
+#else
+vendor = dev->descriptor.idVendor;
+product = dev->descriptor.idProduct;
+#endif
+  switch ( vendor )
+    {
+    case 0x0733:		/* Rebadged ViewQuest (Intel) and ViewQuest cameras */
+      switch ( product )
+	{
+
+	case 0x1314:
+		spca50x->desc = Mercury21;
+		spca50x->bridge = BRIDGE_SPCA533;
+		spca50x->sensor = SENSOR_INTERNAL;
+		spca50x->header_len = SPCA533_OFFSET_DATA;
+		spca50x->i2c_ctrl_reg = 0;
+		spca50x->i2c_base = 0;
+		spca50x->i2c_trigger_on_write = 0;
+		spca50x->cameratype = JPEG;
+		info ("USB SPCA5XX camera found. Mercury Digital Pro 2.1Mp ");
+		break;
+		
+	case 0x2211:
+	  spca50x->desc = Jenoptikjdc21lcd;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Jenoptik JDC 21 LCD");
+	  break;
+
+	case 0x2221:
+	  spca50x->desc = MercuryDigital;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Mercury Digital Pro 3.1Mp ");
+	  break;
+
+	case 0x1311:
+	  spca50x->desc = Epsilon13;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Digital Dream Epsilon 1.3");
+	  break;
+
+	 case 0x3261:
+	  spca50x->desc = Concord3045;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found.Concord 3045 Spca536 Mpeg4");
+	  break;
+	  case 0x3281:
+	  spca50x->desc = CyberpixS550V;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found.Mercury Cyberpix Spca536 Mpeg4");
+	  break;
+	default:
+	  goto error;
+	};
+      break;
+
+    case 0x04a5:		/* Benq */
+    case 0x08ca:		/* Aiptek */
+    case 0x055f:		/* Mustek cameras */
+    case 0x04fc:		/* SunPlus */
+    case 0x052b:		/* ?? Megapix */
+    case 0x04f1:		/* JVC */
+      switch (product)
+	{
+	case 0xc520:
+	  spca50x->desc = MustekGsmartMini3;
+	  spca50x->bridge = BRIDGE_SPCA504;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Mustek gSmart Mini 3(SPCA504A)");
+	  break;
+	case 0xc420:
+	  spca50x->desc = MustekGsmartMini2;
+	  spca50x->bridge = BRIDGE_SPCA504;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Mustek gSmart Mini 2(SPCA504A)");
+	  break;
+
+	case 0xc360:
+	  spca50x->desc = MustekDV4000;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Mustek DV4000 Spca536 Mpeg4");
+	  break;
+
+	case 0xc211:
+	  spca50x->desc = Bs888e;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Kowa Bs-888e Spca536 Mpeg4");
+	  break;
+
+	case 0xc005:		// zc302 chips 
+	  spca50x->desc = Wcam300A;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Mustek Wcam300a Zc0301 ");
+	  break;
+
+	case 0xd003:		// zc302 chips 
+	  spca50x->desc = MustekWcam300A;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Mustek PCCam300a Zc0301 ");
+	  break;
+	 case 0xd004:		// zc302 chips 
+	  spca50x->desc = WCam300AN;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Mustek WCam300aN Zc0302 ");
+	 break;
+	case 0x504a:
+	  /*try to get the firmware as some cam answer 2.0.1.2.2 
+	     and should be a spca504b then overwrite that setting */
+	  spca5xxRegRead (dev, 0x20, 0, 0, &fw, 1);
+	  if (fw == 1)
+	    {
+	      spca50x->desc = AiptekMiniPenCam13;
+	      spca50x->bridge = BRIDGE_SPCA504;
+	      spca50x->sensor = SENSOR_INTERNAL;
+	      spca50x->header_len = SPCA50X_OFFSET_DATA;
+	      spca50x->i2c_ctrl_reg = 0;
+	      spca50x->i2c_base = 0;
+	      spca50x->i2c_trigger_on_write = 0;
+	      spca50x->cameratype = JPEG;
+	      info
+		("USB SPCA5XX camera found. Type Aiptek mini PenCam 1.3(SPCA504A)");
+	    }
+	  else if (fw == 2)
+	    {
+	      spca50x->desc = Terratec2move13;
+	      spca50x->bridge = BRIDGE_SPCA504B;
+	      spca50x->sensor = SENSOR_INTERNAL;
+	      spca50x->header_len = SPCA50X_OFFSET_DATA;
+	      spca50x->i2c_ctrl_reg = 0;
+	      spca50x->i2c_base = 0;
+	      spca50x->i2c_trigger_on_write = 0;
+	      spca50x->cameratype = JPEG;
+	      info
+		("USB SPCA5XX camera found. Terratec 2 move1.3(SPCA504A FW2)");
+	    }
+	  else
+	    return -ENODEV;
+	  break;
+
+	case 0x2018:
+
+	  spca50x->desc = AiptekPenCamSD;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek PenCam SD(SPCA504A FW2)");
+	  break;
+	case 0x1001:
+
+	  spca50x->desc = JvcGcA50;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. JVC GC-A50(SPCA504A FW2)");
+	  break;
+	case 0x2008:
+
+	  spca50x->desc = AiptekMiniPenCam2;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek PenCam 2M(SPCA504A FW2)");
+	  break;
+
+	case 0x504b:
+
+	  spca50x->desc = MaxellMaxPocket;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Maxell MaxPocket 1.3 (SPCA504A FW2)");
+	  break;
+
+	case 0xffff:
+
+	  spca50x->desc = PureDigitalDakota;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Pure Digital Dakota (SPCA504A FW2)");
+	  break;
+
+	case 0x0104:
+
+	  spca50x->desc = AiptekPocketDVII;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek PocketDVII 1.3Mp");
+	  break;
+
+	case 0x0106:
+
+	  spca50x->desc = AiptekPocketDV3100;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek PocketDV3100+");
+	  break;
+	  
+	case 0xc630:
+
+	  spca50x->desc = MustekMDC4000;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Musteck MDC4000");
+	  break;
+	  
+	case 0x5330:
+
+	  spca50x->desc = Digitrex2110;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. ApexDigital Digitrex 2110 spca533");
+	  break;
+
+	case 0x2022:
+
+	  spca50x->desc = AiptekSlim3200;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found type: Aiptek Slim3 200 spca533");
+	  break;
+	  
+	case 0x2028:
+
+	  spca50x->desc = AiptekPocketCam4M;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found type: Aiptek PocketCam 4M spca533");
+	  break; 
+	   
+	case 0x5360:
+	
+	  spca50x->desc = SunplusGeneric536;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek Generic spca536a");
+	  break;
+	  
+	case 0x2024:
+
+	  spca50x->desc = AiptekDV3500;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek DV3500 Mpeg4");
+	  break;
+	  
+	case 0x2042:
+	
+	  spca50x->desc = AiptekPocketDV5100;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek DV5100 Mpeg4");
+	  break;
+	  
+	  case 0x2060:
+	
+	  spca50x->desc = AiptekPocketDV5300;
+	  spca50x->bridge = BRIDGE_SPCA536;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA536_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek DV5300 Mpeg4");
+	  break;
+	  
+	case 0x3008:
+
+	  spca50x->desc = BenqDC1500;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Benq DC 1500 Spca533");
+	  break;
+
+	case 0x3003:
+
+	  spca50x->desc = BenqDC1300;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Benq DC 1300 Spca504b");
+	  break;
+
+	case 0x300a:
+
+	  spca50x->desc = BenqDC3410;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Benq DC 3410 Spca533");
+	  break;
+
+	case 0x2010:
+
+	  spca50x->desc = AiptekPocketCam3M;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Aiptek PocketCam 3M");
+	  break;
+
+	case 0x2016:
+
+	  spca50x->desc = AiptekPocketCam2M;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Aiptek PocketCam 2 Mega (SPCA504A FW2)");
+	  break;
+
+	case 0xc530:
+	  spca50x->desc = MustekGsmartLCD3;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Mustek Gsmart LCD 3");
+	  break;
+
+	case 0xc430:
+	  spca50x->desc = MustekGsmartLCD2;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Mustek Gsmart LCD 2");
+	  break;
+
+	case 0xc440:
+
+	  spca50x->desc = MustekDV3000;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. DV3000");
+	  break;
+
+	case 0xc540:
+
+	  spca50x->desc = GsmartD30;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found.Mustek Gsmart D30");
+	  break;
+	case 0xc650:
+
+	  spca50x->desc = MustekMDC5500Z;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found Mustek MDC5500Z");
+	  break;
+
+	case 0x1513:
+
+
+	  spca50x->desc = MegapixV4;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found Megapix V4");
+
+	  break;
+
+	default:
+	  goto error;
+	};
+      break;
+    case 0x046d:		/* Logitech Labtec*/
+    case 0x041E:		/* Creative cameras */
+      switch (product)
+	{
+
+	  
+	case 0x4012:
+	  spca50x->desc = PcCam350;
+	  spca50x->bridge = BRIDGE_SPCA504C;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA504_PCCAM600_OFFSET_DATA;;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative PC-CAM 350 (SPCA504c+unknown CCD)");
+	break;
+	
+
+	case 0x08a0:
+	  spca50x->desc = QCim;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech QC IM ");
+	  break;
+	  
+	case 0x08a1:
+	
+	  spca50x->desc = QCimA1;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech QC IM ");
+	  break;
+	  
+	case 0x08a2:		// zc302 chips 
+	
+	  spca50x->desc = LabtecPro;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_HDCS2020;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Labtec Webcam Pro Zc0302 + Hdcs2020");
+	  break;
+	  
+	case 0x08a3:
+	
+	  spca50x->desc = QCchat;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech QC Chat ");
+	  break;
+	  
+	 case 0x08a9:
+	
+	  spca50x->desc = LogitechNotebookDeluxe;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_HDCS2020;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech Notebooks Deluxe Zc0302 + Hdcs2020");
+	  break;
+	case 0x08ae:
+	
+	  spca50x->desc = QuickCamNB;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_HDCS2020;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech QC for Notebooks ");
+	  break;
+	   
+	 case 0x08ad:
+	  spca50x->desc = LogitechQCCommunicateSTX;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_HV7131C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech QC Communicate STX ");
+	  break;
+	  
+	 case 0x08aa:
+	  spca50x->desc = LabtecNotebook;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_HDCS2020;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Labtec for Notebooks ");
+	  break;
+	  
+	case 0x08b9:
+	  spca50x->desc = QCimB9;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Logitech QC IM ??? ");
+	  break;
+
+	case 0x0905:
+	  spca50x->desc = LogitechClickSmart820;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Logitech ClickSmart 820 (SPCA533+unknown CCD)");
+	  break;
+	case 0x400B:
+	  spca50x->desc = CreativePCCam600;
+	  spca50x->bridge = BRIDGE_SPCA504C;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA504_PCCAM600_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative PC-CAM 600 (SPCA504+unknown CCD)");
+	  break;
+	case 0x4013:
+	  spca50x->desc = CreativePccam750;
+	  spca50x->bridge = BRIDGE_SPCA504C;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA504_PCCAM600_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative PC-CAM 750 (SPCA504+unknown CCD)");
+	  break;
+	case 0x0960:
+	  spca50x->desc = LogitechClickSmart420;
+	  spca50x->bridge = BRIDGE_SPCA504C;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA504_PCCAM600_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Logitech Clicksmart 420 (SPCA504+unknown CCD)");
+	  break;
+
+	case 0x401c:		// zc301 chips 
+	  spca50x->desc = CreativeNX;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_PAS106;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative NX Zc301+ CCD PAS106B");
+	  break;
+	case 0x401e:		// zc301 chips 
+	  spca50x->desc = CreativeNxPro;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_HV7131B;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative NX Pro Zc301+hv7131b");
+	  break;
+	case 0x4034:		// zc301 chips 
+	  spca50x->desc = CreativeInstant1;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_PAS106;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative Instant P0620");
+	  break; 
+	case 0x4035:		// zc301 chips 
+	  spca50x->desc = CreativeInstant2;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_PAS106;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative Instant P0620D");
+	  break;    
+	case 0x403a:
+	  spca50x->desc = CreativeNxPro2;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative Nx Pro FW2 Zc301+Tas5130c");
+	  break;
+
+	case 0x4036:
+	  spca50x->desc = CreativeLive;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative Live! Zc301+Tas5130c");
+	  break;
+	case 0x401f:		// zc301 chips 
+	  spca50x->desc = CreativeNotebook;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative Webcam Notebook Zc301+Tas5130c");
+	  break;
+	case 0x4017:		// zc301 chips 
+	  spca50x->desc = CreativeMobile;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_ICM105A;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Creative Webcam Mobile Zc301+Icm105a");
+	  break;
+
+	default:
+	  goto error;
+	};
+      break;
+    case 0x0AC8:		/* Vimicro z-star */
+      switch (product)
+	{
+	case 0x301b:		/* Wasam 350r */
+	  spca50x->desc = Vimicro;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_PB0330;	//overwrite by the sensor detect routine
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info ("USB SPCA5XX camera found. Type Vimicro Zc301P 0x301b");
+
+	  break;
+	case 0x303b:		/* Wasam 350r */
+	  spca50x->desc = Vimicro303b;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_PB0330;	//overwrite by the sensor detect routine
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info ("USB SPCA5XX camera found. Type Vimicro Zc301P 0x303b");
+
+	  break;  
+	case 0x305b:	/* Generic */
+	  spca50x->desc = Zc0305b;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;	//overwrite by the sensor detect routine
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info ("USB SPCA5XX camera found. Type Vimicro Zc305B 0x305b");
+	break;
+	
+	case 0x0302:		/* Generic */
+	  spca50x->desc = Zc302;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_ICM105A;	//overwrite by the sensor detect routine
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info ("USB SPCA5XX camera found. Type Vimicro Zc302 ");
+
+	  break;
+
+	default:
+	  goto error;
+	};
+      break;
+
+    case 0x0458:		/* Genius KYE cameras */
+      switch (product)
+	{
+	case 0x7006:
+	  spca50x->desc = GeniusDsc13;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found. Type Genius DSC 1.3 Smart Spca504B");
+	  break;
+	case 0x7007:		// zc301 chips 
+	  spca50x->desc = GeniusVideoCamV2;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Genius VideoCam V2 Zc301+Tas5130c");
+	  break;
+
+	case 0x700c:		// zc301 chips 
+	  spca50x->desc = GeniusVideoCamV3;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Genius VideoCam V3 Zc301+Tas5130c");
+	  break;
+
+	case 0x7029:		// zc301 chips 
+	  spca50x->desc = GeniusVideoCamExpressV2b;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Genius VideoCam Express V2 Zc301+Tas5130c");
+	  break;
+	default:
+	  goto error;
+	};
+      break;
+
+    case 0x10fd:		/* FlyCam usb 100  */
+      switch (product)
+	{
+
+	case 0x0128:
+	case 0x8050:		// zc301 chips
+	  spca50x->desc = TyphoonWebshotIIUSB300k;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Typhoon Webshot II Zc301p Tas5130c");
+	  break;
+
+	default:
+	  goto error;
+	};
+      break;
+    case 0x0461:		/* MicroInnovation  */
+      switch (product)
+	{
+
+	case 0x0a00:		// zc301 chips 
+	  spca50x->desc = WebCam320;
+	  spca50x->bridge = BRIDGE_ZC3XX;
+	  spca50x->sensor = SENSOR_TAS5130C;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGH;
+	  info
+	    ("USB SPCA5XX camera found. Type Micro Innovation PC Cam 300A Zc301");
+	  break;
+	default:
+	  goto error;
+	};
+      break;
+
+    case 0x05da:		/* Digital Dream cameras */
+      switch (product)
+	{
+	case 0x1018:
+	  spca50x->desc = Enigma13;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+
+	  info ("USB SPCA5XX camera found. Digital Dream Enigma 1.3");
+	  break;
+	default:
+	  goto error;
+	};
+      break;
+    case 0x0c45:		/* Sonix6025 TAS 5130d1b */
+      switch (product)
+	{
+	case 0x607c:
+	  spca50x->desc = SonixWC311P;
+	  spca50x->bridge = BRIDGE_SN9CXXX;
+	  spca50x->sensor = SENSOR_HV7131R;
+	  spca50x->customid = SN9C102P;
+	  spca50x->header_len = 0;
+	  spca50x->i2c_ctrl_reg = 0x81;
+	  spca50x->i2c_base = 0x11;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGS;	// jpeg 4.2.2 whithout header ;
+	  info ("USB SPCA5XX camera found. SONIX sn9c102p + Hv7131R ");
+	  break;
+	case 0x613c:
+	  spca50x->desc = Pccam168;
+	  spca50x->bridge = BRIDGE_SN9CXXX;
+	  spca50x->sensor = SENSOR_HV7131R;
+	  spca50x->customid = SN9C120;
+	  spca50x->header_len = 0;
+	  spca50x->i2c_ctrl_reg = 0x81;
+	  spca50x->i2c_base = 0x11;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGS;	// jpeg 4.2.2 whithout header ;
+	  info ("USB SPCA5XX camera found. SONIX sn9c120 + Hv7131R ");
+	  break;
+	case 0x6130:
+	  spca50x->desc = Pccam;
+	  spca50x->bridge = BRIDGE_SN9CXXX;
+	  spca50x->sensor = SENSOR_MI0360;
+	  spca50x->customid = SN9C120;
+	  spca50x->header_len = 0;
+	  spca50x->i2c_ctrl_reg = 0x81;
+	  spca50x->i2c_base = 0x5d;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGS;	// jpeg 4.2.2 whithout header ;
+	  info ("USB SPCA5XX camera found. SONIX sn9c120 + MI0360 ");
+	  break;
+	case 0x60c0:
+	  spca50x->desc = Sn535;
+	  spca50x->bridge = BRIDGE_SN9CXXX;
+	  spca50x->sensor = SENSOR_MI0360;
+	  spca50x->customid = SN9C105;
+	  spca50x->header_len = 0;
+	  spca50x->i2c_ctrl_reg = 0x81;
+	  spca50x->i2c_base = 0x5d;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGS;	// jpeg 4.2.2 whithout header ;
+	  info ("USB SPCA5XX camera found. SONIX sn9c105 + MI0360 ");
+	  break;
+	case 0x6007:
+	  spca50x->desc = Lic300;
+	  spca50x->bridge = BRIDGE_SN9CXXX;
+	  spca50x->sensor = SENSOR_HV7131R;
+	  spca50x->customid = SN9C105;
+	  spca50x->header_len = 0;
+	  spca50x->i2c_ctrl_reg = 0x81;
+	  spca50x->i2c_base = 0x11;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPGS;	// jpeg 4.2.2 whithout header ;
+	  info ("USB SPCA5XX camera found. SONIX sn9c105 + HV7131R ");
+	  break;
+	default:
+	  goto error;
+	};
+      break;
+    case 0x0546:		/* Polaroid */
+      switch (product)
+	{
+	case 0x3273:
+	  spca50x->desc = PolaroidPDC2030;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+
+	  info ("USB SPCA5XX camera found. Polaroid PDC 2030");
+	  break;
+
+	case 0x3155:
+
+	  spca50x->desc = PolaroidPDC3070;
+	  spca50x->bridge = BRIDGE_SPCA533;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA533_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info ("USB SPCA5XX camera found. Polaroid PDC 3070");
+	  break;
+	  
+	case 0x3191:
+
+	  spca50x->desc = PolaroidIon80;
+	  spca50x->bridge = BRIDGE_SPCA504B;
+	  spca50x->sensor = SENSOR_INTERNAL;
+	  spca50x->header_len = SPCA50X_OFFSET_DATA;
+	  spca50x->i2c_ctrl_reg = 0;
+	  spca50x->i2c_base = 0;
+	  spca50x->i2c_trigger_on_write = 0;
+	  spca50x->cameratype = JPEG;
+	  info
+	    ("USB SPCA5XX camera found.Polaroid Ion80 (SPCA504A FW2)");
+	  break;
+
+	default:
+	  goto error;
+	};
+      break;
+
+    default:
+      goto error;
+    }
+  return 0;
+error:
+  return -ENODEV;
+}
+
+ 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+static int
+spca5xx_probe (struct usb_interface *intf, const struct usb_device_id *id)
+#else
+static void *
+spca5xx_probe (struct usb_device *dev, unsigned int ifnum,
+	       const struct usb_device_id *id)
+#endif
+{
+  struct usb_interface_descriptor *interface;
+  struct usb_spca50x *spca50x;
+  int err_probe;
+  int i;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+  struct usb_device *dev = interface_to_usbdev (intf);
+#endif
+  /* We don't handle multi-config cameras */
+  if (dev->descriptor.bNumConfigurations != 1)
+    goto nodevice;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  /* 2.4.x test Only work on Interface 0 */
+  if (ifnum > 0)
+    goto nodevice;
+
+  interface = &dev->actconfig->interface[ifnum].altsetting[0];
+  /* Since code below may sleep, we use this as a lock */
+  MOD_INC_USE_COUNT;
+#else
+  /* 2.6.x test Only work on Interface 0 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,6)
+  interface = &intf->cur_altsetting->desc;
+#else
+  interface = &intf->altsetting[0].desc;
+#endif
+  if (interface->bInterfaceNumber > 0)
+    goto nodevice;
+#endif
+
+
+  if ((spca50x = kmalloc (sizeof (struct usb_spca50x), GFP_KERNEL)) == NULL)
+    {
+      err ("couldn't kmalloc spca50x struct");
+      goto error;
+    }
+
+  memset (spca50x, 0, sizeof (struct usb_spca50x));
+
+  spca50x->dev = dev;
+  spca50x->iface = interface->bInterfaceNumber;
+  if ((err_probe = spcaDetectCamera (spca50x)) < 0)
+    {
+      err (" Devices not found !! ");
+      /* FIXME kfree spca50x and goto nodevice */
+      goto error;
+    }
+  PDEBUG (0, "Camera type %s ", Plist[spca50x->cameratype].name);
+
+  for (i = 0; i < SPCA50X_NUMFRAMES; i++)
+    init_waitqueue_head (&spca50x->frame[i].wq);
+  init_waitqueue_head (&spca50x->wq);
+
+  if (!spca50x_configure (spca50x))
+    {
+      spca50x->user = 0;
+      init_MUTEX (&spca50x->lock);	/* to 1 == available */
+      init_MUTEX (&spca50x->buf_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10)
+      spin_lock_init(&spca50x->v4l_lock);
+#else
+      spca50x->v4l_lock = SPIN_LOCK_UNLOCKED;
+#endif
+      spca50x->buf_state = BUF_NOT_ALLOCATED;
+    }
+  else
+    {
+      err ("Failed to configure camera");
+      goto error;
+    }
+  /* Init video stuff */
+  spca50x->vdev = video_device_alloc ();
+  if (!spca50x->vdev)
+    goto error;
+  memcpy (spca50x->vdev, &spca50x_template, sizeof (spca50x_template));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+  spca50x->vdev->dev = &dev->dev;
+#endif
+  video_set_drvdata (spca50x->vdev, spca50x);
+
+  PDEBUG (2, "setting video device = %p, spca50x = %p", spca50x->vdev,
+	  spca50x);
+
+  if (video_register_device (spca50x->vdev, VFL_TYPE_GRABBER, video_nr) < 0)
+    {
+      err ("video_register_device failed");
+      goto error;
+    }
+  /* test on disconnect */
+  spca50x->present = 1;
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+  usb_set_intfdata (intf, spca50x);
+  spca50x_create_sysfs (spca50x->vdev);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  MOD_DEC_USE_COUNT;
+  return spca50x;
+#else
+  return 0;
+#endif
+
+error:
+  if (spca50x->vdev)
+    {
+      if (spca50x->vdev->minor == -1)
+	video_device_release (spca50x->vdev);
+      else
+	video_unregister_device (spca50x->vdev);
+      spca50x->vdev = NULL;
+    }
+  if (spca50x)
+    {
+      kfree (spca50x);
+      spca50x = NULL;
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  MOD_DEC_USE_COUNT;
+  return NULL;
+#else
+  return -EIO;
+#endif
+
+nodevice:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  return NULL;
+#else
+  return -ENODEV;
+#endif
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+static void
+spca5xx_disconnect (struct usb_interface *intf)
+{
+  struct usb_spca50x *spca50x = usb_get_intfdata (intf);
+#else
+static void
+spca5xx_disconnect (struct usb_device *dev, void *ptr)
+{
+  struct usb_spca50x *spca50x = (struct usb_spca50x *) ptr;
+#endif
+  int n;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  MOD_INC_USE_COUNT;
+#endif
+  if (!spca50x)
+    return;
+  down (&spca50x->lock);
+  spca50x->present = 0;
+  for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+    spca50x->frame[n].grabstate = FRAME_ABORTING;
+  spca50x->curframe = -1;
+
+  /* This will cause the process to request another frame */
+  for (n = 0; n < SPCA50X_NUMFRAMES; n++)
+    if (waitqueue_active (&spca50x->frame[n].wq))
+      wake_up_interruptible (&spca50x->frame[n].wq);
+
+  if (waitqueue_active (&spca50x->wq))
+    wake_up_interruptible (&spca50x->wq);
+
+  spca5xx_kill_isoc(spca50x);
+
+  PDEBUG (3,"Disconnect Kill isoc done");
+  up (&spca50x->lock);
+  while(spca50x->user) 
+  	schedule();
+    {
+      down (&spca50x->lock);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0)
+      /* be sure close did not use &intf->dev ? */
+      dev_set_drvdata (&intf->dev, NULL);
+#endif
+      /* We don't want people trying to open up the device */
+      if (spca50x->vdev)
+	video_unregister_device (spca50x->vdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+      usb_driver_release_interface (&spca5xx_driver,
+				    &spca50x->dev->actconfig->
+				    interface[spca50x->iface]);
+#endif
+      spca50x->dev = NULL;
+      up (&spca50x->lock);
+
+      /* Free the memory */
+      if (spca50x && !spca50x->user)
+	{
+	  spca5xx_dealloc (spca50x);
+	  kfree (spca50x);
+	  spca50x = NULL;
+	}
+    }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+  MOD_DEC_USE_COUNT;
+#endif
+  PDEBUG (3, "Disconnect complete");
+
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static struct usb_driver spca5xx_driver = {
+  .owner = THIS_MODULE,
+  .name = "spca5xx",
+  .id_table = device_table,
+  .probe = spca5xx_probe,
+  .disconnect = spca5xx_disconnect
+};
+#else
+static struct usb_driver spca5xx_driver = {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,20)
+	  THIS_MODULE,
+#endif
+	"spca5xx",
+	spca5xx_probe,
+	spca5xx_disconnect,
+	{NULL,NULL}
+};
+#endif
+
+
+/****************************************************************************
+ *
+ *  Module routines
+ *
+ ***************************************************************************/
+
+static int __init
+usb_spca5xx_init (void)
+{
+
+  if (usb_register (&spca5xx_driver) < 0)
+    return -1;
+
+  info ("spca5xx driver %s registered", version);
+
+  return 0;
+}
+
+static void __exit
+usb_spca5xx_exit (void)
+{
+  usb_deregister (&spca5xx_driver);
+  info ("driver spca5xx deregistered");
+
+
+}
+
+module_init (usb_spca5xx_init);
+module_exit (usb_spca5xx_exit);
+
+//eof
diff -ruN usb_old/spca5xx/spcadecoder.c usb/spca5xx/spcadecoder.c
--- linux-2.4.31/drivers/usb_old/spca5xx/spcadecoder.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/spcadecoder.c	2005-11-21 14:45:16.000000000 +0100
@@ -0,0 +1,332 @@
+/*******************************************************************************
+#	 	spcadecoder: Generic decoder for various input stream yyuv	#
+# yuyv yuvy jpeg411 jpeg422 bayer rggb with gamma correct			#
+# and various output palette rgb16 rgb24 rgb32 yuv420p				#
+# various output size with crop feature						#
+# 		Copyright (C) 2003 2004 2005 Michel Xhaard			#
+# 		mxhaard@magic.fr						#
+# 		Sonix Decompressor by B.S. (C) 2004				#
+# 		Spca561decoder (C) 2005 Andrzej Szombierski [qq@kuku.eu.org]	#
+# This program is free software; you can redistribute it and/or modify		#
+# it under the terms of the GNU General Public License as published by		#
+# the Free Software Foundation; either version 2 of the License, or		#
+# (at your option) any later version.						#
+#										#
+# This program is distributed in the hope that it will be useful,		#
+# but WITHOUT ANY WARRANTY; without even the implied warranty of		#
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the			#
+# GNU General Public License for more details.					#
+#										#
+# You should have received a copy of the GNU General Public License		#
+# along with this program; if not, write to the Free Software			#
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA	#
+********************************************************************************/
+
+
+#ifndef __KERNEL__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#else /* __KERNEL__ */
+#include <linux/string.h>
+#endif /* __KERNEL__ */
+
+
+#include "spcadecoder.h"
+
+
+/* special markers */
+#define M_BADHUFF	-1
+
+#define ERR_CORRUPTFRAME 16
+
+#define JPEGHEADER_LENGTH 589
+
+const unsigned char JPEGHeader[JPEGHEADER_LENGTH] =
+{
+ 0xff, 0xd8, 0xff, 0xdb, 0x00, 0x84, 0x00, 0x06, 0x04, 0x05, 0x06, 0x05, 0x04, 0x06, 0x06, 0x05,
+ 0x06, 0x07, 0x07, 0x06, 0x08, 0x0a, 0x10, 0x0a, 0x0a, 0x09, 0x09, 0x0a, 0x14, 0x0e, 0x0f, 0x0c,
+ 0x10, 0x17, 0x14, 0x18, 0x18, 0x17, 0x14, 0x16, 0x16, 0x1a, 0x1d, 0x25, 0x1f, 0x1a, 0x1b, 0x23,
+ 0x1c, 0x16, 0x16, 0x20, 0x2c, 0x20, 0x23, 0x26, 0x27, 0x29, 0x2a, 0x29, 0x19, 0x1f, 0x2d, 0x30,
+ 0x2d, 0x28, 0x30, 0x25, 0x28, 0x29, 0x28, 0x01, 0x07, 0x07, 0x07, 0x0a, 0x08, 0x0a, 0x13, 0x0a,
+ 0x0a, 0x13, 0x28, 0x1a, 0x16, 0x1a, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+ 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+ 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
+ 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0xff, 0xc4, 0x01, 0xa2, 0x00, 0x00, 0x01, 0x05,
+ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
+ 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01,
+ 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
+ 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05,
+ 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,
+ 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23,
+ 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17,
+ 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
+ 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
+ 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
+ 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
+ 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+ 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5,
+ 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1,
+ 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04,
+ 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
+ 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14,
+ 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16,
+ 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36,
+ 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56,
+ 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76,
+ 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94,
+ 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2,
+ 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9,
+ 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
+ 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xc0, 0x00, 0x11,
+ 0x08, 0x01, 0xe0, 0x02, 0x80, 0x03, 0x01, 0x21, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff,
+ 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00
+ };
+/*********************************/
+const unsigned char GsmartQTable[22][64]=
+{
+	// index 0, Q50
+	{  16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40,
+       26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51,
+       56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80,109, 81, 87,
+       95, 98,103,104,103, 62, 77,113,121,112,100,120, 92,101,103, 99 },
+	{  17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99,
+       99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+	   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
+       99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99 },
+
+	// index 1, Q70
+	{  10,  7,  7,  8,  7,  6, 10,  8,  8,  8, 11, 10, 10, 11, 14, 24,
+	   16, 14, 13, 13, 14, 29, 21, 22, 17, 24, 35, 31, 37, 36, 34, 31,
+	   34, 33, 38, 43, 55, 47, 38, 41, 52, 41, 33, 34, 48, 65, 49, 52,
+	   57, 59, 62, 62, 62, 37, 46, 68, 73, 67, 60, 72, 55, 61, 62, 59 },
+	{  10, 11, 11, 14, 13, 14, 28, 16, 16, 28, 59, 40, 34, 40, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
+	   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59 },
+
+	// index 2, Q80
+	{   6,  4,  5,  6,  5,  4,  6,  6,  5,  6,  7,  7,  6,  8, 10, 16,
+	   10, 10,  9,  9, 10, 20, 14, 15, 12, 16, 23, 20, 24, 24, 23, 20,
+	   22, 22, 26, 29, 37, 31, 26, 27, 35, 28, 22, 22, 32, 44, 32, 35,
+	   38, 39, 41, 42, 41, 25, 31, 45, 48, 45, 40, 48, 37, 40, 41, 40 },
+	{   7,  7,  7, 10,  8, 10, 19, 10, 10, 19, 40, 26, 22, 26, 40, 40,
+	   40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+	   40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+	   40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40 },
+
+	// index 3, Q85
+	{   5,  3,  4,  4,  4,  3,  5,  4,  4,  4,  5,  5,  5,  6,  7, 12,
+	    8,  7,  7,  7,  7, 15, 11, 11,  9, 12, 17, 15, 18, 18, 17, 15,
+	   17, 17, 19, 22, 28, 23, 19, 20, 26, 21, 17, 17, 24, 33, 24, 26,
+	   29, 29, 31, 31, 31, 19, 23, 34, 36, 34, 30, 36, 28, 30, 31, 30 },
+	{   5,  5,  5,  7,  6,  7, 14,  8,  8, 14, 30, 20, 17, 20, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 },
+
+	// index 4, Q90
+	{   3,  2,  2,  3,  2,  2,  3,  3,  3,  3,  4,  3,  3,  4,  5,  8,
+	    5,  5,  4,  4,  5, 10,  7,  7,  6,  8, 12, 10, 12, 12, 11, 10,
+	   11, 11, 13, 14, 18, 16, 13, 14, 17, 14, 11, 11, 16, 22, 16, 17,
+	   19, 20, 21, 21, 21, 12, 15, 23, 24, 22, 20, 24, 18, 20, 21, 20 },
+	{   3,  4,  4,  5,  4,  5,  9,  5,  5,  9, 20, 13, 11, 13, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+	   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 },
+
+	// index 5, Q60
+	{  13,  9, 10, 11, 10,  8, 13, 11, 10, 11, 14, 14, 13, 15, 19, 32,
+	   21, 19, 18, 18, 19, 39, 28, 30, 23, 32, 46, 41, 49, 48, 46, 41,
+	   45, 44, 51, 58, 74, 62, 51, 54, 70, 55, 44, 45, 64, 87, 65, 70,
+	   76, 78, 82, 83, 82, 50, 62, 90, 97, 90, 80, 96, 74, 81, 82, 79 },
+	{  14, 14, 14, 19, 17, 19, 38, 21, 21, 38, 79, 53, 45, 53, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
+	   79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79 },
+
+	// index 6, Q25
+	{  32, 22, 24, 28, 24, 20, 32, 28, 26, 28, 36, 34, 32, 38, 48, 80,
+	   52, 48, 44, 44, 48, 98, 70, 74, 58, 80,116,102,122,120,114,102,
+	  112,110,128,144,184,156,128,136,174,138,110,112,160,218,162,174,
+	  190,196,206,208,206,124,154,226,242,224,200,240,184,202,206,198 },
+	{  34, 36, 36, 48, 42, 48, 94, 52, 52, 94,198,132,112,132,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,
+	  198,198,198,198,198,198,198,198,198,198,198,198,198,198,198,198 },
+
+	// index 7, Q95
+	{   2,  1,  1,  1,  1,  1,  2,  1,  1,  1,  2,  2,  2,  2,  2,  4,
+	    3,  2,  2,  2,  2,  5,  4,  4,  3,  4,  6,  5,  6,  6,  6,  5,
+	    6,  6,  6,  7,  9,  8,  6,  7,  9,  7,  6,  6,  8, 11,  8,  9,
+	   10, 10, 10, 10, 10,  6,  8, 11, 12, 11, 10, 12,  9, 10, 10, 10 },
+	{   2,  2,  2,  2,  2,  2,  5,  3,  3,  5, 10,  7,  6,  7, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
+	   10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 },
+
+	// index 8, Q93
+	{   2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  3,  2,  2,  3,  3,  6,
+	    4,  3,  3,  3,  3,  7,  5,  5,  4,  6,  8,  7,  9,  8,  8,  7,
+	    8,  8,  9, 10, 13, 11,  9, 10, 12, 10,  8,  8, 11, 15, 11, 12,
+	   13, 14, 14, 15, 14,  9, 11, 16, 17, 16, 14, 17, 13, 14, 14, 14 },
+	{   2,  3,  3,  3,  3,  3,  7,  4,  4,  7, 14,  9,  8,  9, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+	   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14 },
+
+	// index 9, Q40
+	{  20, 14, 15, 18, 15, 13, 20, 18, 16, 18, 23, 21, 20, 24, 30, 50,
+	   33, 30, 28, 28, 30, 61, 44, 46, 36, 50, 73, 64, 76, 75, 71, 64,
+	   70, 69, 80, 90,115, 98, 80, 85,109, 86, 69, 70,100,136,101,109,
+	  119,123,129,130,129, 78, 96,141,151,140,125,150,115,126,129,124 },
+	{  21, 23, 23, 30, 26, 30, 59, 33, 33, 59,124, 83, 70, 83,124,124,
+	  124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,
+	  124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,
+	  124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124 },
+
+	// index 10, pccam300
+	{   5,  3,  3,  5,  7, 12, 15, 18,  4,  4,  4,  6,  8, 17, 18, 17,
+	    4,  4,  5,  7, 12, 17, 21, 17,  4,  5,  7,  9, 15, 26, 24, 19,
+	    5,  7, 11, 17, 20, 33, 31, 23,  7, 11, 17, 19, 24, 31, 34, 28,
+	   15, 19, 23, 26, 31, 36, 36, 30, 22, 28, 29, 29, 34, 30, 31, 30 },
+	{   5,  5,  7, 14, 30, 30, 30, 30,  5,  6,  8, 20, 30, 30, 30, 30,
+	    7,  8, 17, 30, 30, 30, 30, 30, 14, 20, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
+	   30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 }
+};
+
+int spca50x_outpicture ( struct spca50x_frame *myframe );
+
+static int make_jpeg ( struct spca50x_frame *myframe );
+static int make_jpeg_conexant (struct spca50x_frame *myframe);
+
+void
+init_jpeg_decoder (struct usb_spca50x *spca50x, unsigned int qIndex)
+{
+int i,j;
+/* set up a quantization table */
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 64; j++) {
+			spca50x->maindecode.quant[i][j] = GsmartQTable[qIndex * 2 + i][j];
+		}
+	}
+}
+int spca50x_outpicture ( struct spca50x_frame *myframe )
+{	/* general idea keep a frame in the temporary buffer from the tasklet*/
+	/* decode with native format at input and asked format at output */
+	/* myframe->cameratype is the native input format */
+	/* myframe->format is the asked format */
+	
+	int width = 0;
+	int height = 0;
+	int done = 0;
+
+	switch(myframe->cameratype){
+		case JPGC: //conexant
+			height = (myframe->data[11] << 8) | myframe->data[12];
+			width = (myframe->data[13] << 8) | myframe->data[14];
+			if (myframe->hdrheight != height || myframe->hdrwidth != width){	
+				done = ERR_CORRUPTFRAME;
+			} else {
+			
+				memcpy(myframe->tmpbuffer,myframe->data,myframe->scanlength);
+			 	done = make_jpeg_conexant ( myframe );
+			
+			}
+		break;
+		case JPGH://Vimicro
+			width = (myframe->data[10] << 8) | myframe->data[11];
+			height = (myframe->data[12] << 8) | myframe->data[13];
+			/* some camera did not respond with the good height ie:Labtec Pro 240 -> 232 */
+			if (myframe->hdrwidth != width){	
+				done = ERR_CORRUPTFRAME;
+			} else {
+				memcpy(myframe->tmpbuffer,myframe->data+16,myframe->scanlength - 16);
+				done = make_jpeg ( myframe );
+			
+			}
+		break;
+		case JPGM://Mars-semi
+		case JPGS://Sonix
+		case JPEG://Sunplus
+			memcpy(myframe->tmpbuffer,myframe->data,myframe->scanlength );
+			done = make_jpeg ( myframe );
+
+		break;
+
+	default : done = -1;
+	break;
+	}
+return done;	
+}
+
+/* this function restore the missing header for the jpeg camera */
+/* adapted from Till Adam create_jpeg_from_data() */
+static int make_jpeg (struct spca50x_frame *myframe)
+{
+  __u8 *start;
+ int i;
+ __u8 value;
+ int width = myframe->hdrwidth;
+ int height = myframe->hdrheight;
+ long inputsize = myframe->scanlength;
+ __u8 *buf = myframe->tmpbuffer;
+ __u8 *dst = myframe->data;;
+
+	 start = dst;	
+	/* set up the default header */
+	memcpy(dst,JPEGHeader,JPEGHEADER_LENGTH);
+	/* setup quantization table */
+	*(dst+6) = 0;
+	memcpy(dst+7,myframe->decoder->quant[0],64);
+	*(dst+7+64) = 1;
+	memcpy(dst+8+64,myframe->decoder->quant[1],64);
+	
+	*(dst + 564) = width & 0xFF;	//Image width low byte
+	*(dst + 563) = width >> 8 & 0xFF;	//Image width high byte
+	*(dst + 562) = height & 0xFF;	//Image height low byte
+	*(dst + 561) = height >> 8 & 0xFF;	//Image height high byte
+	/* set the format */
+	if(myframe->cameratype == JPEG){
+	 *(dst + 567) = 0x22;
+	 dst += JPEGHEADER_LENGTH;
+	 for (i=0 ; i < inputsize; i++){
+		value = *(buf + i) & 0xFF;
+		*dst = value;
+		dst++;
+		if (value == 0xFF){
+			*dst = 0;
+			dst++;
+		}	
+	 }	  
+	} else {
+	 *(dst + 567) = 0x21;
+	 dst += JPEGHEADER_LENGTH;
+	 memcpy(dst,buf,inputsize);
+	 dst += inputsize;
+
+	}
+	/* Add end of image marker */	
+	*(dst++) = 0xFF; 	
+	*(dst++) = 0xD9;
+	myframe->scanlength = (long)(dst - start);
+return 0;
+}
+
+static int make_jpeg_conexant (struct spca50x_frame *myframe)
+{
+
+ __u8 *buf = myframe->data;
+ __u8 *dst = myframe->tmpbuffer;
+
+	memcpy(dst,JPEGHeader,JPEGHEADER_LENGTH-33);
+	*(dst+6) = 0;
+	memcpy(dst+7,myframe->decoder->quant[0],64);
+	*(dst+7+64) = 1;
+	memcpy(dst+8+64,myframe->decoder->quant[1],64);
+	dst += (JPEGHEADER_LENGTH-33);
+	memcpy(dst,buf,myframe->scanlength);
+	myframe->scanlength +=(JPEGHEADER_LENGTH-33);
+return 0;
+}
diff -ruN usb_old/spca5xx/spcadecoder.h usb/spca5xx/spcadecoder.h
--- linux-2.4.31/drivers/usb_old/spca5xx/spcadecoder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/spcadecoder.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,14 @@
+
+#ifndef SPCADECODER_H
+#define SPCADECODER_H
+
+#include "spca5xx.h"
+
+
+int 
+spca50x_outpicture (struct spca50x_frame *myframe);
+void
+init_jpeg_decoder (struct usb_spca50x *spca50x, unsigned int qIndex);
+
+
+#endif /* SPCADECODER_H */
diff -ruN usb_old/spca5xx/spcausb.h usb/spca5xx/spcausb.h
--- linux-2.4.31/drivers/usb_old/spca5xx/spcausb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/spcausb.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,315 @@
+
+#ifndef SPCAUSB_H
+#define SPCAUSB_INIT_H
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 6)
+#define wait_ms(a) msleep((a))
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 11)
+#define TimeOut 1000
+#else
+#define TimeOut HZ
+#endif
+/* Common functions prototype */
+static int spca50x_reg_read(struct usb_device *dev,
+                            __u16              reg,
+                            __u16              index,
+                            __u16              length);
+static int spca50x_reg_write(struct usb_device *dev,
+                             __u16              reg,
+                             __u16              index,
+                             __u16              value);
+			     
+static void spca5xxRegRead(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length) ;	
+static void spca5xxRegWrite(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length) ;	
+static void sonixRegRead(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length) ;	
+static void sonixRegWrite(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length) ;	
+
+
+/*
+static int spca_clear_feature(struct usb_device *dev,
+				 int endpoint)
+{
+	int inpipe;
+	inpipe = usb_rcvintpipe(dev,endpoint);
+	usb_clear_halt(dev, inpipe);
+	return 0;
+}
+*/
+
+static int spca50x_setup_qtable(struct usb_spca50x *spca50x,
+                                unsigned int        request,
+                                unsigned int        ybase,
+                                unsigned int        cbase,
+                                unsigned char       qtable[2][64]);
+
+/***************************** Implementation ****************************/
+static void spca5xxRegRead(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length) 
+{	
+	int rc;
+	__u8 *kbuffer = NULL;
+	__u16 RegType;
+	if(length >0) {
+		kbuffer = (__u8 *) kmalloc (length,GFP_KERNEL);
+		memcpy (kbuffer, buffer, length);
+	}
+	RegType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	rc = usb_control_msg(dev,
+		usb_rcvctrlpipe(dev,0),
+		reg,
+		RegType,
+		(__u16)value, (__u16)index, kbuffer, length, TimeOut);
+	if(length >0) {	
+		memcpy (buffer, kbuffer, length);
+		kfree (kbuffer);
+	}
+	if (buffer) { 
+		PDEBUG(5, "reg read: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+		RegType ,reg ,value ,index ,(int) *buffer);
+	} else { 
+		PDEBUG(5, "reg read: 0x%02X, 0x%02X,0x%02X, 0x%02X ",RegType,reg,value,index );
+	}
+	return ;
+}
+
+
+static void spca5xxRegWrite(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length) 
+{	int rc;
+	__u16 RegType;
+	__u8 *kbuffer = NULL;
+	if(length >0) {
+		kbuffer = (__u8 *) kmalloc (length,GFP_KERNEL);
+		memcpy (kbuffer, buffer, length);
+	}
+	RegType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	rc = usb_control_msg(dev,
+		usb_sndctrlpipe(dev,0),
+		reg,
+		RegType,
+		(__u16)value, (__u16)index, kbuffer, length, TimeOut);
+	if(length >0) {	
+		memcpy (buffer, kbuffer, length);
+		kfree (kbuffer);
+	}
+	if (buffer) { 
+		PDEBUG(5, "reg write: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+		RegType ,reg ,value ,index ,(int) *buffer);
+	} else { 
+		PDEBUG(5, "reg write: 0x%02X, 0x%02X,0x%02X, 0x%02X ",RegType,reg,value,index );
+	}
+	return ;
+}
+static void sonixRegRead(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length)
+{
+	int rc;
+	__u8 *kbuffer = NULL;
+	__u16 RegType;
+	if(length >0) {
+		kbuffer = (__u8 *) kmalloc (length,GFP_KERNEL);
+		memcpy (kbuffer, buffer, length);
+	}
+	RegType = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+	rc = usb_control_msg(dev,
+		usb_rcvctrlpipe(dev,0),
+		reg,
+		RegType,
+		(__u16)value, (__u16)index, kbuffer, length, TimeOut);
+	if(length >0) {
+		memcpy (buffer, kbuffer, length);
+		kfree (kbuffer);
+	}
+	if (buffer) {
+		PDEBUG(5, "reg read: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+		RegType ,reg ,value ,index ,(int) *buffer);
+	} else {
+		PDEBUG(5, "reg read: 0x%02X, 0x%02X,0x%02X, 0x%02X ",RegType,reg,value,index );
+	}
+	return ;
+}
+
+static void sonixRegWrite(struct usb_device *dev,
+				__u16 reg,
+				__u16 value,
+				__u16 index,
+				__u8 *buffer,
+				__u16 length)
+{	int rc;
+	__u16 RegType;
+	__u8 *kbuffer = NULL;
+	if(length >0) {
+		kbuffer = (__u8 *) kmalloc (length,GFP_KERNEL);
+		memcpy (kbuffer, buffer, length);
+	}
+	RegType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE;
+	rc = usb_control_msg(dev,
+		usb_sndctrlpipe(dev,0),
+		reg,
+		RegType,
+		(__u16)value, (__u16)index, kbuffer, length, TimeOut);
+	if(length >0) {
+		memcpy (buffer, kbuffer, length);
+		kfree (kbuffer);
+	}
+	if (buffer) {
+		PDEBUG(5, "reg write: 0x%02X, 0x%02X, 0x%02X, 0x%02X: 0x%04X",
+		RegType ,reg ,value ,index ,(int) *buffer);
+	} else {
+		PDEBUG(5, "reg write: 0x%02X, 0x%02X,0x%02X, 0x%02X ",RegType,reg,value,index );
+	}
+	return ;
+}
+
+ 
+static int spca50x_reg_write(struct usb_device *dev,
+			   __u16 reg,
+			   __u16 index,
+			   __u16 value)
+{
+	int rc;
+
+	rc = usb_control_msg(dev,
+		usb_sndctrlpipe(dev, 0),
+		reg,
+		USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		value, index, NULL, 0, TimeOut);
+
+	PDEBUG(5, "reg write: 0x%02X,0x%02X:0x%02X, 0x%x", reg, index, value, rc);
+
+	if (rc < 0)
+		err("reg write: error %d", rc);
+
+	return rc;
+}
+
+static int spca50x_reg_read_with_value(struct usb_device *dev,
+                                       __u16              reg, // bRequest
+                                       __u16              value, // wValue
+                                       __u16              index, // wIndex
+                                       __u16              length) // wLength
+{
+	int rc;
+	unsigned char buffer[4]={0,0,0,0};
+	/* Hope plp didn't ask for more */
+	rc = usb_control_msg(dev,
+		usb_rcvctrlpipe(dev, 0),
+		reg,
+		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
+		(__u16)value, (__u16)index, buffer, length, TimeOut);
+		
+	PDEBUG(5, "reg read: 0x%02X,0x%02X:0x%04X", reg, index, *(int *)&buffer[0]);
+
+	if (rc < 0) {
+		err("reg read: error %d", rc);
+		return rc;
+	} else {
+		return *(int *)&buffer[0];
+	}
+}
+
+/* returns: negative is error, pos or zero is data */
+static int spca50x_reg_read(struct usb_device *dev, 
+                            __u16              reg, // bRequest
+                            __u16              index, // wIndex
+                            __u16              length) // wLength
+{
+	return spca50x_reg_read_with_value(dev, reg, 0, index, length);
+}
+/*
+ * Simple function to wait for a given 8-bit value to be returned from
+ * a spca50x_reg_read call.
+ * Returns: negative is error or timeout, zero is success.
+ */
+
+static int spca50x_write_vector(struct usb_spca50x *spca50x,__u16 data[][3])
+{
+	struct usb_device *dev=spca50x->dev;
+	int err_code;
+
+	int I=0;
+	while((data[I][0])!=(__u16)0 || (data[I][1])!=(__u16)0 || (data[I][2])!=(__u16)0)
+	{
+		err_code = spca50x_reg_write(dev, data[I][0], (__u16)(data[I][2]), 
+			(__u16)(data[I][1]));
+		if(err_code < 0) 
+		{ 
+			PDEBUG(1, "Register write failed for 0x%x,0x%x,0x%x", 
+				data[I][0],data[I][1], data[I][2]); 
+			return -1; 
+		}
+		I++;
+	}
+	return 0;
+}
+
+static int spca50x_setup_qtable(struct usb_spca50x *spca50x,
+                                unsigned int        request,
+                                unsigned int        ybase,
+                                unsigned int        cbase,
+                                unsigned char       qtable[2][64])
+{
+	int i;
+	int err;
+
+	/* loop over y components */
+	for (i = 0; i < 64; i++)
+	{
+		err = spca50x_reg_write(spca50x->dev, request, ybase + i, qtable[0][i]);
+		if (err < 0)
+		{
+			PDEBUG(2, "spca50x_reg_write failed");
+			return err;
+		}
+	}
+
+	/* loop over c components */
+	for (i = 0; i < 64; i++)
+	{
+		err = spca50x_reg_write(spca50x->dev, request, cbase + i, qtable[1][i]);
+		if (err < 0)
+		{
+			PDEBUG(2, "spca50x_reg_write failed");
+			return err;
+		}
+	}
+
+	/* all ok */
+	return 0;
+}
+
+	 
+#endif /* SPCAUSB_H */
diff -ruN usb_old/spca5xx/tas5130c.h usb/spca5xx/tas5130c.h
--- linux-2.4.31/drivers/usb_old/spca5xx/tas5130c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/tas5130c.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,283 @@
+/****************************************************************************
+#	 	TAS5130C      library                                       #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+
+static __u16 tas5130cxx_start_data[][3]=
+{
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x50, 0x0002},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x02, 0x0010},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x00, 0x0001},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x07, 0x00a5},
+ { 0xa0, 0x02, 0x00a6},
+ /********************/
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ /********************/
+ { 0xa0, 0x04, 0x0098},
+ { 0xa0, 0x0f, 0x009a},
+ { 0xa0, 0x04, 0x011a},
+ { 0xa0, 0x0f, 0x011c},
+ { 0xa0, 0xe8, 0x009c},
+ { 0xa0, 0x02, 0x009d},
+ { 0xa0, 0x88, 0x009e},
+ { 0xa0, 0x06, 0x008d},
+ { 0xa0, 0xf7, 0x0101},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x68, 0x018d},
+ { 0xa0, 0x60, 0x01a8},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ { 0xa0, 0x03, 0x0008},
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ /******* gammaT *****/
+ { 0xa0, 0x04, 0x0120},
+ { 0xa0, 0x16, 0x0121},
+ { 0xa0, 0x30, 0x0122},
+ { 0xa0, 0x4e, 0x0123},
+ { 0xa0, 0x68, 0x0124},
+ { 0xa0, 0x81, 0x0125},
+ { 0xa0, 0x98, 0x0126},
+ { 0xa0, 0xac, 0x0127},
+ { 0xa0, 0xbe, 0x0128},
+ { 0xa0, 0xcd, 0x0129},
+ { 0xa0, 0xda, 0x012a},
+ { 0xa0, 0xe4, 0x012b},
+ { 0xa0, 0xed, 0x012c},
+ { 0xa0, 0xf5, 0x012d},
+ { 0xa0, 0xfb, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x0c, 0x0130},
+ { 0xa0, 0x16, 0x0131},
+ { 0xa0, 0x1b, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x19, 0x0134},
+ { 0xa0, 0x18, 0x0135},
+ { 0xa0, 0x15, 0x0136},
+ { 0xa0, 0x12, 0x0137},
+ { 0xa0, 0x10, 0x0138},
+ { 0xa0, 0x0d, 0x0139},
+ { 0xa0, 0x0b, 0x013a},
+ { 0xa0, 0x09, 0x013b},
+ { 0xa0, 0x08, 0x013c},
+ { 0xa0, 0x06, 0x013d},
+ { 0xa0, 0x05, 0x013e},
+ { 0xa0, 0x03, 0x013f},
+ /********************/
+ { 0xa0, 0x68, 0x010a},
+ { 0xa0, 0xec, 0x010b},
+ { 0xa0, 0xec, 0x010c},
+ { 0xa0, 0xec, 0x010d},
+ { 0xa0, 0x68, 0x010e},
+ { 0xa0, 0xec, 0x010f},
+ { 0xa0, 0xec, 0x0110},
+ { 0xa0, 0xec, 0x0111},
+ { 0xa0, 0x68, 0x0112},
+ /****** MATRIXT *****/
+ { 0xa1, 0x01, 0x018d},
+ { 0xa0, 0x90, 0x018d},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0xa3, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0xa4, 0x0092},
+ { 0xa0, 0x77, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x01, 0x00a3},
+ { 0xa0, 0x77, 0x00a4},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x03, 0x0191},
+ { 0xa0, 0xe8, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x7d, 0x0197},
+ { 0xa0, 0x0c, 0x018c},
+ { 0xa0, 0x18, 0x018f},
+ { 0xa0, 0x08, 0x01a9},
+ { 0xa0, 0x24, 0x01aa},
+ { 0xa0, 0xf0, 0x001d},
+ { 0xa0, 0xf4, 0x001e},
+ { 0xa0, 0xf8, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x03, 0x009f},
+ { 0xa0, 0xc0, 0x00a0},
+ { 0xa0, 0x50, 0x011d},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ /********************/
+ {0,0,0},
+ };
+static __u16 tas5130cxx_scale_data[][3]=
+{
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x01, 0x0000},
+ { 0xa0, 0x40, 0x0002},
+  /*******************/
+ { 0xa0, 0x03, 0x0008},
+ { 0xa1, 0x01, 0x0008},
+ /*******************/
+ { 0xa0, 0x02, 0x0010},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x00, 0x0001},
+ { 0xa0, 0x01, 0x0012},
+ { 0xa0, 0x01, 0x0001},
+ { 0xa0, 0x05, 0x0012},
+ { 0xa0, 0x07, 0x00a5},
+ { 0xa0, 0x02, 0x00a6},
+ { 0xa0, 0x02, 0x0003},
+ { 0xa0, 0x80, 0x0004},
+ { 0xa0, 0x01, 0x0005},
+ { 0xa0, 0xe0, 0x0006},
+ { 0xa0, 0x05, 0x0098},
+ { 0xa0, 0x0f, 0x009a},
+ { 0xa0, 0x05, 0x011a},
+ { 0xa0, 0x0f, 0x011c},
+ { 0xa0, 0xe6, 0x009c},
+ { 0xa0, 0x02, 0x009d},
+ { 0xa0, 0x86, 0x009e},
+ { 0xa0, 0x06, 0x008d},
+ { 0xa0, 0x37, 0x0101},
+ { 0xa0, 0x0d, 0x0100},
+ { 0xa0, 0x06, 0x0189},
+ { 0xa0, 0x68, 0x018d},
+ { 0xa0, 0x60, 0x01a8},
+ { 0xa0, 0x00, 0x01ad},
+ { 0xa0, 0x03, 0x01c5},
+ { 0xa0, 0x13, 0x01cb},
+ { 0xa0, 0x08, 0x0250},
+ { 0xa0, 0x08, 0x0301},
+ { 0xa1, 0x01, 0x0002},
+ { 0xa1, 0x01, 0x0008},
+ /*******************/
+ { 0xa0, 0x03, 0x0008},
+ { 0xa1, 0x01, 0x0008},
+ /*******************/
+ { 0xa0, 0x08, 0x01c6},
+ { 0xa1, 0x01, 0x01c8},
+ { 0xa1, 0x01, 0x01c9},
+ { 0xa1, 0x01, 0x01ca},
+ { 0xa0, 0x0f, 0x01cb},
+ { 0xa0, 0x04, 0x0120},
+ { 0xa0, 0x16, 0x0121},
+ { 0xa0, 0x30, 0x0122},
+ { 0xa0, 0x4e, 0x0123},
+ { 0xa0, 0x68, 0x0124},
+ { 0xa0, 0x81, 0x0125},
+ { 0xa0, 0x98, 0x0126},
+ { 0xa0, 0xac, 0x0127},
+ { 0xa0, 0xbe, 0x0128},
+ { 0xa0, 0xcd, 0x0129},
+ { 0xa0, 0xda, 0x012a},
+ { 0xa0, 0xe4, 0x012b},
+ { 0xa0, 0xed, 0x012c},
+ { 0xa0, 0xf5, 0x012d},
+ { 0xa0, 0xfb, 0x012e},
+ { 0xa0, 0xff, 0x012f},
+ { 0xa0, 0x0c, 0x0130},
+ { 0xa0, 0x16, 0x0131},
+ { 0xa0, 0x1b, 0x0132},
+ { 0xa0, 0x1c, 0x0133},
+ { 0xa0, 0x19, 0x0134},
+ { 0xa0, 0x18, 0x0135},
+ { 0xa0, 0x15, 0x0136},
+ { 0xa0, 0x12, 0x0137},
+ { 0xa0, 0x10, 0x0138},
+ { 0xa0, 0x0d, 0x0139},
+ { 0xa0, 0x0b, 0x013a},
+ { 0xa0, 0x09, 0x013b},
+ { 0xa0, 0x08, 0x013c},
+ { 0xa0, 0x06, 0x013d},
+ { 0xa0, 0x05, 0x013e},
+ { 0xa0, 0x03, 0x013f},
+ /*******************/
+ { 0xa0, 0x68, 0x010a},
+ { 0xa0, 0xec, 0x010b},
+ { 0xa0, 0xec, 0x010c},
+ { 0xa0, 0xec, 0x010d},
+ { 0xa0, 0x68, 0x010e},
+ { 0xa0, 0xec, 0x010f},
+ { 0xa0, 0xec, 0x0110},
+ { 0xa0, 0xec, 0x0111},
+ { 0xa0, 0x68, 0x0112},
+ /*******************/
+ { 0xa1, 0x01, 0x018d},
+ { 0xa0, 0x90, 0x018d},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x00, 0x0180},
+ { 0xa0, 0x00, 0x0019},
+ { 0xa0, 0xa3, 0x0092},
+ { 0xa0, 0x01, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0xa4, 0x0092},
+ { 0xa0, 0x63, 0x0093},
+ { 0xa0, 0x00, 0x0094},
+ { 0xa0, 0x01, 0x0090},
+ { 0xa1, 0x01, 0x0091},
+ { 0xa0, 0x01, 0x00a3},
+ { 0xa0, 0x63, 0x00a4},
+ { 0xa0, 0x00, 0x0190},
+ { 0xa0, 0x02, 0x0191},
+ { 0xa0, 0x38, 0x0192},
+ { 0xa0, 0x00, 0x0195},
+ { 0xa0, 0x00, 0x0196},
+ { 0xa0, 0x47, 0x0197},
+ { 0xa0, 0x0c, 0x018c},
+ { 0xa0, 0x18, 0x018f},
+ { 0xa0, 0x08, 0x01a9},
+ { 0xa0, 0x24, 0x01aa},
+ { 0xa0, 0xd3, 0x001d},
+ { 0xa0, 0xda, 0x001e},
+ { 0xa0, 0xea, 0x001f},
+ { 0xa0, 0xff, 0x0020},
+ { 0xa0, 0x03, 0x009f},
+ { 0xa0, 0x4c, 0x00a0},
+ { 0xa0, 0x50, 0x011d},
+ { 0xa0, 0x40, 0x0180},
+ { 0xa1, 0x01, 0x0180},
+ { 0xa0, 0x42, 0x0180},
+ /********************/
+ {0,0,0},
+ };
+ 
diff -ruN usb_old/spca5xx/zc3xx.h usb/spca5xx/zc3xx.h
--- linux-2.4.31/drivers/usb_old/spca5xx/zc3xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.31/drivers/usb/spca5xx/zc3xx.h	2005-11-21 14:33:20.000000000 +0100
@@ -0,0 +1,559 @@
+ 
+#ifndef ZC3XXUSB_H
+#define ZC3XXUSB_H
+/****************************************************************************
+#	 	Z-star zc301 zc302 P library                                #
+# 		Copyright (C) 2004 Michel Xhaard   mxhaard@magic.fr         #
+#                                                                           #
+# This program is free software; you can redistribute it and/or modify      #
+# it under the terms of the GNU General Public License as published by      #
+# the Free Software Foundation; either version 2 of the License, or         #
+# (at your option) any later version.                                       #
+#                                                                           #
+# This program is distributed in the hope that it will be useful,           #
+# but WITHOUT ANY WARRANTY; without even the implied warranty of            #
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
+# GNU General Public License for more details.                              #
+#                                                                           #
+# You should have received a copy of the GNU General Public License         #
+# along with this program; if not, write to the Free Software               #
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA #
+#                                                                           #
+****************************************************************************/
+#include "tas5130c.h"
+#include "icm105a.h"
+#include "hdcs2020.h"
+#include "hv7131b.h"
+#include "pb0330.h"
+#include "hv7131c.h"
+#include "cs2102.h"
+#include "pas106b.h"
+/*******************     Camera Interface   ***********************/
+static __u16 zc3xx_getbrightness(struct usb_spca50x *spca50x);
+static __u16 zc3xx_getcontrast(struct usb_spca50x *spca50x);
+static void zc3xx_setbrightness(struct usb_spca50x *spca50x);
+static int zc3xx_init(struct usb_spca50x *spca50x );
+static void zc3xx_start(struct usb_spca50x *spca50x );
+static void zc3xx_stop(struct usb_spca50x *spca50x );
+static int zc3xx_config(struct usb_spca50x *spca50x );
+static void zc3xx_shutdown(struct usb_spca50x *spca50x );
+/*******************     Camera Private     ***********************/
+enum {
+SensorId = 0,
+reg8d,
+val8d,
+SensorReg1,
+valSreg1L,
+valSreg1H,
+SensorReg2,
+valSreg2L,
+valSreg2H,
+totval,
+};
+#define VGATOT 8
+static __u8 zcxxi2cSensor [VGATOT][totval]= {
+{ 0x00, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff}, // HV7131B
+{ 0x04, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff}, // CS2102
+{ 0x06, 0x8d, 0x08, 0x11, 0xaa, 0x00, 0xff, 0xff, 0xff},
+{ 0x08, 0xff, 0xff, 0x1c, 0x00, 0x00, 0x15, 0xaa, 0x00}, // HDCS2020 ?
+{ 0x0a, 0xff, 0xff, 0x07, 0xaa, 0xaa, 0xff, 0xff, 0xff}, // MI330 PB330
+{ 0x0c, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff}, // ICM105
+{ 0x0e, 0x8d, 0x08, 0x03, 0xaa, 0x00, 0xff, 0xff, 0xff}, // pas102
+{ 0x02, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},
+};
+#define SIFTOT 1
+static __u8 zcxxi2cSensorSIF [SIFTOT][totval]= {
+#if 0
+{ 0x01, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff}, // corrupt with 0x00 hv7131b reg 0 return 0x01 readonly
+{ 0x05, 0xff, 0xff, 0x01, 0xaa, 0x00, 0xff, 0xff, 0xff},
+{ 0x07, 0x8d, 0x08, 0x11, 0xaa, 0x00, 0xff, 0xff, 0xff},
+{ 0x09, 0xff, 0xff, 0x1c, 0x00, 0x00, 0x15, 0xaa, 0x00}, // corrupt with 0x08 hdcs2020 reg 0 return 0x18 readonly
+{ 0x0b, 0xff, 0xff, 0x07, 0xaa, 0xaa, 0xff, 0xff, 0xff},
+{ 0x0d, 0xff, 0xff, 0x01, 0x11, 0x00, 0xff, 0xff, 0xff}, // corrupt with 0x0c ICM105 reg 0 is writable
+#endif
+{ 0x0f, 0x8d, 0x08, 0x03, 0xaa, 0x00, 0xff, 0xff, 0xff}, // PAS106 reg3 did not write with 0x0e !conflict PAS102 
+};
+static __u8 zcxx3wrSensor [][5]= {
+{ 0x8b, 0xb3, 0x11, 0x12, 0xff},
+{ 0x8b, 0x91, 0x14, 0x15, 0x16},
+{ 0x8b, 0xe0, 0x14, 0x15, 0x16},
+{0,0,0,0,0}
+};
+
+static int zcxx_probeSensor( struct usb_spca50x *spca50x)
+{ __u8 retbyte = 0;
+int i,j;
+/* check i2c */
+/* check SIF */
+	for (i= 0; i< SIFTOT; i++) {
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0000,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][SensorId],0x0010,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0001,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x03,0x0012,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0012,NULL,0);
+	 wait_ms(10);
+	 if (zcxxi2cSensorSIF[i][reg8d] == 0x8d)
+		spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][val8d],0x008d,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][SensorReg1],0x0092,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][valSreg1L],0x0093,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][valSreg1H],0x0094,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0090,NULL,0);
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1); // write byte
+	  wait_ms(10);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][SensorReg1],0x0092,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x02,0x0090,NULL,0); // read byte
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0095,&retbyte,1);
+	  wait_ms(10);
+	 PDEBUG(0,"sensor answer1  %d ",retbyte );
+	 if (retbyte != zcxxi2cSensorSIF[i][valSreg1L])
+	 	continue;
+	 
+	 if (retbyte == zcxxi2cSensorSIF[i][valSreg1L] && zcxxi2cSensorSIF[i][SensorReg2] == 0xff)
+		return zcxxi2cSensorSIF[i][SensorId];
+	
+	 if(zcxxi2cSensorSIF[i][SensorReg2] != 0xff){
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][SensorReg2],0x0092,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][valSreg2L],0x0093,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][valSreg2H],0x0094,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0090,NULL,0);
+	   spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensorSIF[i][SensorReg2],0x0092,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,0x02,0x0090,NULL,0);
+	  spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+	  spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0095,&retbyte,1);
+	  PDEBUG(0,"sensor answer2  %d ",retbyte );
+	  if (retbyte == zcxxi2cSensorSIF[i][valSreg2L])
+		return zcxxi2cSensorSIF[i][SensorId];
+	  
+	 }
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0096,&retbyte,1);
+	}
+/* check VGA */
+	for (i= 0; i< VGATOT; i++) {
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0000,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][SensorId],0x0010,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0001,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x03,0x0012,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0012,NULL,0);
+	 wait_ms(10);
+	 if (zcxxi2cSensor[i][reg8d] == 0x8d)
+		spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][val8d],0x008d,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][SensorReg1],0x0092,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][valSreg1L],0x0093,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][valSreg1H],0x0094,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0090,NULL,0);
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+	 if(zcxxi2cSensor[i][SensorReg2] != 0xff){
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][SensorReg2],0x0092,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][valSreg2L],0x0093,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][valSreg2H],0x0094,NULL,0);
+	   spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0090,NULL,0);
+	   spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+	   spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][SensorReg2],0x0092,NULL,0);
+	 } else {
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxxi2cSensor[i][SensorReg1],0x0092,NULL,0);
+	 }
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x02,0x0090,NULL,0);
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0095,&retbyte,1);
+	 PDEBUG(0,"sensor answervga  %d ",retbyte );
+	 if (retbyte != 0)
+		return zcxxi2cSensor[i][SensorId];
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0096,&retbyte,1);
+	}
+/* check 3 wires bus */
+	i = 0;
+	while (zcxx3wrSensor [i][0]) {
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x02,0x0010,NULL,0);
+	 spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0010,&retbyte,1);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0000,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x00,0x0010,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0001,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,zcxx3wrSensor[i][1],zcxx3wrSensor[i][0],NULL,0);
+	
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x03,0x0012,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0012,NULL,0);
+	 spca5xxRegWrite(spca50x->dev,0xa0,0x05,0x0012,NULL,0);
+	 for (j =2 ; j < 5; j++){
+		if( zcxx3wrSensor[i][j] != 0xff){
+			spca5xxRegWrite(spca50x->dev,0xa0,zcxx3wrSensor[i][j],0x0092,NULL,0);
+			spca5xxRegWrite(spca50x->dev,0xa0,0x02,0x0090,NULL,0);
+			spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0091,&retbyte,1);
+			spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0095,&retbyte,1);
+			if (retbyte != 0)
+				return (i | 0x10);
+			spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0096,&retbyte,1);
+		}
+	 }
+	
+	i++;
+	}
+	return (-1);
+}
+
+static __u16 zc3xxWriteVector(struct usb_spca50x *spca50x,__u16 data[][3])
+{ 
+	struct usb_device *dev=spca50x->dev;
+	int err = 0;
+	int i = 0;
+	__u8 buffread;
+	while (data[i][0]){
+	if (data[i][0] == 0xa0){
+	/* write registers */
+	spca5xxRegWrite(dev,data[i][0],data[i][1],data[i][2],NULL,0);
+	} else {
+	/* read status */
+	spca5xxRegRead(dev,data[i][0],data[i][1],data[i][2],&buffread,1);
+	}
+	i++;
+	udelay(1000);
+	}
+
+return err;
+}
+
+#define CLAMP(x) (unsigned char)(((x)>0xFF)?0xff:(((x)<1)?1:(x)))
+
+static __u8 Tgamma[16]={0x13,0x38,0x59,0x79,0x92,0xa7,0xb9,0xc8,0xd4,0xdf,0xe7,0xee,0xf4,0xf9,0xfc,0xff};
+static __u8 Tgradient[16]={0x26,0x22,0x20,0x1c,0x16,0x13,0x10,0x0d,0x0b,0x09,0x07,0x06,0x05,0x04,0x03,0x02};
+//static __u8 Tgamma[16]={0x24,0x44,0x64,0x84,0x9d,0xb2,0xc4,0xd3,0xe0,0xeb,0xf4,0xff,0xff,0xff,0xff,0xff}; //CS2102
+//static __u8 Tgradient[16]={0x18,0x20,0x20,0x1c,0x16,0x13,0x10,0x0e,0x0b,0x09,0x07,0x00,0x00,0x00,0x00,0x01};
+
+static __u16 zc3xx_getbrightness(struct usb_spca50x *spca50x)
+{	spca50x->brightness = 0x80 << 8;
+	spca50x->contrast = 0x80 << 8;
+	return spca50x->brightness;
+}
+static __u16 zc3xx_getcontrast(struct usb_spca50x *spca50x)
+{
+	
+	return spca50x->contrast;
+}
+
+static void zc3xx_setbrightness(struct usb_spca50x *spca50x)
+{
+	__u16 brightness;
+	__u16 contrast;
+	char deltabright = 0;
+	int  gm0 =0;
+	int gr0 = 0;
+	int index =0;
+	int i;
+	brightness = spca50x->brightness >> 8;
+	/* 0x80 don't touch anything else add or substract brightness
+	to gamma setting leave gradient unchanged */
+	deltabright = brightness - 0x80;
+	/* now get the index of gamma table */
+	contrast=zc3xx_getcontrast(spca50x) ;
+	if((index = contrast >> 13) > 6) index = 6;
+	PDEBUG(2,"starting new table index %d ",index );
+	for(i=0;i < 16; i++){
+	gm0= Tgamma[i]*index >> 2;
+	gr0 = Tgradient[i]*index >> 2;
+		//Tgamma[i] = CLAMP(gm0+deltabright);
+		spca5xxRegWrite(spca50x->dev,0xa0,CLAMP(gm0+deltabright),0x0120+i,NULL,0);
+		spca5xxRegWrite(spca50x->dev,0xa0,CLAMP(gr0),0x0130+i,NULL,0);
+		//PDEBUG(0,"i %d gamma %d gradient %d",i ,Tgamma[i],Tgradient[i]);
+	}
+}
+
+
+
+static int zc3xx_init(	struct usb_spca50x *spca50x )
+{
+ spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0000,NULL,0);	
+	return 0;
+}
+static void set_zc3xxVGA(struct usb_spca50x *spca50x )
+{
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[VGA].width = 640;
+		spca50x->mode_cam[VGA].height = 480;
+		spca50x->mode_cam[VGA].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[VGA].pipe = 1023;
+		spca50x->mode_cam[VGA].method = 0;
+		spca50x->mode_cam[VGA].mode = 0;
+		spca50x->mode_cam[PAL].width = 384;
+		spca50x->mode_cam[PAL].height = 288;
+		spca50x->mode_cam[PAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[PAL].pipe = 1023;
+		spca50x->mode_cam[PAL].method = 1;
+		spca50x->mode_cam[PAL].mode = 0;
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 1;
+		spca50x->mode_cam[SIF].mode = 0;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette = P_JPEG | P_RAW | P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CIF].pipe = 1023;
+		spca50x->mode_cam[CIF].method = 0;
+		spca50x->mode_cam[CIF].mode = 1;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 1023;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 1;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 1023;
+		spca50x->mode_cam[QSIF].method = 1;
+		spca50x->mode_cam[QSIF].mode = 1;
+}
+static void set_zc3xxSIF(struct usb_spca50x *spca50x )
+{
+		memset (spca50x->mode_cam, 0x00, TOTMODE * sizeof(struct mwebcam));
+		spca50x->mode_cam[SIF].width = 352;
+		spca50x->mode_cam[SIF].height = 288;
+		spca50x->mode_cam[SIF].t_palette = P_JPEG | P_RAW |P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[SIF].pipe = 1023;
+		spca50x->mode_cam[SIF].method = 0;
+		spca50x->mode_cam[SIF].mode = 0;
+		spca50x->mode_cam[CIF].width = 320;
+		spca50x->mode_cam[CIF].height = 240;
+		spca50x->mode_cam[CIF].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[CIF].pipe = 1023;
+		spca50x->mode_cam[CIF].method = 1;
+		spca50x->mode_cam[CIF].mode = 0;
+		spca50x->mode_cam[QPAL].width = 192;
+		spca50x->mode_cam[QPAL].height = 144;
+		spca50x->mode_cam[QPAL].t_palette = P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QPAL].pipe = 1023;
+		spca50x->mode_cam[QPAL].method = 1;
+		spca50x->mode_cam[QPAL].mode = 0;
+		spca50x->mode_cam[QSIF].width = 176;
+		spca50x->mode_cam[QSIF].height = 144;
+		spca50x->mode_cam[QSIF].t_palette = P_JPEG | P_RAW |P_YUV420 | P_RGB32 | P_RGB24 | P_RGB16;
+		spca50x->mode_cam[QSIF].pipe = 1023;
+		spca50x->mode_cam[QSIF].method = 0;
+		spca50x->mode_cam[QSIF].mode = 1;
+}
+
+static int zc3xx_config( struct usb_spca50x *spca50x )
+{ 
+	
+	int sensor =0;
+	__u8 bsensor = 0;
+	sensor = zcxx_probeSensor(spca50x);
+	switch (sensor) {
+		case -1:
+		PDEBUG(0,"Find Sensor UNKNOW_0 force Tas5130");
+		spca50x->sensor = SENSOR_TAS5130C;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 0:
+		PDEBUG(0,"Find Sensor HV7131");
+		spca50x->sensor = SENSOR_HV7131B;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 1:
+		PDEBUG(0,"Find Sensor SIF UNKNOW_1");
+		break;
+		case 0x02:
+		PDEBUG(0,"Find Sensor UNKNOW_2");
+		break;
+		case 0x04:
+		PDEBUG(0,"Find Sensor CS2102");
+		spca50x->sensor = SENSOR_CS2102;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 5:
+		PDEBUG(0,"Find Sensor SIF UNKNOW_5");
+		break;
+		case 0x06:
+		PDEBUG(0,"Find Sensor VGA UNKNOW_6");
+		break;
+		case 7:
+		PDEBUG(0,"Find Sensor SIF UNKNOW_7");
+		break;
+		case 0x08:
+		PDEBUG(0,"Find Sensor HDCS2020(b)");
+		spca50x->sensor = SENSOR_HDCS2020b;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 9:
+		PDEBUG(0,"Find Sensor SIF UNKNOW_9");
+		break;
+		case 0x0a:
+		PDEBUG(0,"Find Sensor PB0330");
+		spca50x->sensor = SENSOR_PB0330;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 0x0b:
+		PDEBUG(0,"Find Sensor SIF UNKNOW_b");
+		break;
+		case 0x0c:
+		PDEBUG(0,"Find Sensor ICM105");
+		spca50x->sensor = SENSOR_ICM105A;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 0x0d:
+		PDEBUG(0,"Find Sensor SIF UNKNOW_d");
+		break;
+		case 0x0e:
+		PDEBUG(0,"Find Sensor HDCS2020");
+		spca50x->sensor = SENSOR_HDCS2020;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 0x0f:
+		PDEBUG(0,"Find Sensor PAS106");
+		spca50x->sensor = SENSOR_PAS106;
+		set_zc3xxSIF (spca50x);
+		break;
+		case 0x10:
+		PDEBUG(0,"Find Sensor TAS5130");
+		spca50x->sensor = SENSOR_TAS5130C;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 0x11:
+		PDEBUG(0,"Find Sensor HV7131(c)");
+		spca50x->sensor = SENSOR_HV7131C;
+		set_zc3xxVGA (spca50x);
+		break;
+		case 0x12:
+		PDEBUG(0,"Find Sensor TAS5130");
+		spca50x->sensor = SENSOR_TAS5130C;
+		set_zc3xxVGA (spca50x);
+		break;
+		
+	};
+	if (( sensor == 0x02) || (sensor == 0x06 ) || (sensor == 0x01) || (sensor == 0x05)
+	     || (sensor == 0x07) || (sensor == 0x09) || (sensor == 0x0b) || (sensor == 0x0d)){
+		PDEBUG(0,"Our Sensor is unknow at the moment please report mxhaard@free.fr ");
+		return -EINVAL;
+	}
+	if((sensor == -1) || (sensor == 0x10) || (sensor == 0x12)){
+		spca5xxRegWrite(spca50x->dev,0xa0,0x02,0x0010,NULL,0);
+		spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0010,&bsensor,1);
+	} else {
+		sensor = sensor & 0x0f;
+		spca5xxRegWrite(spca50x->dev,0xa0,sensor,0x0010,NULL,0);
+		spca5xxRegRead(spca50x->dev,0xa1,0x01,0x0010,&bsensor,1);
+	}
+	//  spca5xxRegWrite(spca50x->dev,0xa0,0x01,0x0000,NULL,0);
+	
+	return 0;
+}
+
+static void zc3xx_start(struct usb_spca50x *spca50x )
+{
+	int err = 0;
+	/* Assume start use the good resolution from spca50x->mode */
+	switch (spca50x->sensor){
+		case SENSOR_TAS5130C:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,tas5130cxx_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,tas5130cxx_scale_data);
+			}
+		break;
+		case SENSOR_ICM105A:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,icm105axx_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,icm105axx_scale_data);
+			}
+		break;
+		case SENSOR_HDCS2020:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,hdcs2020xx_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,hdcs2020xx_scale_data);
+			}
+		break;
+		case SENSOR_HDCS2020b:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,hdcs2020xb_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,hdcs2020xb_scale_data);
+			}
+		break;
+		case SENSOR_HV7131B:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,hv7131bxx_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,hv7131bxx_scale_data);
+			}
+		break;
+		case SENSOR_HV7131C:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,hv7131cxx_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,hv7131cxx_scale_data);
+			}
+		break;
+		case SENSOR_PB0330:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,pb0330xx_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,pb0330xx_scale_data);
+			}
+		break;
+		case SENSOR_CS2102:
+			if (spca50x->mode){
+			/* 320x240 */
+			err = zc3xxWriteVector(spca50x,cs2102_start_data);
+			} else {
+			/* 640x480 */
+			err = zc3xxWriteVector(spca50x,cs2102_scale_data);
+			}
+		break;
+		case SENSOR_PAS106:
+			if (spca50x->mode){
+			/* 176x144 */
+			err = zc3xxWriteVector(spca50x,pas106b_start_data);
+			} else {
+			/* 352x288 */
+			err = zc3xxWriteVector(spca50x,pas106b_scale_data);
+			}
+		break;
+	}
+	zc3xx_setbrightness(spca50x);
+	
+}
+
+static void zc3xx_stop(struct usb_spca50x *spca50x )
+{  	
+	
+	//struct usb_device *dev=spca50x->dev;
+	//__u8 buffread;
+	// dont use that will disconnect the cam from usb bus :(
+	// from unkown reason replug the cam did not help
+	// hcd don't accept the device seem only affect via controler
+	// stop is get by set the interface to 0 packetsize 0
+	// and unlink or kill the urb 
+	// spca5xxRegWrite(dev,0xa0,0x01,0x0000,NULL,0);
+	//spca5xxRegRead(dev,0xa1,0x01,0x0180,&buffread,1);
+	//spca5xxRegWrite(dev,0xa0,0x00,0x0180,NULL,0);
+	//spca5xxRegWrite(dev,0xa0,0x01,0x0000,NULL,0);
+}
+static void zc3xx_shutdown(struct usb_spca50x *spca50x )
+{  	
+	
+	struct usb_device *dev=spca50x->dev;
+	__u8 buffread;
+	
+	spca5xxRegRead(dev,0xa1,0x01,0x0180,&buffread,1);
+	spca5xxRegWrite(dev,0xa0,0x00,0x0180,NULL,0);
+	spca5xxRegWrite(dev,0xa0,0x01,0x0000,NULL,0);
+}
+#endif // ZC3XXUSB_H
